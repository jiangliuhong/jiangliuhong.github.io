<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>简单栈练习-最小栈</title>
    <link href="/2020/04/22/Java/leetcode/%E7%AE%80%E5%8D%95%E6%A0%88%E7%BB%83%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88/"/>
    <url>/2020/04/22/Java/leetcode/%E7%AE%80%E5%8D%95%E6%A0%88%E7%BB%83%E4%B9%A0-%E6%9C%80%E5%B0%8F%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目地址：<a href="https://leetcode-cn.com/problems/min-stack/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/min-stack/</a></p></blockquote><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><ul><li><code>push(x)</code> —— 将元素 x 推入栈中。</li><li><code>pop()</code> —— 删除栈顶的元素。</li><li><code>top()</code> —— 获取栈顶元素。</li><li><code>getMin()</code> —— 检索栈中的最小元素。</li></ul><p>示例：</p><pre><code class="hljs plain">输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack &#x3D; new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   --&gt; 返回 -3.minStack.pop();minStack.top();      --&gt; 返回 0.minStack.getMin();   --&gt; 返回 -2.</code></pre><p>提示：</p><ul><li><code>pop</code>、<code>top</code>和<code>getMin</code>操作总是在<code>非空栈</code>上调用。</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jarome.leetcode;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MinStack</span> </span>&#123;    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();    <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MinStack</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;        list.add(x);        min = Math.min(min, x);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (list.size() &gt;= <span class="hljs-number">1</span>) &#123;            Integer remove = list.remove(list.size() - <span class="hljs-number">1</span>);            <span class="hljs-keyword">if</span> (remove &lt;= min) &#123;                <span class="hljs-comment">// 移除的小于等于最小值，重新遍历寻找</span>                min = Integer.MAX_VALUE;                <span class="hljs-keyword">for</span> (Integer integer : list) &#123;                    min = Math.min(min, integer);                &#125;            &#125;        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (list.size() &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"is empty"</span>);        &#125;        <span class="hljs-keyword">return</span> list.get(list.size() - <span class="hljs-number">1</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (list.size() &lt; <span class="hljs-number">1</span>) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"is empty"</span>);        &#125;        <span class="hljs-keyword">return</span> min;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-观察者模式</title>
    <link href="/2020/04/22/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/22/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式●观察者模式"><a href="#设计模式●观察者模式" class="headerlink" title="设计模式●观察者模式"></a>设计模式●观察者模式</h1><p>观察者模式(Observer Pattern)：定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 </p><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>观察者模式包含如下角色：</p><ul><li>Subject: 目标</li><li>ConcreteSubject: 具体目标</li><li>Observer: 观察者</li><li>ConcreteObserver: 具体观察者</li></ul><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="观察者模式"></p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。</li></ul><h2 id="观察者模式优点"><a href="#观察者模式优点" class="headerlink" title="观察者模式优点"></a>观察者模式优点</h2><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求</li></ul><h2 id="观察者模式缺点"><a href="#观察者模式缺点" class="headerlink" title="观察者模式缺点"></a>观察者模式缺点</h2><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h2 id="观察者模式适用环境"><a href="#观察者模式适用环境" class="headerlink" title="观察者模式适用环境"></a>观察者模式适用环境</h2><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h2 id="观察者模式示例"><a href="#观察者模式示例" class="headerlink" title="观察者模式示例"></a>观察者模式示例</h2><p>定义消息通知实体</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Message</span> </span>&#123;    <span class="hljs-comment">/** 消息id */</span>    <span class="hljs-keyword">private</span> String id;    <span class="hljs-comment">/** 消息内容 */</span>    <span class="hljs-keyword">private</span> String value;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Message</span><span class="hljs-params">(String id, String value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> value;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;        <span class="hljs-keyword">this</span>.value = value;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"Message&#123;"</span> +                <span class="hljs-string">"id='"</span> + id + <span class="hljs-string">'\''</span> +                <span class="hljs-string">", value='"</span> + value + <span class="hljs-string">'\''</span> +                <span class="hljs-string">'&#125;'</span>;    &#125;</code></pre><p>定义一个主题接口</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 注册一个观察者</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer observer)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 移除一个观察者</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span></span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通知所有观察者</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p>定义一个主题服务中心</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubjectServer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;    <span class="hljs-keyword">private</span> List&lt;Observer&gt; obs = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();    <span class="hljs-keyword">private</span> Message message;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.obs.add(observer);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer observer)</span> </span>&#123;        <span class="hljs-keyword">this</span>.obs.remove(observer);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">for</span> (Observer observer : obs) &#123;             observer.notify(message);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addMessage</span><span class="hljs-params">(Message message)</span></span>&#123;        <span class="hljs-keyword">this</span>.message = message;        notifyObservers();    &#125;&#125;</code></pre><p>定义一个观察者服务接口</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by jiangliuhong on 2016/10/21. 所有观察者需要实现此接口</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 消息通知</span><span class="hljs-comment">     * </span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 通知内容</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(Message message)</span></span>;&#125;</code></pre><p>定义两个观察者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverOne</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(Message message)</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">":"</span>+message.toString());    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverTwo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(Message message)</span> </span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">":"</span>+message.toString());    &#125;&#125;</code></pre><p>测试主方法：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SubjectServer subjectServer = <span class="hljs-keyword">new</span> SubjectServer();        Observer ob1 = <span class="hljs-keyword">new</span> ObserverOne();        subjectServer.registerObserver(ob1);        Observer ob2 = <span class="hljs-keyword">new</span> ObserverTwo();        subjectServer.registerObserver(ob2);        subjectServer.addMessage(<span class="hljs-keyword">new</span> Message(<span class="hljs-string">"1122"</span>,<span class="hljs-string">"test!test!test!"</span>));    &#125;&#125;</code></pre><p>运行测试方法控制台显示内容如下：</p><pre><code class="hljs tex">priv.jarome.designmode.observer.core.ObserverOne:Message&#123;id='1122', value='test!test!test!'&#125;priv.jarome.designmode.observer.core.ObserverTwo:Message&#123;id='1122', value='test!test!test!'&#125;</code></pre><p>从打印内容不难看出，两个观察者均接受到了主题发布的通知。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>完全平方数</title>
    <link href="/2020/04/22/Java/leetcode/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/"/>
    <url>/2020/04/22/Java/leetcode/%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目地址：<a href="https://leetcode-cn.com/problems/perfect-squares/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/perfect-squares/</a></p></blockquote><p>给定正整数 n，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。</p><p>示例1：</p><pre><code class="hljs plain">输入: n &#x3D; 12输出: 3 解释: 12 &#x3D; 4 + 4 + 4.</code></pre><p>示例2：</p><pre><code class="hljs plain">输入: n &#x3D; 13输出: 2解释: 13 &#x3D; 4 + 9.</code></pre><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="基于BFS实现"><a href="#基于BFS实现" class="headerlink" title="基于BFS实现"></a>基于BFS实现</h3><blockquote><p>首先枚举出所有的值，然后利用BFS进行搜索</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jarome.leetcode;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SolutionNumSquares</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;        List&lt;Integer&gt; sqrtList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 先枚举出所有</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++) &#123;            <span class="hljs-keyword">int</span> sqrt = i * i;            <span class="hljs-keyword">if</span> (sqrt == num) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sqrt &gt; num) &#123;                <span class="hljs-comment">// 已经超过当前数字了就不需要在执行了</span>                <span class="hljs-keyword">break</span>;            &#125;            sqrtList.add(sqrt);        &#125;        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();        queue.offer(num);        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            count = count + <span class="hljs-number">1</span>;            <span class="hljs-comment">// 避免循环加入队列</span>            Set&lt;Integer&gt; temp = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();            <span class="hljs-keyword">int</span> size = queue.size();            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;                Integer poll = queue.poll();                <span class="hljs-keyword">for</span> (Integer sqrt : sqrtList) &#123;                    <span class="hljs-keyword">if</span> (poll.equals(sqrt)) &#123;                        <span class="hljs-keyword">return</span> count;                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (poll &lt; sqrt) &#123;                        <span class="hljs-keyword">break</span>;                    &#125; <span class="hljs-keyword">else</span> &#123;                        <span class="hljs-keyword">int</span> nextVal = poll - sqrt;                        <span class="hljs-keyword">if</span> (!temp.contains(nextVal)) &#123;                            queue.offer(nextVal);                            temp.add(nextVal);                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> count;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SolutionNumSquares sns = <span class="hljs-keyword">new</span> SolutionNumSquares();        System.out.println(sns.numSquares(<span class="hljs-number">12</span>));    &#125;&#125;</code></pre><p>运行情况：</p><ul><li>执行时间：88ms</li><li>内存消耗：41.3MB</li></ul><h3 id="基于动态规划"><a href="#基于动态规划" class="headerlink" title="基于动态规划"></a>基于动态规划</h3><blockquote><p>待完成</p><p>计算公式：num = a * a + b ； b = c * c + d ；以此类推</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-原型模式</title>
    <link href="/2020/04/21/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/21/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式●原型模式"><a href="#设计模式●原型模式" class="headerlink" title="设计模式●原型模式"></a>设计模式●原型模式</h1><blockquote><p>原型模式(<code>Prototype pattern</code>)：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</p></blockquote><p>原型模式是创建型模式的一种,其特点在于通过「复制」一个已经存在的实例来返回新的实例,而不是新建实例。被复制的实例就是我们所称的「原型」，这个原型是可定制的。 </p><p>在提到原型模式时，不得不提起两个概念：深拷贝、浅拷贝</p><ul><li>深拷贝：当一个类的拷贝构造方法，不仅要复制对象的所有非引用成员变量值，还要为引用类型的成员变量创建新的实例，并且初始化为形式参数实例值 。</li><li>浅拷贝：使用一个已知实例对新创建实例的成员变量逐个赋值，这个方式被称为浅拷贝。 </li></ul><p>简单地说：浅拷贝只是复制一个对象，传递引用，不能复制实例。而深拷贝则是对对象内部的引用均可复制，它是创建一个新的实例。</p><h2 id="原型模式结构"><a href="#原型模式结构" class="headerlink" title="原型模式结构"></a>原型模式结构</h2><h3 id="简单原型模式"><a href="#简单原型模式" class="headerlink" title="简单原型模式"></a>简单原型模式</h3><p>原型模式包含如下角色：</p><ul><li>Client：调用类，客户端提出创建对象的请求</li><li>Prototype：原型类，可以是接口，一般情况下是由Java接口或抽象类来实现</li><li>ConcretePrototype：具体角色，该类是被复制的对象</li></ul><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt="原型模式"></p><p>原型模式的核心就是<code>Prototype</code>类，该类必须实现Cloneable，然后重写<code>clone</code>方法，原因是在Java虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出CloneNotSupportedException异常。</p><h3 id="登记形式的原型模式"><a href="#登记形式的原型模式" class="headerlink" title="登记形式的原型模式"></a>登记形式的原型模式</h3><blockquote><p>登记形式的原型模式是较复杂的一种原型模式，它主要是多了一个原型管理器(<code>PrototypeManager</code>)角色，该角色创建具体原型类的对象，并记录每一个被创建的对象。</p></blockquote><p> <img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E5%A4%8D%E6%9D%82%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt="复杂原型模式"></p><h2 id="原型模式优点"><a href="#原型模式优点" class="headerlink" title="原型模式优点"></a>原型模式优点</h2><ul><li>如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也可以提高效率。</li><li>原型模式向客户隐藏了创建对象的复杂性。</li><li>可以使用深克隆保持对象的状态。</li><li>原型模式提供了简化的创建结构。</li></ul><h2 id="原型模式缺点"><a href="#原型模式缺点" class="headerlink" title="原型模式缺点"></a>原型模式缺点</h2><ul><li>在实现深克隆的时候可能需要比较复杂的代码。</li><li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行一个通彻的全盘考量，这对全新的来说并不是很困难，但是对已有的类进行改造的时候，必须要修改其源代码，这就违反了面向对象设计原则中的<code>开闭原则</code>。</li></ul><h2 id="原型模式示例"><a href="#原型模式示例" class="headerlink" title="原型模式示例"></a>原型模式示例</h2><blockquote><p>在该示例中，我们以学生坐车为例</p></blockquote><p>首先定义个学生类与汽车类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> Car car;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, Car car)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.car = car;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">getCar</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> car;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCar</span><span class="hljs-params">(Car car)</span> </span>&#123;        <span class="hljs-keyword">this</span>.car = car;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">"乘坐"</span>+<span class="hljs-keyword">this</span>.car.getName());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Student <span class="hljs-title">clone</span><span class="hljs-params">()</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (Student)<span class="hljs-keyword">super</span>.clone();        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Car</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><p>在定义一个<code>Client</code>类</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Student student1 = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">"小明"</span>,<span class="hljs-keyword">new</span> Car(<span class="hljs-string">"公交车"</span>));        student1.print();        Student student2 = student1.clone();        student2.print();        System.out.println(student1 == student2);        System.out.println(student1.getCar() == student2.getCar());    &#125;&#125;</code></pre><p>运行该类输出结果如下：</p><pre><code class="hljs tex">小明乘坐公交车小明乘坐公交车falsetrue</code></pre><p>从输出结果不难看出，该示例中，两个car变量是相等，说明，该操作只是实现的浅拷贝。下面再介绍一个深拷贝(即，深度克隆)的实现方式：</p><p>首先改造car对象，新建一个<code>CarDeep</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarDeep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CarDeep</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> CarDeep <span class="hljs-title">clone</span><span class="hljs-params">()</span>  </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">return</span> (CarDeep)<span class="hljs-keyword">super</span>.clone();        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre><p>再新建一个<code>StudentDeep</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentDeep</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Student</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentDeep</span><span class="hljs-params">(String name, CarDeep car)</span> </span>&#123;        <span class="hljs-keyword">super</span>(name, car);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Student <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;        StudentDeep student = (StudentDeep) <span class="hljs-keyword">super</span>.clone();        Car car = getCar();        <span class="hljs-keyword">if</span>(car != <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">if</span>(car <span class="hljs-keyword">instanceof</span> CarDeep) &#123;                student.setCar(((CarDeep) car).clone());            &#125;        &#125;        <span class="hljs-keyword">return</span> student;    &#125;&#125;</code></pre><p>测试：</p><pre><code class="hljs java">Student stuDeep1 = <span class="hljs-keyword">new</span> StudentDeep(<span class="hljs-string">"小明"</span>,<span class="hljs-keyword">new</span> CarDeep(<span class="hljs-string">"公交车"</span>));stuDeep1.print();Student stuDeep2 = stuDeep1.clone();stuDeep2.print();System.out.println(stuDeep1 == stuDeep2);System.out.println(stuDeep1.getCar() == stuDeep2.getCar());</code></pre><p>输出结果：</p><pre><code class="hljs tex">小明乘坐公交车小明乘坐公交车falsefalse</code></pre><h2 id="原型模式总结"><a href="#原型模式总结" class="headerlink" title="原型模式总结"></a>原型模式总结</h2><ul><li>克隆分为浅克隆和深克隆两种。 </li><li>原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。 </li><li>我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。 </li><li>如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。 </li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。  </li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 </li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2020/04/21/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/21/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>所谓单例模式，简单来说，就是在整个应用中保证只有一个类的实例存在。就像是Java Web中的application，也就是提供了一个全局变量，用处相当广泛，比如保存全局数据，实现全局性的操作等。 </p></blockquote><p> 在单例模式的实现过程中，需要注意以下三点：</p><ul><li>单例类的构造函数为私有</li><li>提供一个自身的静态私有成员变量</li><li>提供一个公有的静态工厂方法</li></ul><h2 id="单例模式优点"><a href="#单例模式优点" class="headerlink" title="单例模式优点"></a>单例模式优点</h2><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能 。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例 。</li></ul><h2 id="单例模式缺点"><a href="#单例模式缺点" class="headerlink" title="单例模式缺点"></a>单例模式缺点</h2><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难 。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。 </li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h2 id="单例模式示例"><a href="#单例模式示例" class="headerlink" title="单例模式示例"></a>单例模式示例</h2><h3 id="最简单实现-饿汉"><a href="#最简单实现-饿汉" class="headerlink" title="最简单实现(饿汉)"></a>最简单实现(饿汉)</h3><p>外部使用者如果需要使用SingletonClass的实例，只能通过getInstance()方法，并且它的构造方法是private的，这样就保证了只能有一个对象存在。</p><p>缺点：</p><ul><li>资源浪费：无论这个类是否被使用，都会创建一个instance对象 </li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton singleton = <span class="hljs-keyword">new</span> Singleton();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> singleton;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span></span>&#123;    &#125;&#125;</code></pre><h3 id="性能优化–lazy-loaded-懒汉"><a href="#性能优化–lazy-loaded-懒汉" class="headerlink" title="性能优化–lazy loaded(懒汉)"></a>性能优化–lazy loaded(懒汉)</h3><blockquote><p>不推荐使用该模式</p></blockquote><p>对上述的饿汉进行优化，加入懒加载的实现逻辑。在系统调用getInstance方法时才初始化instance。</p><p>缺点：</p><ul><li>非线程安全</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonClass instance = <span class="hljs-keyword">null</span>;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;       instance = <span class="hljs-keyword">new</span> SingletonClass();     &#125;     <span class="hljs-keyword">return</span> instance;   &#125;  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span> </span>&#123;   &#125;&#125;</code></pre><h3 id="线程安全的懒汉模式"><a href="#线程安全的懒汉模式" class="headerlink" title="线程安全的懒汉模式"></a>线程安全的懒汉模式</h3><p>在讨论线程安全时，顺便分析下为什么会产生线程安全问题：</p><ul><li>线程A希望使用SingletonClass，调用getInstance()方法。因为是第一次调用，A就发现instance是null的，于是它开始创建实例，就在这个时候，CPU发生时间片切换。</li><li>线程B开始执行，它要使用SingletonClass，调用getInstance()方法，同样检测到instance是null——注意，这是在A检测完之后切换的，也就是说A并没有来得及创建对象——因此B开始创建。</li><li>B创建完成后，切换到A继续执行，因为它已经检测完了，所以A不会再检测一遍，它会直接创建对象。这样，线程A和B各自拥有一个SingletonClass的对象——单例失败。</li></ul><p><strong>解决办法：</strong>加锁（synchronized  ）。</p><p>只要getInstance（）加上同步锁，一个线程必须等待另外一个线程创建完后才能使用这个方法，这就保证了单例的唯一性。 </p><p>缺点：</p><ul><li>如果存在很多类同时调用或多次调用getInstance方法，则会导致程序响应速度很慢</li></ul><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonClass instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;            instance = <span class="hljs-keyword">new</span> SingletonClass();        &#125;        <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span></span>&#123;    &#125; &#125;</code></pre><h3 id="双重检查锁定-double–checked–locking"><a href="#双重检查锁定-double–checked–locking" class="headerlink" title="双重检查锁定(double–checked–locking)"></a>双重检查锁定(double–checked–locking)</h3><p>在上述代码中，我们解决了懒汉模式的线程安全问题，但是在getInstance方法加锁的方法很笨重，在一定情况下会产生性能问题，所以此处我们再对上面的方式进行优化。虽然getInstance方法存在多次调用，但在单例模式中instance的初始化方法却只会调用一次。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonClass instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span>(SingletonClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;                    instance = <span class="hljs-keyword">new</span> SingletonClass();                &#125;            &#125;        &#125;            <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span></span>&#123;    &#125; &#125;</code></pre><h3 id="并发编程–有序性"><a href="#并发编程–有序性" class="headerlink" title="并发编程–有序性"></a>并发编程–有序性</h3><p>并发编程中，我们通常会遇到以下三个问题： </p><ul><li>原子性：一个操作或多个操作要么全部执行完成且执行过程不被中断，要么就不执行 。</li><li>可见性：当多个线程同时访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值 。</li><li>有序性：程序执行的顺序按照代码的先后顺序执行。</li></ul><p>基于上诉代码不难发现其均违背了<strong>有序性</strong></p><p>初始化Singleton和将对象地址赋给instance字段的顺序是不确定的。在某个线程创建单例对象时，在构造方法被调用之前，就为该对象分配了内存空间并将分配的内存地址赋值给instance字段了，然而该对象可能还没有初始化。若紧接着另外一个线程来调用getInstance，此时instance不是null，但取到的对象还未真正初始化，程序就会出错。 </p><p>在Java里面，可以通过<strong>volatile关键字</strong>来保证一定的“有序性”（具体原理在下一节讲述volatile关键字）。另外可以通过<strong>synchronized和Lock</strong>来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p> <pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> SingletonClass instance = <span class="hljs-keyword">null</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">synchronized</span>(SingletonClass<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>)&#123;                    instance = <span class="hljs-keyword">new</span> SingletonClass();                &#125;            &#125;        &#125;            <span class="hljs-keyword">return</span> instance;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span></span>&#123;    &#125; &#125;</code></pre><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>使用枚举除了线程安全和防止反射调用构造器之外，还提供了自动序列化机制，防止反序列化的时候创建新的对象。因此，《Effective Java》作者推荐使用的方法。 </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Singleton&#123;      instance;      <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">whateverMethod</span><span class="hljs-params">()</span></span>&#123;&#125;      &#125;</code></pre><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>SingletonClass没有static的属性，因此并不会被初始化。直到调用getInstance()的时候，会首先加载SingletonClassInstance类，这个类有一个static的SingletonClass实例，因此需要调用SingletonClass的构造方法，然后getInstance()将把这个内部类的instance返回给使用者。由于这个instance是static的，因此并不会构造多次。</p><p>由于SingletonClassInstance是私有静态内部类，所以不会被其他类知道，同样，static语义也要求不会有多个实例存在。并且，JSL规范定义，类的构造必须是原子性的，非并发的，因此不需要加同步块。同样，由于这个构造是并发的，所以getInstance()也并不需要加同步。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassInstance</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonClass instance = <span class="hljs-keyword">new</span> SingletonClass();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> SingletonClassInstance.instance;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span> </span>&#123;   &#125; &#125;</code></pre><h2 id="补充：被破坏的单例模式"><a href="#补充：被破坏的单例模式" class="headerlink" title="补充：被破坏的单例模式"></a>补充：被破坏的单例模式</h2><p>单例模式真的能够实现实例的唯一性吗？ </p><p>答案是否定的，反射、序列化均可破坏单例模式。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>在第二次实例化的时候，抛出异常</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> isInstanced = <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassInstance</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonClass instance = <span class="hljs-keyword">new</span> SingletonClass();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> SingletonClassInstance.instance;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span> </span>&#123;         <span class="hljs-keyword">if</span>(!instanced)&#123;            instanced = <span class="hljs-keyword">true</span>;        &#125;<span class="hljs-keyword">else</span>&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">"duplicate instance create error!"</span> + SingletonClass<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;          &#125;  &#125; &#125;</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>查看ObjectInputStream源码可发现以下一段代码：</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-keyword">null</span>;&#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;    <span class="hljs-keyword">throw</span> (IOException) <span class="hljs-keyword">new</span> InvalidClassException(desc.forClass().getName(),<span class="hljs-string">"unable to create instance"</span>).initCause(ex);&#125;</code></pre><p>序列化会通过反射调用无参数的构造方法创建一个新的对象。 </p><h4 id="防止序列化破坏单例模式"><a href="#防止序列化破坏单例模式" class="headerlink" title="防止序列化破坏单例模式"></a>防止序列化破坏单例模式</h4><p>只要在Singleton类中定义<code>readResolve</code>就可以解决该问题： </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClass</span> </span>&#123;   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonClassInstance</span> </span>&#123;     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> SingletonClass instance = <span class="hljs-keyword">new</span> SingletonClass();   &#125;   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonClass <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;     <span class="hljs-keyword">return</span> SingletonClassInstance.instance;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SingletonClass</span><span class="hljs-params">()</span> </span>&#123;   &#125;   <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span></span>&#123;      <span class="hljs-keyword">return</span> SingletonClassInstance.instance;  &#125;&#125;</code></pre><p><strong>具体原理请查阅</strong><code>http://www.hollischuang.com/archives/1144</code></p><hr><p><strong>参考资料</strong></p><p><a href="http://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1144</a></p><p><a href="https://blog.csdn.net/jlh912008548/article/details/79448124" target="_blank" rel="noopener">https://blog.csdn.net/jlh912008548/article/details/79448124</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-建造者模式</title>
    <link href="/2020/04/21/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/21/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>造者模式(Builder Pattern)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 </p></blockquote><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。 </p><h2 id="建造者模式结构"><a href="#建造者模式结构" class="headerlink" title="建造者模式结构"></a>建造者模式结构</h2><p>建造者模式包含如下角色：</p><ul><li>Builder：抽象建造者</li><li>ConcreteBuilder：具体建造者</li><li>Director：指挥者</li><li>Product：产品角色</li></ul><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="建造者模式"></p><h2 id="建造者模式优点"><a href="#建造者模式优点" class="headerlink" title="建造者模式优点"></a>建造者模式优点</h2><ul><li>在建造者模式中， <strong>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</strong></li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， <strong>用户使用不同的具体建造者即可得到不同的产品对象</strong> 。</li><li><strong>可以更加精细地控制产品的创建过程</strong> 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li><strong>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</strong></li></ul><h2 id="建造者模式缺点"><a href="#建造者模式缺点" class="headerlink" title="建造者模式缺点"></a>建造者模式缺点</h2><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h2 id="建造者模式示例"><a href="#建造者模式示例" class="headerlink" title="建造者模式示例"></a>建造者模式示例</h2><p>产品角色：Role </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Role</span> </span>&#123;    <span class="hljs-keyword">private</span> String head;    <span class="hljs-keyword">private</span> String face;    <span class="hljs-keyword">private</span> String body;    <span class="hljs-comment">/**生命值*/</span>    <span class="hljs-keyword">private</span> Double hp;    <span class="hljs-comment">/**能量值*/</span>    <span class="hljs-keyword">private</span> Double sp;    <span class="hljs-comment">/**魔法值*/</span>    <span class="hljs-keyword">private</span> Double mp;<span class="hljs-comment">//省略get、set方法</span>&#125;</code></pre><p>抽象建造者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-keyword">protected</span> Role role = <span class="hljs-keyword">new</span> Role();    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHead</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBody</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHp</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSp</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMp</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Role <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> role;    &#125;&#125;</code></pre><p>普通角色建造者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonRoleBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-keyword">private</span> Role role = <span class="hljs-keyword">new</span> Role();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHead</span><span class="hljs-params">()</span> </span>&#123;        role.setBody(<span class="hljs-string">"common head"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span> </span>&#123;        role.setFace(<span class="hljs-string">"common face"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBody</span><span class="hljs-params">()</span> </span>&#123;        role.setBody(<span class="hljs-string">"common body"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHp</span><span class="hljs-params">()</span> </span>&#123;        role.setHp(<span class="hljs-number">100</span>d);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSp</span><span class="hljs-params">()</span> </span>&#123;        role.setSp(<span class="hljs-number">100</span>d);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMp</span><span class="hljs-params">()</span> </span>&#123;        role.setMp(<span class="hljs-number">100</span>d);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Role <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> role;    &#125;&#125;</code></pre><p>超级角色建造者</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperRoleBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;    <span class="hljs-keyword">private</span> Role role = <span class="hljs-keyword">new</span> Role();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHead</span><span class="hljs-params">()</span> </span>&#123;        role.setBody(<span class="hljs-string">"suoer head"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFace</span><span class="hljs-params">()</span> </span>&#123;        role.setFace(<span class="hljs-string">"super face"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildBody</span><span class="hljs-params">()</span> </span>&#123;        role.setBody(<span class="hljs-string">"super body"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildHp</span><span class="hljs-params">()</span> </span>&#123;        role.setHp(<span class="hljs-number">120</span>d);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSp</span><span class="hljs-params">()</span> </span>&#123;        role.setSp(<span class="hljs-number">120</span>d);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildMp</span><span class="hljs-params">()</span> </span>&#123;        role.setMp(<span class="hljs-number">120</span>d);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Role <span class="hljs-title">getResult</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> role;    &#125;&#125;</code></pre><p>指挥者：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">construct</span><span class="hljs-params">(Builder builder)</span></span>&#123;        builder.buildBody();        builder.buildHead();        builder.buildFace();        builder.buildHp();        builder.buildMp();        builder.buildSp();    &#125;&#125;</code></pre><h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。 </li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 </li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。 </li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。 </li></ul><h2 id="建造者模式与工厂模式"><a href="#建造者模式与工厂模式" class="headerlink" title="建造者模式与工厂模式"></a>建造者模式与工厂模式</h2><p>不难看出，建造者模式与工厂模式极为类似，建造者模式仅仅只比工厂模式多了一个“导演类”的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单工厂模式了。 </p><p>与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>打开转盘锁</title>
    <link href="/2020/04/19/Java/leetcode/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/"/>
    <url>/2020/04/19/Java/leetcode/%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目地址：<a href="https://leetcode-cn.com/problems/open-the-lock/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/open-the-lock/</a></p></blockquote><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’ 。每个拨轮可以自由旋转：例如把 ‘9’ 变为  ‘0’，’0’ 变为 ‘9’ 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 ‘0000’ ，一个代表四个拨轮的数字的字符串。</p><p>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。</p><p>示例 1:</p><pre><code class="hljs plain">输入：deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;输出：6解释：可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</code></pre><p>示例 2:</p><pre><code class="hljs plain">输入: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;输出：1解释：把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</code></pre><p>示例 3:</p><pre><code class="hljs plain">输入: deadends &#x3D; [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target &#x3D; &quot;8888&quot;输出：-1解释：无法旋转到目标数字且不被锁定。</code></pre><p>示例 4:</p><pre><code class="hljs plain">输入: deadends &#x3D; [&quot;0000&quot;], target &#x3D; &quot;8888&quot;输出：-1</code></pre><p>提示：</p><p>1.死亡列表 deadends 的长度范围为 [1, 500]。<br>2.目标数字 target 不会在 deadends 之中。<br>3.每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 ‘0000’ 到 ‘9999’ 中产生。</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><blockquote><p>基于广度搜索实现</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jarome.leetcode;<span class="hljs-keyword">import</span> java.util.Arrays;<span class="hljs-keyword">import</span> java.util.HashSet;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">import</span> java.util.Set;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SolutionCenterLock</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String[] deadends = &#123;<span class="hljs-string">"0201"</span>, <span class="hljs-string">"0101"</span>, <span class="hljs-string">"0102"</span>, <span class="hljs-string">"1212"</span>, <span class="hljs-string">"2002"</span>&#125;;        <span class="hljs-comment">// String[] deadends = &#123;"0000"&#125;;</span>        String target = <span class="hljs-string">"0202"</span>;        SolutionCenterLock sc = <span class="hljs-keyword">new</span> SolutionCenterLock();        <span class="hljs-keyword">int</span> res = sc.openLock(deadends, target);        System.out.println(res);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">openLock</span><span class="hljs-params">(String[] deadends, String target)</span> </span>&#123;        Set&lt;String&gt; deadendSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(deadends));        String baseRec = <span class="hljs-string">"0000"</span>;        Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();        queue.offer(baseRec);        Set&lt;String&gt; temp = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();        temp.add(baseRec);        <span class="hljs-keyword">int</span> num = -<span class="hljs-number">1</span>;        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;            <span class="hljs-comment">// 记录当前队列大小</span>            <span class="hljs-keyword">int</span> thisQueueSize = queue.size();            num++;            <span class="hljs-comment">// 处理这一行的数据</span>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; thisQueueSize; row++) &#123;                String thisRec = queue.poll();                <span class="hljs-keyword">if</span> (deadendSet.contains(thisRec)) &#123;                    <span class="hljs-comment">// 阻断，跳过</span>                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-keyword">if</span> (target.equals(thisRec)) &#123;                    <span class="hljs-keyword">return</span> num;                &#125;                <span class="hljs-comment">// 8种可能 4个数字 加1 减1</span>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++) &#123;                        <span class="hljs-keyword">int</span> ji = Integer.parseInt(String.valueOf(thisRec.charAt(i)));                        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">0</span>) &#123;                            ji++;                        &#125; <span class="hljs-keyword">else</span> &#123;                            ji--;                        &#125;                        <span class="hljs-keyword">if</span> (ji &gt; <span class="hljs-number">9</span>) &#123;                            ji = <span class="hljs-number">0</span>;                        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ji &lt; <span class="hljs-number">0</span>) &#123;                            ji = <span class="hljs-number">9</span>;                        &#125;                        String newRec = thisRec.substring(<span class="hljs-number">0</span>, i) + ji + thisRec.substring(i + <span class="hljs-number">1</span>);                        <span class="hljs-comment">// 该点已经操作过了。不进行操作</span>                        <span class="hljs-keyword">if</span> (!temp.contains(newRec)) &#123;                            temp.add(newRec);                            queue.offer(newRec);                        &#125;                    &#125;                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;&#125;</code></pre><p>执行情况：</p><ul><li>执行用时: 223 ms</li><li>内存消耗: 47.2 MB</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-工厂模式</title>
    <link href="/2020/04/19/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2020/04/19/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-工厂模式"><a href="#设计模式-工厂模式" class="headerlink" title="设计模式-工厂模式"></a>设计模式-工厂模式</h1><blockquote><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p></blockquote><p>工厂模式分类三类：（在《设计模式》一书中将简单工厂模式与工厂方法模式合称为工厂方法模式）</p><ul><li>简单工厂模式(Simple Factory)</li><li>工厂方法模式(Factory Method)</li><li>抽象工厂模式(Abstract Factory)</li></ul><h2 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式(Simple Factory)"></a>简单工厂模式(Simple Factory)</h2><blockquote><p>建立一个工厂（一个函数或一个类方法）来制造新的对象。</p></blockquote><p>简单工厂模式(Simple Factory Pattern)：又称为静态工厂方法(Static Factory Method)模式，它属于类创建型模式。在简单工厂模式中，可以根据自变量的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt="简单工厂模式"></p><h3 id="简单工厂模式优点"><a href="#简单工厂模式优点" class="headerlink" title="简单工厂模式优点"></a>简单工厂模式优点</h3><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><h3 id="简单工厂模式缺点"><a href="#简单工厂模式缺点" class="headerlink" title="简单工厂模式缺点"></a>简单工厂模式缺点</h3><ul><li>由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。</li><li>使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。</li><li>系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。</li><li>简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。</li></ul><h3 id="简单工厂模式示例"><a href="#简单工厂模式示例" class="headerlink" title="简单工厂模式示例"></a>简单工厂模式示例</h3><p>定义抽象产品类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 交通工具</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Vehicle</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 汽车基础类</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Car</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vehicle</span> </span>&#123;    <span class="hljs-keyword">private</span> Double speed;    <span class="hljs-keyword">private</span> String name;    Car(Double speed, String name) &#123;        <span class="hljs-keyword">this</span>.speed = speed;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getSpeed</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> speed;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSpeed</span><span class="hljs-params">(Double speed)</span> </span>&#123;        <span class="hljs-keyword">this</span>.speed = speed;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(getName() + <span class="hljs-string">" speed is :"</span> + getSpeed());    &#125;&#125;</code></pre><p>定义具体的汽车实现类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 小汽车</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SedanCar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SedanCar</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-number">200</span>D,<span class="hljs-string">"SedanCar"</span>);    &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 摩托车</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Motobike</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Car</span>  </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Motobike</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">super</span>(<span class="hljs-number">120</span>D, <span class="hljs-string">"Motobike"</span>);    &#125;&#125;</code></pre><p>定义工厂类</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 汽车工厂类</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span></span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarFactory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Vehicle <span class="hljs-title">createCar</span><span class="hljs-params">(CarType carType)</span> </span>&#123;        <span class="hljs-keyword">switch</span> (carType) &#123;            <span class="hljs-keyword">case</span> MOTOBIKE:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Motobike();            <span class="hljs-keyword">case</span> SEDANCAR:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SedanCar();            <span class="hljs-keyword">default</span>:                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        &#125;    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 汽车类别</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> CarType &#123;    <span class="hljs-comment">/** 小汽车 */</span>    SEDANCAR,    <span class="hljs-comment">/** 摩托车 */</span>    MOTOBIKE;&#125;</code></pre><p>模拟运行</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Vehicle v1 = CarFactory.createCar(CarType.MOTOBIKE);        v1.run();        Vehicle v2 = CarFactory.createCar(CarType.SEDANCAR);        v2.run();    &#125;&#125;</code></pre><p>控制台输出</p><pre><code class="hljs text">Motobike speed is :120.0SedanCar speed is :200.0</code></pre><h2 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a>工厂方法模式(Factory Method)</h2><blockquote><p> 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method是一个类的实例化延迟到其子类。</p></blockquote><p> 在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt="工厂方法模式"></p><h3 id="工厂方法模式优点"><a href="#工厂方法模式优点" class="headerlink" title="工厂方法模式优点"></a>工厂方法模式优点</h3><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无需关心创建细节，甚至无需知道具体产品类的类名 </li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，正是因为所有的具体工厂类都具有同一抽象父类 </li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无需修改抽象工厂和抽象产品提供的接口，无需修改客户端，也无需修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了，这样，系统的可扩展性也就变得非常好，完全符合“开闭原则” </li></ul><h3 id="工厂方法模式缺点"><a href="#工厂方法模式缺点" class="headerlink" title="工厂方法模式缺点"></a>工厂方法模式缺点</h3><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销 </li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度 </li></ul><h3 id="工厂方法模式示例"><a href="#工厂方法模式示例" class="headerlink" title="工厂方法模式示例"></a>工厂方法模式示例</h3><p>Factory方法</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 工厂方法接口</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VehicleFacotry</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建交通工具</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CarFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">VehicleFacotry</span> </span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MotobikeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Motobike();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SedanCarFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CarFactory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SedanCar();    &#125;&#125;</code></pre><h2 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h2><blockquote><p>抽象工厂模式提供一个创建一系列或相互依赖的对象的接口，而无需指定它们具体的类。 </p></blockquote><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F.png" srcset="/img/loading.gif" alt="抽象工厂模式"></p><h3 id="抽象工厂模式优点"><a href="#抽象工厂模式优点" class="headerlink" title="抽象工厂模式优点"></a>抽象工厂模式优点</h3><ul><li>隔离了具体类的生成，使得用户不需要知道什么被创建了。 </li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 </li></ul><h3 id="抽象工厂模式缺点"><a href="#抽象工厂模式缺点" class="headerlink" title="抽象工厂模式缺点"></a>抽象工厂模式缺点</h3><ul><li>添加新的产品对像时，难以扩展抽象工厂以便生产新种类的产品。 </li></ul><h3 id="抽象工厂模式示例"><a href="#抽象工厂模式示例" class="headerlink" title="抽象工厂模式示例"></a>抽象工厂模式示例</h3><p>定义ProductB</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tv</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">player</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeTv</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tv</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">player</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"player LeTv"</span>);    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChangTv</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Tv</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">player</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"player ChangTv"</span>);    &#125;&#125;</code></pre><p>定义Factory</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Tv <span class="hljs-title">createTv</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConOneFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Tv <span class="hljs-title">createTv</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LeTv();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Motobike();    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConTwoFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Factory</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Tv <span class="hljs-title">createTv</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ChangTv();    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Vehicle <span class="hljs-title">createVehicle</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SedanCar();    &#125;&#125;</code></pre><hr><p><strong>参考资料</strong></p><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/</a></p><p><a href="https://www.jianshu.com/p/bf8341c75304" target="_blank" rel="noopener">https://www.jianshu.com/p/bf8341c75304</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>岛屿数量</title>
    <link href="/2020/04/18/Java/leetcode/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <url>/2020/04/18/Java/leetcode/%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目地址： <a href="https://leetcode-cn.com/problems/number-of-islands/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/number-of-islands/</a></p></blockquote><p>给定一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，计算岛屿的数量。一个岛被水包围，并且它是通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设网格的四个边均被水包围。</p><p>示例1：</p><pre><code class="hljs plain">输入:11110110101100000000输出: 1</code></pre><p>示例2：</p><pre><code class="hljs plain">输入:11000110000010000011输出: 3</code></pre><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="使用广度优先搜索算法"><a href="#使用广度优先搜索算法" class="headerlink" title="使用广度优先搜索算法"></a>使用广度优先搜索算法</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jarome.leetcode;<span class="hljs-keyword">import</span> java.util.LinkedList;<span class="hljs-keyword">import</span> java.util.Queue;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SolutionIsland</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;        <span class="hljs-keyword">int</span> islandSize = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> ySize = grid.length;        <span class="hljs-comment">// 遍历grid数组</span>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ySize; i++) &#123;            <span class="hljs-keyword">char</span>[] item = grid[i];            <span class="hljs-keyword">int</span> xSize = item.length;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; xSize; j++) &#123;                <span class="hljs-keyword">char</span> itemValue = item[j];                <span class="hljs-keyword">if</span> (itemValue != <span class="hljs-string">'1'</span>) &#123;                    <span class="hljs-comment">// 当前不为1，直接跳过</span>                    <span class="hljs-keyword">continue</span>;                &#125;                <span class="hljs-comment">// 岛屿数加1</span>                islandSize++;                <span class="hljs-comment">// 将当前标记为已处理</span>                grid[i][j] = <span class="hljs-string">'0'</span>;                <span class="hljs-comment">// 队列，用于进行广度搜索</span>                Queue&lt;Point&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;Point&gt;();                Point start = <span class="hljs-keyword">new</span> Point(j, i);                queue.add(start);                <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;                    <span class="hljs-comment">// 移除当前</span>                    Point remove = queue.remove();                    <span class="hljs-keyword">int</span> x = remove.getX();                    <span class="hljs-keyword">int</span> y = remove.getY();                    <span class="hljs-comment">// 分别计算上下左右</span>                    <span class="hljs-comment">// 上</span>                    deal(queue, grid, x, y - <span class="hljs-number">1</span>, xSize, ySize);                    <span class="hljs-comment">// 下</span>                    deal(queue, grid, x, y + <span class="hljs-number">1</span>, xSize, ySize);                    <span class="hljs-comment">// 左</span>                    deal(queue, grid, x - <span class="hljs-number">1</span>, y, xSize, ySize);                    <span class="hljs-comment">// 右</span>                    deal(queue, grid, x + <span class="hljs-number">1</span>, y, xSize, ySize);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> islandSize;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deal</span><span class="hljs-params">(Queue&lt;Point&gt; queue, <span class="hljs-keyword">char</span>[][] grid, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> xSize, <span class="hljs-keyword">int</span> ySize)</span> </span>&#123;        <span class="hljs-keyword">if</span> ((x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; xSize) &amp;&amp; (y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; ySize) &amp;&amp; grid[y][x] == <span class="hljs-string">'1'</span>) &#123;            grid[y][x] = <span class="hljs-string">'0'</span>;            Point next = <span class="hljs-keyword">new</span> Point(x, y);            queue.add(next);        &#125;    &#125;    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> x;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Point</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;            <span class="hljs-keyword">this</span>.x = x;            <span class="hljs-keyword">this</span>.y = y;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getX</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> x;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setX</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;            <span class="hljs-keyword">this</span>.x = x;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getY</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> y;        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setY</span><span class="hljs-params">(<span class="hljs-keyword">int</span> y)</span> </span>&#123;            <span class="hljs-keyword">this</span>.y = y;        &#125;    &#125;&#125;</code></pre><p>运行情况：</p><ul><li>执行时间：6ms</li><li>内存消耗：42.6MB</li></ul><p>分析：</p><ul><li>时间复杂度：O(M×N)，其中 M 和 N 分别为行数和列数。</li><li>空间复杂度：O(min(M,N))，在最坏的情况下（全部为陆地），队列的大小可以达到 min(M，N)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计循环队列</title>
    <link href="/2020/04/14/Java/leetcode/%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <url>/2020/04/14/Java/leetcode/%E8%AE%BE%E8%AE%A1%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目地址：<a href="https://leetcode-cn.com/problems/design-circular-queue/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/design-circular-queue/</a></p></blockquote><p>设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。</p><p>循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。</p><p>你的实现应该支持如下操作：</p><ul><li>MyCircularQueue(k): 构造器，设置队列长度为 k 。</li><li>Front: 从队首获取元素。如果队列为空，返回 -1 。</li><li>Rear: 获取队尾元素。如果队列为空，返回 -1 。</li><li>enQueue(value): 向循环队列插入一个元素。如果成功插入则返回真。</li><li>deQueue(): 从循环队列中删除一个元素。如果成功删除则返回真。</li><li>isEmpty(): 检查循环队列是否为空。</li><li>isFull(): 检查循环队列是否已满。</li></ul><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><blockquote><p>使用一个一维数组实现</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.jarome.leetcode;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCircularQueue</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] queue;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> head;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> total;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;    <span class="hljs-comment">/** Initialize your data structure here. Set the size of the queue to be k. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyCircularQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;        <span class="hljs-keyword">this</span>.queue = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];        <span class="hljs-keyword">this</span>.total = k;        <span class="hljs-keyword">this</span>.head = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.size = <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/** Insert an element into the circular queue. Return true if the operation is successful. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">enQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;        <span class="hljs-keyword">if</span> (isFull()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">this</span>.size++;        <span class="hljs-keyword">int</span> tail = getTail();        <span class="hljs-keyword">this</span>.queue[tail] = value;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/** Delete an element from the circular queue. Return true if the operation is successful. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">deQueue</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        <span class="hljs-keyword">this</span>.size--;        <span class="hljs-keyword">this</span>.head = (<span class="hljs-keyword">this</span>.head + <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.total;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-comment">/** Get the front item from the queue. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Front</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue[<span class="hljs-keyword">this</span>.head];    &#125;    <span class="hljs-comment">/** Get the last item from the queue. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Rear</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (isEmpty()) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">int</span> tail = getTail();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.queue[tail];    &#125;    <span class="hljs-comment">/** Checks whether the circular queue is empty or not. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.size == <span class="hljs-number">0</span>;    &#125;    <span class="hljs-comment">/** Checks whether the circular queue is full or not. */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFull</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.total == <span class="hljs-keyword">this</span>.size;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getTail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.head + <span class="hljs-keyword">this</span>.size - <span class="hljs-number">1</span>) % <span class="hljs-keyword">this</span>.total;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算两数之和</title>
    <link href="/2020/04/13/Java/leetcode/%E8%AE%A1%E7%AE%97%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
    <url>/2020/04/13/Java/leetcode/%E8%AE%A1%E7%AE%97%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="计算两数之和"><a href="#计算两数之和" class="headerlink" title="计算两数之和"></a>计算两数之和</h1><blockquote><p>第一次做<code>leetcode</code>题目，先拿一个最简单的练下手。</p></blockquote><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><blockquote><p>题目地址：<a href="https://leetcode-cn.com/problems/two-sum" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum</a></p></blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><p>给定 nums = [2, 7, 11, 15], target = 9</p><p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><blockquote><p>暴力破解法</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; nums.length; j++) &#123;              <span class="hljs-keyword">if</span> (i == j) &#123;                  <span class="hljs-keyword">continue</span>;              &#125;              <span class="hljs-keyword">if</span> (nums[i] + nums[j] == target) &#123;                  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;i, j&#125;;              &#125;          &#125;      &#125;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;  &#125;</code></pre><p>运行消耗：</p><ul><li>执行时间：102 ms</li><li>内存消耗：39.7 MB</li></ul><p>时间复杂度：O(n^2)<br>对于每个元素，我们试图通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费 O(n)O(n) 的时间。因此时间复杂度为 O(n^2)。</p><p>空间复杂度：O(1)。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>利用Map数据结构，每次循环时使用目标值减去当前值，如果结果在map中存在，直接返回，不存在，并将当前值存储在map中，方便下次循环判断。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;        Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;            <span class="hljs-keyword">int</span> res = target - nums[i];            <span class="hljs-keyword">if</span> (map.containsKey(res)) &#123;                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;map.get(res), i&#125;;            &#125;            <span class="hljs-keyword">if</span> (!map.containsKey(nums[i])) &#123;                map.put(nums[i], i);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;</code></pre><p>运行消耗：</p><ul><li>4 ms</li><li>内存消耗：40.1 MB</li></ul><p>时间复杂度：由于只有一个for循环，所以时间复杂度为O(1)<br>空间复杂度：只需要将数组中的存储到map中，所有空间复杂度为O(1)</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020年目标</title>
    <link href="/2020/04/12/study/2020_study/"/>
    <url>/2020/04/12/study/2020_study/</url>
    
    <content type="html"><![CDATA[<blockquote><p>2020年的学习目标，共分为4个主题，针对每个主题的记录相应的博文以作为关键成果验证。</p></blockquote><h2 id="阅读深入理解JVM虚拟机"><a href="#阅读深入理解JVM虚拟机" class="headerlink" title="阅读深入理解JVM虚拟机"></a>阅读<code>深入理解JVM虚拟机</code></h2><h2 id="Leetcode完成100题"><a href="#Leetcode完成100题" class="headerlink" title="Leetcode完成100题"></a>Leetcode完成100题</h2><table><thead><tr><th>序号</th><th>题目</th><th>日期</th><th>文章</th></tr></thead><tbody><tr><td>1</td><td>计算两数之和</td><td>2020-04-13</td><td><a href="/2020/04/13/Java/leetcode/计算两数之和/">点击跳转</a></td></tr><tr><td>2</td><td>设计循环队列</td><td>2020-04-14</td><td><a href="/2020/04/14/Java/leetcode/设计循环队列/">点击跳转</a></td></tr><tr><td>3</td><td>岛屿数量</td><td>2020-04-18</td><td><a href="/2020/04/18/Java/leetcode/岛屿数量/">点击跳转</a></td></tr><tr><td>4</td><td>打开转盘锁</td><td>2020-04-19</td><td><a href="/2020/04/19/Java/leetcode/打开转盘锁/">点击跳转</a></td></tr><tr><td>5</td><td>完全平方数</td><td>2020-04-22</td><td><a href="/2020/04/22/Java/leetcode/完全平方数/">点击跳转</a></td></tr><tr><td>6</td><td>简单栈练习-最小栈</td><td>2020-04-22</td><td><a href="/2020/04/22/Java/leetcode/简单栈练习-最小栈/">点击跳转</a></td></tr></tbody></table><h2 id="完成github上的redis-desktop项目"><a href="#完成github上的redis-desktop项目" class="headerlink" title="完成github上的redis-desktop项目"></a>完成<code>github</code>上的<code>redis-desktop</code>项目</h2><p>github地址：<a href="https://github.com/jiangliuhong/redis-desktop" target="_blank" rel="noopener">https://github.com/jiangliuhong/redis-desktop</a></p><h2 id="Aspose学习"><a href="#Aspose学习" class="headerlink" title="Aspose学习"></a>Aspose学习</h2><h2 id="学习C-模拟调用系统进程"><a href="#学习C-模拟调用系统进程" class="headerlink" title="学习C#模拟调用系统进程"></a>学习C#模拟调用系统进程</h2><h2 id="全面学习设计模式"><a href="#全面学习设计模式" class="headerlink" title="全面学习设计模式"></a>全面学习设计模式</h2><ol><li><a href="/2018/07/16/Java/设计模式/面向对象设计-设计原则/">面向对象设计-设计原则</a></li><li><a href="/2018/07/14/Java/设计模式/设计模式-总览/">设计模式-总览</a></li><li><a href="/2020/04/19/Java/设计模式/设计模式-工厂模式/">设计模式-工厂模式</a></li><li><a href="/2020/04/21/Java/设计模式/设计模式-建造者模式/">设计模式-建造者模式</a></li><li><a href="/2020/04/21/Java/设计模式/设计模式-单例模式/">设计模式-单例模式</a></li><li><a href="/2020/04/21/Java/设计模式/设计模式-原型模式/">设计模式-原型模式</a></li><li><a href="/2020/04/22/Java/设计模式/设计模式-观察者模式/">设计模式-观察者模式</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea单元测试resolving maven dependencies</title>
    <link href="/2020/04/09/normal/idea%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95resolving-maven-dependencies/"/>
    <url>/2020/04/09/normal/idea%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95resolving-maven-dependencies/</url>
    
    <content type="html"><![CDATA[<p>最近在springboot项目中进行单元测试时，遇见这样一个问题，显示卡在这样一个画面：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/other/idea-test-junit-platform.png" srcset="/img/loading.gif" alt=""></p><p>然后出现这样一个错误：</p><pre><code class="hljs plain">Error running &#39;AuditApplicationTests.contextLoads&#39;: Failed to resolve org.junit.platform:junit-platform-launcher:1.5.2</code></pre><p>springboot版本：2.2.6.RELEASE</p><p>idea版本：2019.3.4</p><p>解决办法：在项目的<code>pom.xml</code>文件中加入如下依赖</p><pre><code class="hljs plain">&lt;dependency&gt;&lt;groupId&gt;org.junit.platform&lt;&#x2F;groupId&gt;&lt;artifactId&gt;junit-platform-launcher&lt;&#x2F;artifactId&gt;&lt;scope&gt;test&lt;&#x2F;scope&gt;&lt;&#x2F;dependency&gt;</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nodejs连接redis</title>
    <link href="/2020/04/08/normal/nodejs%E8%BF%9E%E6%8E%A5redis/"/>
    <url>/2020/04/08/normal/nodejs%E8%BF%9E%E6%8E%A5redis/</url>
    
    <content type="html"><![CDATA[<h2 id="引入依赖包"><a href="#引入依赖包" class="headerlink" title="引入依赖包"></a>引入依赖包</h2><pre><code class="hljs plain">npm install redis --save</code></pre><h2 id="工具类模式redisUtil"><a href="#工具类模式redisUtil" class="headerlink" title="工具类模式redisUtil"></a>工具类模式redisUtil</h2><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> redis <span class="hljs-keyword">from</span> <span class="hljs-string">'redis'</span>;<span class="hljs-keyword">const</span> redisUtil = &#123;    config: &#123;        url: <span class="hljs-string">'localhost'</span>,        port: <span class="hljs-string">'6379'</span>,        password: <span class="hljs-string">'123456'</span>    &#125;,    client: <span class="hljs-literal">null</span>,    createClient(conf) &#123;        <span class="hljs-keyword">this</span>.client = redis.createClient(conf.port, conf.url, &#123;&#125;);        <span class="hljs-keyword">this</span>.client.auth(conf.password, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(res);        &#125;);        <span class="hljs-keyword">const</span> _this = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">this</span>.client.on(<span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            _this.client.set(<span class="hljs-string">'author'</span>, <span class="hljs-string">'Wilson'</span>, redis.print);            _this.client.get(<span class="hljs-string">'author'</span>, redis.print);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'connect'</span>);        &#125;);        <span class="hljs-keyword">this</span>.client.on(<span class="hljs-string">'ready'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ready'</span>);        &#125;);    &#125;,    getClient()&#123;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.client == <span class="hljs-literal">null</span>)&#123;            <span class="hljs-keyword">this</span>.createClient(<span class="hljs-keyword">this</span>.config);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.client;    &#125;,    setKey(key, value) &#123;        <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">this</span>.getClient();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            client.set(key, value, (err, replay) =&gt; &#123;                <span class="hljs-keyword">if</span> (err) &#123;                    reject(err);                &#125; <span class="hljs-keyword">else</span> &#123;                    resolve(replay);                &#125;            &#125;)        &#125;)    &#125;,    getKey(key) &#123;        <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">this</span>.getClient();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            client.get(key, (err, replay) =&gt; &#123;                <span class="hljs-keyword">if</span> (err) &#123;                    reject(err);                &#125; <span class="hljs-keyword">else</span> &#123;                    resolve(replay);                &#125;            &#125;)        &#125;)    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> redisUtil;</code></pre><h2 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h2><blockquote><p>es6语法</p></blockquote><h3 id="定义一个RedisClient对象"><a href="#定义一个RedisClient对象" class="headerlink" title="定义一个RedisClient对象"></a>定义一个RedisClient对象</h3><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> redis <span class="hljs-keyword">from</span> <span class="hljs-string">'redis'</span>;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisClient</span> </span>&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 构造函数</span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>config </span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">constructor</span>(config) &#123;        <span class="hljs-keyword">this</span>.config = config;        <span class="hljs-keyword">this</span>.client = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 创建连接</span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>conf 配置信息</span><span class="hljs-comment">     */</span>    createClient(conf) &#123;        <span class="hljs-keyword">this</span>.client = redis.createClient(conf.port, conf.url, &#123;&#125;);        <span class="hljs-keyword">this</span>.client.auth(conf.password, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(res);        &#125;);        <span class="hljs-keyword">const</span> _this = <span class="hljs-keyword">this</span>;        <span class="hljs-keyword">this</span>.client.on(<span class="hljs-string">'connect'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            _this.client.set(<span class="hljs-string">'author'</span>, <span class="hljs-string">'Wilson'</span>, redis.print);            _this.client.get(<span class="hljs-string">'author'</span>, redis.print);            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'connect'</span>);        &#125;);        <span class="hljs-keyword">this</span>.client.on(<span class="hljs-string">'ready'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'ready'</span>);        &#125;);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取链接</span><span class="hljs-comment">     */</span>    getClient() &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.client == <span class="hljs-literal">null</span>) &#123;            <span class="hljs-keyword">this</span>.createClient(<span class="hljs-keyword">this</span>.config);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.client;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 设置值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span> </span>key </span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>value </span><span class="hljs-comment">     */</span>    setKey(key, value) &#123;        <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">this</span>.getClient();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            client.set(key, value, (err, replay) =&gt; &#123;                <span class="hljs-keyword">if</span> (err) &#123;                    reject(err);                &#125; <span class="hljs-keyword">else</span> &#123;                    resolve(replay);                &#125;            &#125;)        &#125;)    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取值</span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span></span>&#125; key </span><span class="hljs-comment">     */</span>    getKey(key) &#123;        <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">this</span>.getClient();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            client.get(key, (err, replay) =&gt; &#123;                <span class="hljs-keyword">if</span> (err) &#123;                    reject(err);                &#125; <span class="hljs-keyword">else</span> &#123;                    resolve(replay);                &#125;            &#125;)        &#125;)    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 查询key</span><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;String&#125;</span></span>&#125; pattern </span><span class="hljs-comment">     */</span>    keys(pattern) &#123;        <span class="hljs-keyword">const</span> client = <span class="hljs-keyword">this</span>.getClient();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            client.keys(pattern, (err, replay) =&gt; &#123;                <span class="hljs-keyword">if</span> (err) &#123;                    reject(err);                &#125; <span class="hljs-keyword">else</span> &#123;                    resolve(replay);                &#125;            &#125;);        &#125;);    &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> RedisClient;</code></pre><h3 id="对象的使用方法"><a href="#对象的使用方法" class="headerlink" title="对象的使用方法"></a>对象的使用方法</h3><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> RedisClient <span class="hljs-keyword">from</span> <span class="hljs-string">"./js/app/RedisClient"</span>;<span class="hljs-keyword">const</span> config = &#123;    url: <span class="hljs-string">"localhost"</span>,    port: <span class="hljs-string">"6379"</span>,    password: <span class="hljs-string">"123456"</span>&#125;;<span class="hljs-keyword">const</span> rc = <span class="hljs-keyword">new</span> RedisClient(config);rc.getKey(<span class="hljs-string">"test2"</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(res);&#125;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm源设置</title>
    <link href="/2020/04/08/normal/npm%E6%BA%90%E8%AE%BE%E7%BD%AE/"/>
    <url>/2020/04/08/normal/npm%E6%BA%90%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="将npm的源替换成淘宝的源"><a href="#将npm的源替换成淘宝的源" class="headerlink" title="将npm的源替换成淘宝的源"></a>将npm的源替换成淘宝的源</h2><pre><code class="hljs plain">npm config set registry http:&#x2F;&#x2F;registry.npm.taobao.org&#x2F;</code></pre><p><strong>修改后面的地址，也可以更换为私有源</strong></p><h2 id="修改源地址为官方源"><a href="#修改源地址为官方源" class="headerlink" title="修改源地址为官方源"></a>修改源地址为官方源</h2><pre><code class="hljs plain">npm config set registry https:&#x2F;&#x2F;registry.npmjs.org&#x2F;</code></pre><h2 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h2><pre><code class="hljs plain">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7把home目录空间转移到其他目录</title>
    <link href="/2020/04/08/normal/centos7%E6%8A%8Ahome%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%9B%AE%E5%BD%95/"/>
    <url>/2020/04/08/normal/centos7%E6%8A%8Ahome%E7%9B%AE%E5%BD%95%E7%A9%BA%E9%97%B4%E8%BD%AC%E7%A7%BB%E5%88%B0%E5%85%B6%E4%BB%96%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>1.重启电脑<br>以root用户直接登陆（这是为了解决/home目录被占用的情况，也可以使用其它方式终止/home被占用，不过这样最直接）<br>2.卸载/home<br>umount /home<br>​3.删除/home所在的lv逻辑卷<br>lvremove /dev/centos00/home<br>小提示：如果不知道你的/home目录的路径，可以使用lvscan命令查看逻辑卷都有哪些，例如我的查<br>5.扩展/root所在的lv，增加100G<br>lvextend -L +100G  /dev/centos00/root<br>​6.扩展/root文件系统<br>xfs_growfs  /dev/centos00/root<br>7.重新创建home lv<br>lvcreate -L 70G -n home centos00<br>home：代表新建lv的名字<br>centos00：代表vg卷组的名字<br>而创建好之后，访问它的路径应该是：/dev/centos00/home（这个是路径的名字）<br>​8.创建文件系统<br>mkfs.xfs  /dev/centos00/home<br>9.挂载<br>​mount  /dev/centos00/home  /home</p><p>设置时间<br>timedatectl 命令<br>(1) 读取时间<br>timedatectl //等同于 timedatectl status<br>(2) 设置时间<br>timedatectl set-time “YYYY-MM-DD HH:MM:SS”<br>(3) 列出所有时区<br>timedatectl list-timezones<br>(4) 设置时区<br>timedatectl set-timezone Asia/Shanghai<br>(5) 是否NTP服务器同步<br>timedatectl set-ntp yes //yes或者no<br>(6) 将硬件时钟调整为与本地时钟一致<br>timedatectl set-local-rtc 1<br>hwclock –systohc –localtime //与上面命令效果一致</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>elasticsearch安装教程及异常解决方法</title>
    <link href="/2020/04/06/database/elastic/elasticsearch%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <url>/2020/04/06/database/elastic/elasticsearch%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%E5%8F%8A%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>安装elasticsearch之前请确认操作系统中具备jdk1.8环境</p><p>本文基于centos6.5环境</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先前往elastic官网下载，下载地址：<a href="https://www.elastic.co/downloads/elasticsearch" target="_blank" rel="noopener">https://www.elastic.co/downloads/elasticsearch</a></p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/other/elasticsearchdownload.png" srcset="/img/loading.gif" alt="elasticsearchdownload"></p><p>你可以根据自己操作系统选择对应的安装包。</p><p><strong>linux步骤：</strong></p><pre><code class="hljs plain">#weget https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;elasticsearch&#x2F;elasticsearch-6.6.0.tar.gz#tar -zvxf elasticsearch-6.6.0.tar.gz#useradd elasticsearch#chmod +R 777 elasticsearch#su elasticsearch#cd elasticsearch-6.6.0#.&#x2F;bin&#x2F;elasticsearch</code></pre><p>由于elasticsearch不允许使用root账号启动，如果使用root用户执行脚本，则会报如下错误，所以需要新建一个<code>elasticsearch</code>用户启动程序。</p><p><strong>root用户启动异常:</strong></p><pre><code class="hljs plain">Exception in thread &quot;main&quot; java.nio.file.AccessDeniedException: &#x2F;usr&#x2F;local&#x2F;jarome&#x2F;elasticsearch-6.6.0&#x2F;config&#x2F;jvm.options        at sun.nio.fs.UnixException.translateToIOException(UnixException.java:84)        at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:102)        at sun.nio.fs.UnixException.rethrowAsIOException(UnixException.java:107)        at sun.nio.fs.UnixFileSystemProvider.newByteChannel(UnixFileSystemProvider.java:214)        at java.nio.file.Files.newByteChannel(Files.java:361)        at java.nio.file.Files.newByteChannel(Files.java:407)        at java.nio.file.spi.FileSystemProvider.newInputStream(FileSystemProvider.java:384)        at java.nio.file.Files.newInputStream(Files.java:152)        at org.elasticsearch.tools.launchers.JvmOptionsParser.main(JvmOptionsParser.java:60)</code></pre><h2 id="启动异常"><a href="#启动异常" class="headerlink" title="启动异常"></a>启动异常</h2><p>1.当操作系统vm.max_map_count配置过低（即：sysctl.conf文件配置过低）时，启动<code>elasticsearch</code>会报如下错误：</p><pre><code class="hljs plain">max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]</code></pre><p>解决办法：</p><p>临时修改（该方法重启系统会失效）：</p><pre><code class="hljs plain"># sysctl -w vm.max_map_count&#x3D;262144</code></pre><p>永久修改：</p><pre><code class="hljs plain"># vim &#x2F;etc&#x2F;sysctl.conf</code></pre><p>在该文件中增加如下内容:</p><pre><code class="hljs plain"># elasticsearch config startvm.max_map_count&#x3D;262144# elasticsearch config end</code></pre><p>然后使用<code>sysctl -p</code>命令使修改生效。</p><p>2.操作系统安全检车检测配置限制过低（即：limits.conf文件置过低）时，启动<code>elasticsearch</code>会报如下错误：</p><pre><code class="hljs plain">max file descriptors [4096] for elasticsearch process is too low, increase to at least [65536]</code></pre><p>解决办法：</p><pre><code class="hljs plain"># vim &#x2F;etc&#x2F;security&#x2F;limits.conf</code></pre><p>追加如下内容：</p><pre><code class="hljs plain"># elasticsearch config start* soft nofile 65536* hard nofile 131072* soft nproc 2048* hard nproc 4096# elasticsearch config end</code></pre><p>3.启动节点异常</p><p>错误日志如下：</p><pre><code class="hljs plain">maybe these locations are not writable or multiple nodes were started without increasing [node.max_local_storage_nodes] (was [1])</code></pre><p>解决方法：</p><p>增加<code>node.max_local_storage_nodes</code>的值，如：</p><pre><code class="hljs plain">node.max_local_storage_nodes: 2</code></pre><p>出现该异常的原因我不是特别清楚，如果你清知道，请留言告诉我一下</p><h2 id="配置局域网访问"><a href="#配置局域网访问" class="headerlink" title="配置局域网访问"></a>配置局域网访问</h2><p>默认环境下，elasticsearch仅允许<code>localhost</code>访问其服务，如果需要在局域网中访问，需要修改其配置文件<code>elasticsearch.yml</code>中的<code>network.host</code>配置项，例如：</p><pre><code class="hljs plain">network.host: 您的ip</code></pre><p>当然，你也可以将<code>network.host</code>设置为<code>0.0.0.0</code></p><h2 id="开启跨域访问支持"><a href="#开启跨域访问支持" class="headerlink" title="开启跨域访问支持"></a>开启跨域访问支持</h2><p>开启跨域访问支持只需要在配置文件中加入以下配置即可：</p><pre><code class="hljs plain">#开启跨域访问支持，默认为falsehttp.cors.enabled: true#跨域访问允许的域名地址，(允许所有域名)以上使用正则http.cors.allow-origin: &#x2F;.*&#x2F;</code></pre><h2 id="elasticsearch-head使用"><a href="#elasticsearch-head使用" class="headerlink" title="elasticsearch-head使用"></a>elasticsearch-head使用</h2><p>在github上有一个测试elasticsearch的开源工具：<code>elasticsearch-head</code>,<code>github</code>地址为：<a href="https://github.com/mobz/elasticsearch-head" target="_blank" rel="noopener">https://github.com/mobz/elasticsearch-head</a></p><p>使用该工具之前，你应该确保你的操作系统具有<code>npm</code>环境。</p><p>启动教程：</p><pre><code class="hljs plain">git clone git:&#x2F;&#x2F;github.com&#x2F;mobz&#x2F;elasticsearch-head.gitcd elasticsearch-headnpm installnpm run startopen http:&#x2F;&#x2F;localhost:9100&#x2F;</code></pre><p>该工具默认访问链接为<code>localhost:9200的</code>elasticsearch服务，当然你也可以在界面上输入其他ip地址，前提是你输入的<code>elasticsearch</code>服务开启了跨域访问支持。</p><p>elasticsearch-head截图如下：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/other/elasticsearch-head.png" srcset="/img/loading.gif" alt="elasticsearch-head"></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>elastic</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java调试体系总结</title>
    <link href="/2020/04/05/Java/tools/Java%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/"/>
    <url>/2020/04/05/Java/tools/Java%E8%B0%83%E8%AF%95%E4%BD%93%E7%B3%BB%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文为<code>JPDA</code>、<code>本地调试</code>、<code>远程调试</code>的总结内容</p></blockquote><h2 id="JPDA"><a href="#JPDA" class="headerlink" title="JPDA"></a>JPDA</h2><blockquote><p><code>JPDA</code>是<code>Java SE</code>1.2.2版本推出的Java凭条调试体系结构工具集，而从<code>JDK1.3.x</code>开始，JavaSDK就提供了对Java平台调试体系结构的直接支持。这个体系为开发人员提供了一整套用于调试 Java 程序的 API，是一套用于开发 Java 调试工具的接口和协议。</p></blockquote><h3 id="JADA组成模块"><a href="#JADA组成模块" class="headerlink" title="JADA组成模块"></a>JADA组成模块</h3><p><code>JPDA</code>定义了一个完整独立的体系，它主要分为三个独立的层次，分别为：Java虚拟机工具接口(<code>JVMTI</code>)、Java调试线协议(<code>JDWP</code>)以及Java调试接口(<code>JDI</code>)。其中，我们可以把<code>JVMTI</code>理解为调试者(<code>debugger</code>)，把<code>JDI</code>理解为被调试者<code>debuggee</code>，对用的层次见下图：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/JPDA%E6%A8%A1%E5%9D%97%E5%B1%82%E6%AC%A1.jpg" srcset="/img/loading.gif" alt="JPDA模块层次"></p><p>通过该图，我们不难看出，<code>JDWP</code>是调试者与被调试者之间的桥梁，两者之间的交互都是通过<code>JDWP</code>进行传输。</p><h3 id="Java-虚拟机工具接口（JVMTI）"><a href="#Java-虚拟机工具接口（JVMTI）" class="headerlink" title="Java 虚拟机工具接口（JVMTI）"></a>Java 虚拟机工具接口（JVMTI）</h3><p>JDWP（Java Debug Wire Protocol）是一个为 Java 调试而设计的一个通讯交互协议，它定义了调试器和被调试程序之间传递的信息的格式。</p><p>它是一套由Java虚拟机直接提供的<code>native</code>接口，它处于整个<code>JPDA</code>体系的最底层，所有调试功能本质上都需要通过<code>JVMTI</code>来提供。同时我们开发人员还可以查看它们运行的状态，设置回调函数，控制某些环境变量，从而优化程序性能。</p><h3 id="Java-调试线协议（JDWP）"><a href="#Java-调试线协议（JDWP）" class="headerlink" title="Java 调试线协议（JDWP）"></a>Java 调试线协议（JDWP）</h3><p>JDWP（Java Debug Wire Protocol）是一个为 Java 调试而设计的一个通讯交互协议，它定义了调试器和被调试程序之间传递的信息的格式。在 JPDA 体系中，作为前端（front-end）的调试者（debugger）进程和后端（back-end）的被调试程序（debuggee）进程之间的交互数据的格式就是由 JDWP 来描述的，它详细完整地定义了请求命令、回应数据和错误代码，保证了前端和后端的 JVMTI 和 JDI 的通信通畅。</p><h3 id="Java-调试接口（JDI）"><a href="#Java-调试接口（JDI）" class="headerlink" title="Java 调试接口（JDI）"></a>Java 调试接口（JDI）</h3><p>JDI（Java Debug Interface）是三个模块中最高层的接口，在多数的 JDK 中，它是由 Java 语言实现的。</p><p>JDI 由针对前端定义的接口组成，通过它，调试工具开发人员就能通过前端虚拟机上的调试器来远程操控后端虚拟机上被调试程序的运行，JDI 不仅能帮助开发人员格式化 JDWP 数据，而且还能为 JDWP 数据传输提供队列、缓存等优化服务。从理论上说，开发人员只需使用 JDWP 和 JVMTI 即可支持跨平台的远程调试，但是直接编写 JDWP 程序费时费力，而且效率不高。因此基于 Java 的 JDI 层的引入，简化了操作，提高了开发人员开发调试程序的效率。</p><h2 id="本地、远程调试"><a href="#本地、远程调试" class="headerlink" title="本地、远程调试"></a>本地、远程调试</h2><h3 id="使用JDB进行调试"><a href="#使用JDB进行调试" class="headerlink" title="使用JDB进行调试"></a>使用<code>JDB</code>进行调试</h3><h4 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h4><p>在使用<code>JDB</code>进行远程调试之前，我们应该先试验一下，使用<code>JDB</code>进行本地调试。</p><p>首先编写一个测试类<code>TestJdb.java</code></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJdb</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;        <span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;        <span class="hljs-keyword">int</span> c = a + b;        <span class="hljs-keyword">int</span> d = c + b;        <span class="hljs-keyword">int</span> e = a + d;        System.out.println(<span class="hljs-string">"a="</span> + a + <span class="hljs-string">",b="</span> + b + <span class="hljs-string">",c="</span> + c + <span class="hljs-string">",d="</span> + d + <span class="hljs-string">",e="</span> + e);    &#125;&#125;</code></pre><p>使用javac编译得到<code>TestJdb.class</code>,使用命令<code>jdb TestJdb</code>即可进入调试模式,使用<code>stop</code>命令可设置断点,使用<code>run</code>命令即可运行程序</p><pre><code class="hljs plain">&gt;jdb TestJdb正在初始化jdb...&gt; stop at TestJdb:5正在延迟断点TestJdb:5。将在加载类后设置。&gt; run运行TestJdb设置未捕获的java.lang.Throwable设置延迟的未捕获的java.lang.Throwable&gt;VM 已启动: 设置延迟的断点TestJdb:5断点命中: &quot;线程&#x3D;main&quot;, TestJdb.main(), 行&#x3D;5 bci&#x3D;45            int c &#x3D; a + b;</code></pre><p><strong>jdb命令：</strong></p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>help or ?</td><td>最重要的<strong>JDB</strong>命令; 它会显示一个包含简要说明的已识别命令列表。</td></tr><tr><td>run</td><td>启动<strong>JDB</strong>并设置必要的断点后，可以使用此命令开始执行并调试应用程序。</td></tr><tr><td>cont</td><td>在断点，异常或步骤之后继续执行已调试的应用程序。</td></tr><tr><td>print</td><td>显示Java对象和原始值。</td></tr><tr><td>dump</td><td>对于原始值，此命令与print相同。 对于对象，它会打印对象中定义的每个字段的当前值。 包括静态和实例字段。</td></tr><tr><td>threads</td><td>列出当前正在运行的线程。</td></tr><tr><td>thread</td><td>选择一个线程作为当前线程。</td></tr><tr><td>where</td><td>转储当前线程的堆栈。</td></tr></tbody></table><p><strong>如何设置断点</strong></p><pre><code class="hljs plain">stop at &lt;class&gt;:&lt;line_number&gt; 或     stop in &lt;class&gt;.&lt;method_name&gt;[(argument_type,...)]</code></pre><p><strong>如何打印参数</strong></p><p>通过 <code>print</code> 或 <code>dump</code> 命令查看此时指定变量的值，<code>print</code> 用于查看简单类型，<code>dump</code> 用于查看对象类型</p><pre><code class="hljs plain">main[1] print a a &#x3D; 1main[1] print thiscom.sun.tools.example.debug.expr.ParseException: No &#39;this&#39;.  In native or static method this &#x3D; 空值main[1] dump thiscom.sun.tools.example.debug.expr.ParseException: No &#39;this&#39;.  In native or static method this &#x3D; 空值main[1]</code></pre><p><strong>如何执行方法</strong></p><p>通过 <code>step</code>、<code>next</code> 或 <code>cont</code> 命令继续执行程序：</p><ul><li><code>step</code> 命令相当于 eclipse 当中的 F5，如果当前语句是另一个方法调用时，会进入那个方法当中</li><li><code>next</code> 命令相当于 F6，只会逐行执行，不会进入被调用的其它方法</li><li><code>cont</code> 命令相当于 F8，从当前行一直执行到下一个断点，如果没有就一直执行到程序结束</li></ul><h4 id="远程调试"><a href="#远程调试" class="headerlink" title="远程调试"></a>远程调试</h4><p>使用<code>jdb</code>的<code>attach</code>命令，可以链接到已经处于运行状态的目标JVM。具体命令为</p><pre><code class="hljs plain">java -agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;&lt;PORT&gt; &lt;主类的全路径名&gt;</code></pre><p>其中 <code>address</code> 参数可选，如果不指定的话会随机分配一个可用端口。</p><p>如果是使用<code>tomcat</code>部署的<code>war</code>包工程，则需要在tomcat的启动脚本（<code>catalina.sh</code>）里添加下面的参数：</p><pre><code class="hljs plain">JAVA_OPTS&#x3D;&quot;$JAVA_OPTS -agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;5005&quot;</code></pre><p>同时需要关闭服务器防火墙，或者开发调试端口。</p><p><strong>一个连接示例：</strong></p><p>首先使用下面的命令启动服务：</p><pre><code class="hljs sh">java -agentlib:jdwp=transport=dt_socket,server=y,<span class="hljs-built_in">suspend</span>=n -jar helloworld-1.0.0-SNAPSHOT.jar</code></pre><p>启动成功后，日志中会打印出提供给 jdb 连接的端口，因为我们之前未指定，所以这里随机分配了一个</p><pre><code class="hljs sh">dereck-mbp:target Dereck$ java -agentlib:jdwp=transport=dt_socket,server=y,<span class="hljs-built_in">suspend</span>=n -jar helloworld-1.0.0-SNAPSHOT.jar Listening <span class="hljs-keyword">for</span> transport dt_socket at address: 51750</code></pre><p>通过 <code>jdb</code> 命令连接到正在运行的 JVM</p><pre><code class="hljs sh">dereck-mbp:~ Dereck$ jdb -connect com.sun.jdi.SocketAttach:port=51750设置未捕获的java.lang.Throwable设置延迟的未捕获的java.lang.Throwable正在初始化jdb...&gt;</code></pre><p>后续调试方式与<code>本地调试</code>方法一致。</p><h3 id="使用开发工具进行调试"><a href="#使用开发工具进行调试" class="headerlink" title="使用开发工具进行调试"></a>使用开发工具进行调试</h3><p>常见的开发工具有<code>eclipse</code>、<code>myeclipse</code>、<code>idea</code>，对于开发工具的本地调试，因为可视化话操作比较简单，顾本文不再赘述。这里主要说明一下如果使用可视化工具进行远程调试，下面以<code>idea</code>为例。</p><p>在进行调试之前，同意需要在启动服务的时候添加调试相关的参数，详细见<code>jdb</code>远程调试部分，示例为：</p><pre><code class="hljs plain">-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;n,address&#x3D;5005</code></pre><p>打开idea中的run/debug configurations, 选择remote类型，地址配置为服务器地址，端口配置为上述配置参数中的address，配置如图：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/tools/idea%E8%B0%83%E8%AF%95%E6%88%AA%E5%9B%BE.png" srcset="/img/loading.gif" alt="idea调试截图"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo中markdown文档自动编号</title>
    <link href="/2020/03/26/normal/md%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/"/>
    <url>/2020/03/26/normal/md%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo中markdown文档自动编号"><a href="#hexo中markdown文档自动编号" class="headerlink" title="hexo中markdown文档自动编号"></a>hexo中markdown文档自动编号</h1><h2 id="css实现原理"><a href="#css实现原理" class="headerlink" title="css实现原理"></a>css实现原理</h2><p>有时候我们需要对文章进行编号，例如：</p><pre><code class="hljs plain">1 标题11.1 标题1.11.1.1 标题1.1.11.2 标题1.2</code></pre><p>但是这在<code>hexo</code>是不支持的，需要自己开发，查阅了资料，发现可以利用css的计数器(counter)来实现此功能。</p><p>在css里，我们可以声明一个计数器，假设其名称为counter_xxx，那么我们可以使用counter()函数获得它当前的值。</p><pre><code class="hljs plain">counter(counter_xxx);</code></pre><p>与此同时，我们可以使用counter-reset属性指定需要重置的计数器，使用counter-increment属性指定计数加一的计数器。</p><pre><code class="hljs plain">h1 &#123;counter-increment: counter_h1;counter-reset: counter_h2;&#125;</code></pre><p>如上代码所示，每有一个h1出现时，计数器counter_h1的值就会加一，而counter_h2的值就会重置为0。我们刚好可以利用这个，配合伪类选择器:before来实现标题的自动编号。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>代码详情：</strong></p><pre><code class="hljs css"><span class="hljs-selector-tag">h2</span> &#123;<span class="hljs-attribute">counter-increment</span>: counter_h2;<span class="hljs-attribute">counter-reset</span>: counter_h3;&#125;<span class="hljs-selector-tag">h2</span> <span class="hljs-selector-class">.headerlink</span><span class="hljs-selector-pseudo">:before</span> &#123;<span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(counter_h2)<span class="hljs-string">"　"</span>;&#125;<span class="hljs-selector-tag">h3</span> &#123;<span class="hljs-attribute">counter-increment</span>: counter_h3;<span class="hljs-attribute">counter-reset</span>: counter_h4;&#125;<span class="hljs-selector-tag">h3</span> <span class="hljs-selector-class">.headerlink</span><span class="hljs-selector-pseudo">:before</span> &#123;<span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(counter_h2)<span class="hljs-string">"."</span><span class="hljs-built_in">counter</span>(counter_h3)<span class="hljs-string">"　"</span>;&#125;<span class="hljs-selector-tag">h4</span> &#123;<span class="hljs-attribute">counter-increment</span>: counter_h4;<span class="hljs-attribute">counter-reset</span>: counter_h5;&#125;<span class="hljs-selector-tag">h4</span> <span class="hljs-selector-class">.headerlink</span><span class="hljs-selector-pseudo">:before</span> &#123;<span class="hljs-attribute">content</span>: <span class="hljs-built_in">counter</span>(counter_h2)<span class="hljs-string">"."</span><span class="hljs-built_in">counter</span>(counter_h3)<span class="hljs-string">"."</span><span class="hljs-built_in">counter</span>(counter_h4)<span class="hljs-string">"　"</span>;&#125;</code></pre><p><strong>注意：</strong></p><ul><li><p><code>h4 .headerlink:before</code>这个是具体展现的<code>css</code>，你可根据自生情况来说。</p></li><li><p>这里我是从<code>h2</code>开始编号的，如果需要，你也可以从<code>h1</code>开始编号。</p></li></ul><p><strong>展现效果：</strong></p><h2 id="h2标题"><a href="#h2标题" class="headerlink" title="h2标题"></a>h2标题</h2><h3 id="h3标题"><a href="#h3标题" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题"><a href="#h4标题" class="headerlink" title="h4标题"></a>h4标题</h4><h4 id="h4标题-1"><a href="#h4标题-1" class="headerlink" title="h4标题"></a>h4标题</h4><h4 id="h4标题-2"><a href="#h4标题-2" class="headerlink" title="h4标题"></a>h4标题</h4><h3 id="h3标题-1"><a href="#h3标题-1" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题-3"><a href="#h4标题-3" class="headerlink" title="h4标题"></a>h4标题</h4><h4 id="h4标题-4"><a href="#h4标题-4" class="headerlink" title="h4标题"></a>h4标题</h4><h2 id="h2标题-1"><a href="#h2标题-1" class="headerlink" title="h2标题"></a>h2标题</h2><h3 id="h3标题-2"><a href="#h3标题-2" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题-5"><a href="#h4标题-5" class="headerlink" title="h4标题"></a>h4标题</h4>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>githubpage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java合并图片</title>
    <link href="/2020/03/25/Java/tools/java%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87/"/>
    <url>/2020/03/25/Java/tools/java%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用java合并图片"><a href="#使用java合并图片" class="headerlink" title="使用java合并图片"></a>使用java合并图片</h1><h2 id="编写Bimg类"><a href="#编写Bimg类" class="headerlink" title="编写Bimg类"></a>编写<code>Bimg</code>类</h2><blockquote><p>省略<code>get</code>、<code>set</code>方法</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bimg</span> </span>&#123;    <span class="hljs-keyword">private</span> BufferedImage image;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> w;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> y;&#125;</code></pre><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.awt.*;<span class="hljs-keyword">import</span> java.awt.image.BufferedImage;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> javax.imageio.ImageIO;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">getImgs</span><span class="hljs-params">()</span> </span>&#123;        List&lt;String&gt; array = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        array.add(<span class="hljs-string">"D:\\temp\\signimgs\\img\\1.png"</span>);        array.add(<span class="hljs-string">"D:\\temp\\signimgs\\img\\2.png"</span>);        array.add(<span class="hljs-string">"D:\\temp\\signimgs\\img\\3.png"</span>);        array.add(<span class="hljs-string">"D:\\temp\\signimgs\\img\\4.png"</span>);        <span class="hljs-keyword">return</span> array;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">// 横向图片数量</span>        <span class="hljs-keyword">int</span> wsize = <span class="hljs-number">3</span>;        List&lt;String&gt; imgs = getImgs();        <span class="hljs-keyword">int</span> allWidth = <span class="hljs-number">0</span>;        <span class="hljs-keyword">int</span> allHeight = <span class="hljs-number">0</span>;        List&lt;Bimg&gt; bimgs = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        <span class="hljs-comment">// 目前横坐标</span>        <span class="hljs-keyword">int</span> w = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 目前竖坐标</span>        <span class="hljs-keyword">int</span> y = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 当前行宽度</span>        <span class="hljs-keyword">int</span> currentRowWidth = <span class="hljs-number">0</span>;        <span class="hljs-comment">// 当前行高度</span>        <span class="hljs-keyword">int</span> currentRowHeight = <span class="hljs-number">0</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= imgs.size(); i++) &#123;            String imgPath = imgs.get(i - <span class="hljs-number">1</span>);            File imgFile = <span class="hljs-keyword">new</span> File(imgPath);            InputStream in = <span class="hljs-keyword">new</span> FileInputStream(imgFile);            BufferedImage imageBuffer = ImageIO.read(in);            Bimg bimg = <span class="hljs-keyword">new</span> Bimg();            bimgs.add(bimg);            bimg.setImage(imageBuffer);            <span class="hljs-comment">// 判断是否需要换行</span>            <span class="hljs-keyword">if</span> (i % (wsize + <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123;                <span class="hljs-comment">// 需要换行</span>                w = <span class="hljs-number">0</span>;                y = currentRowHeight;                allWidth = Math.max(allWidth, currentRowWidth);                allHeight = allHeight + currentRowHeight;                currentRowWidth = <span class="hljs-number">0</span>;                currentRowHeight = <span class="hljs-number">0</span>;            &#125;            bimg.setW(w);            bimg.setY(y);            w = w + imageBuffer.getWidth();            currentRowHeight = Math.max(currentRowHeight, imageBuffer.getHeight());            <span class="hljs-comment">// 维护当前行宽度</span>            currentRowWidth = currentRowWidth + imageBuffer.getWidth();        &#125;        <span class="hljs-comment">// 如果最终的高宽都是0，就进行一次设置，主要为仅一行的情况做处理</span>        <span class="hljs-keyword">if</span> (currentRowWidth != <span class="hljs-number">0</span> || currentRowHeight != <span class="hljs-number">0</span>) &#123;            allWidth = Math.max(allWidth, currentRowWidth);            allHeight = allHeight + currentRowHeight;        &#125;        <span class="hljs-comment">// 解决透明区域变黑的问题</span>        BufferedImage combined = <span class="hljs-keyword">new</span> BufferedImage(allWidth, allHeight, BufferedImage.TYPE_INT_RGB);        Graphics2D g = combined.createGraphics();        combined = g.getDeviceConfiguration().createCompatibleImage(combined.getWidth(), combined.getHeight(),            Transparency.TRANSLUCENT);        <span class="hljs-comment">// 解决透明区域变黑的问题</span>        Graphics graphics = combined.getGraphics();        <span class="hljs-keyword">for</span> (Bimg bimg : bimgs) &#123;            graphics.drawImage(bimg.getImage(), bimg.getW(), bimg.getY(), <span class="hljs-keyword">null</span>);        &#125;        ImageIO.write(combined, <span class="hljs-string">"png"</span>, <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\\temp\\signimgs\\img\\res.png"</span>));    &#125;&#125;</code></pre><p>其中需要注意的是，如果源图片存在透明区域，直接合并的话，透明区域会变为黑色，该情况使用下面的代码就能解决：</p><pre><code class="hljs java">BufferedImage combined = <span class="hljs-keyword">new</span> BufferedImage(allWidth, allHeight, BufferedImage.TYPE_INT_RGB);        Graphics2D g = combined.createGraphics();        combined = g.getDeviceConfiguration().createCompatibleImage(combined.getWidth(), combined.getHeight(),            Transparency.TRANSLUCENT);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows添加vscode右键菜单</title>
    <link href="/2020/03/24/normal/windows%E6%B7%BB%E5%8A%A0vscode%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <url>/2020/03/24/normal/windows%E6%B7%BB%E5%8A%A0vscode%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="windows添加vscode右键菜单"><a href="#windows添加vscode右键菜单" class="headerlink" title="windows添加vscode右键菜单"></a>windows添加vscode右键菜单</h1><blockquote><p>最近对<code>vscode</code>编辑器几乎入魔了，凡事静态代码，都改用<code>vscode</code>来编写了，不过在windows上，如果需要打开一个文件或者一个文件夹，这个操作比较繁琐，所以就期望能够直接在windows的资源管理器里加上一个菜单。经过<code>google</code>之后，发现了如下方法</p></blockquote><p>创建一个<code>vscode.reg</code>，名字可以随便写，但是后缀名用<code>.reg</code>，文件内容如下：</p><pre><code class="hljs plain">Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\VSCode]@&#x3D;&quot;Open with Code&quot;&quot;Icon&quot;&#x3D;&quot;C:\\app\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\*\shell\VSCode\command]@&#x3D;&quot;\&quot;C:\\app\\Microsoft VS Code\\Code.exe\&quot; \&quot;%1\&quot;&quot;Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\VSCode]@&#x3D;&quot;Open with Code&quot;&quot;Icon&quot;&#x3D;&quot;C:\\app\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]@&#x3D;&quot;\&quot;C:\\app\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]@&#x3D;&quot;Open with Code&quot;&quot;Icon&quot;&#x3D;&quot;C:\\app\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]@&#x3D;&quot;\&quot;C:\\app\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;</code></pre><p>其中 <code>C:\\app\\Microsoft VS Code\\Code.exe</code> 这个是我本机的安装地址，你可能需要修改一下。</p><p>最后双击执行即可，如果失败，你可能需要使用管理员权限使用。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程学习笔记</title>
    <link href="/2019/08/26/Java/tools/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/08/26/Java/tools/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程学习笔记"><a href="#多线程学习笔记" class="headerlink" title="多线程学习笔记"></a>多线程学习笔记</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务</p><h2 id="什么是线程安全和线程不安全"><a href="#什么是线程安全和线程不安全" class="headerlink" title="什么是线程安全和线程不安全"></a>什么是线程安全和线程不安全</h2><p>线程安全是针对多线程来讲的，如果所使用的公用变量在多线程下没有被保护机制时，变量结果会和理论值不一致，这样就叫作线程不安全，相反公用变量在保护机制下工作，就不会出现“随机”变化，这时叫线程安全。<br>线程安全:   在多线程中使用时,不用自已做同步处理.<br>线程不安全:   在多线程中使用时,   必须做线程同步,不然会有未知后果.</p><h2 id="什么是自旋锁"><a href="#什么是自旋锁" class="headerlink" title="什么是自旋锁"></a>什么是自旋锁</h2><p>是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判<br>断锁是否能够被成功获取，直到获取到锁才会退出循环。<br>获取锁的线程一直处于活跃状态，占用cpu时间，但是没有执行任何有效的任务，使用这种锁会造成busy-waiting。</p><h2 id="什么是Java内存模型"><a href="#什么是Java内存模型" class="headerlink" title="什么是Java内存模型"></a>什么是Java内存模型</h2><p>Java内存模型即Java Memory Model (<code>JMM</code>)，JMM定义了Java虚拟机在计算机内存中的工作方式，JVM是整个计算机的虚拟模型，所以JMM是隶属于JVM的。</p><h2 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h2><p>CAS算法 即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。CAS算法涉及到三个操作数：</p><ul><li>需要读写的内存值 V</li><li>进行比较的值 A</li><li>拟写入的新值 B</li><li>当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java多线程编程总结</title>
    <link href="/2019/08/26/Java/tools/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2019/08/26/Java/tools/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="线程基本概念"><a href="#线程基本概念" class="headerlink" title="线程基本概念"></a>线程基本概念</h2><h3 id="主线程与子线程"><a href="#主线程与子线程" class="headerlink" title="主线程与子线程"></a>主线程与子线程</h3><p>每个Java应用程序都有一个执行Main()函数的默认线程，这就是主线程（main thread）。当Java程序启动时，主线程立刻运行，因为它是程序开始时就执行的。主线程的重要性体现在两方面：</p><ol><li><p>它是产生其他子线程的线程</p></li><li><p>通常它必须最后完成执行，因为它执行各种关闭动作</p></li></ol><p>由主线程创建的线程即被称为子线程。Java主要通过<code>jaava.lang.Thread</code>类以及<code>java.lang.Runnable</code>接口来实现线程机制。</p><p><strong>实现<code>Runnable</code>接口：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"NewRunnable ... "</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> NewRunnable());        thread.start();    &#125;&#125;</code></pre><p>从该例可以看出，实现<code>Runnable</code>接口只需要实现其<code>run</code>方法，仅仅声明了方法，要执行该方法还需要使用<code>Thread</code>类调用<code>start</code>方法执行。</p><p><strong>可以继承<code>Thread</code>类：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NewThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        System.out.println(<span class="hljs-string">"NewThread ..."</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Thread thread = <span class="hljs-keyword">new</span> NewThread();        thread.start();    &#125;&#125;</code></pre><p>对于创建线程，一般都使用实现<code>Runnable</code>接口方式来实现；如果需要重载<code>Thread</code>的方法，则使用继承<code>Thread</code>的方式实现。</p><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p>线程的状态分为6种，分别为：</p><ol><li>创建(NEW)：新创建了一个线程对象，但还没有调用start()方法。</li><li>就绪(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”。</li><li>阻塞(BLOCKED)：线程被锁阻塞。</li><li>等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回。</li><li>死亡(TERMINATED)：表示该线程已经执行完毕。</li></ol><p><strong>状态切换：</strong></p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/tools/%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2.png" srcset="/img/loading.gif" alt="线程状态切换"></p><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>线程优先级被线程调度用来判定何时每个线程允许运行。理论上，优先级高的线程比优先级低的线程获得更多的<code>CPU</code>时间。实际上，线程获得的<code>CPU</code>时间通常由包括优先级在内的多个因素决定（例如，一个实行多任务处理的操作系统如何更有效的利用<code>CPU</code>时间）。</p><p>一个优先级高的线程自然比优先级低的线程优先。举例来说，当低优先级线程正在运行，而一个高优先级的线程被恢复（例如从沉睡中或等待I/O中），它将抢占低优先级线程所使用的<code>CPU</code>。</p><p>在创建线程的时候，可以通过<code>Thread.setPriority(int newPriority)</code>方法指定线程优先级；改方法是否生效与操作系统及虚拟机版本相关。</p><p>其中<code>newPriority</code>参数使用1-10表示：</p><ul><li>最低优先级 1：<code>Thread.MIN_PRIORITY</code></li><li>普通优先级 5：<code>Thread.NORM_PRIORITY</code></li><li>最高优先级 10：<code>Thread.MAX_PRIORITY</code></li></ul><p>在Java程序中，线程的默认优先级为其父线程的优先级，而非普通优先级(<code>NORM_PRIORITY</code>)。</p><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>Java程序运行多线程之间并发控制，当两个或两个以上的线程需要共享资源，它们需要某种方法来确定资源在某一刻仅被一个线程占用，避免相互之间产生冲突，保证变量的唯一性和准确性，达到此目的的过程叫做同步（synchronization）。</p><p><strong>线程同步方法：</strong></p><p>1.使用<code>synchronized</code>修饰方法、代码块。如果修饰的是静态方法，则锁的是类。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>&#123;&#125;<span class="hljs-keyword">synchronized</span>(object)&#123; &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;&#125;</code></pre><p>2.使用<code>volatile</code>变量实现线程同步</p><p><code>volatile</code>通常被比喻成”轻量级的<code>synchronized</code>“，不同的是<code>volatile</code>只能修饰变量。</p><p><code>volatile</code>主要作用是保证线程之间的可见性、有序性：</p><ul><li><p>可见性：Java中的<code>volatile</code>关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。</p></li><li><p>有序性：<code>volatile</code>可以禁止指令重排，被它修饰的变量，会严格按照代码顺序执行。</p></li><li><p>原子性：一个操作或者多个操作要么全部执行，要么全不执行。</p></li></ul><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池的优势：</p><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建的销毁造成的消耗，需要注意的是，如果线程过多，线程上下文切换会是一种消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。服务端拿到用户请求，可以先向用户返回结果，然后利用线程异步的执行任务。</li><li>提高线程的可管理性：线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="Excutor的线程池"><a href="#Excutor的线程池" class="headerlink" title="Excutor的线程池"></a>Excutor的线程池</h3><ul><li><code>newSingleThreadExecutor</code>：一个单线程的线程池，可以用于需要保证顺序执行的场景，并且只有一个线程在执行。</li><li><code>newFixedThreadPool</code>：一个固定大小的线程池，可以用于已知并发压力的情况下，对线程数做限制。</li><li><code>newCachedThreadPool</code>：一个可以无限扩大的线程池，比较适合处理执行时间比较小的任务。</li><li><code>newScheduledThreadPool</code>：可以延时启动，定时启动的线程池，适用于需要多个后台线程执行周期任务的场景。</li><li><code>newWorkStealingPool</code>：一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用cpu数量的线程来并行执行。</li><li>自定义线程池</li></ul><h2 id="四种并发模型"><a href="#四种并发模型" class="headerlink" title="四种并发模型"></a>四种并发模型</h2><h3 id="多线程编程模型"><a href="#多线程编程模型" class="headerlink" title="多线程编程模型"></a>多线程编程模型</h3><ul><li>多个相互独立的执行流</li><li>共享内存状态</li><li>抢占式调度</li><li>依赖锁、信号量等同步机制</li></ul><h3 id="Callback编程模型"><a href="#Callback编程模型" class="headerlink" title="Callback编程模型"></a>Callback编程模型</h3><p>回调。某个函数(A)可以接受另一个函数(B)作为参数，在执行流程到某个点时作为参数的函数B就会被函数A调用执行，这个行为就被称为回调。</p><p>作用：快速响应。</p><p>应用：在javascript中应用较多</p><h3 id="Actor编程模型"><a href="#Actor编程模型" class="headerlink" title="Actor编程模型"></a>Actor编程模型</h3><ul><li>万物皆是Actor</li><li>Actor之间完全独立，只允许消息传递，不允许其他”任何”共享</li><li>每个Actor最多同时只能进行一样工作</li><li>每个Actor都有一个专属的命名Mailbox(非匿名)</li><li>消息的传递是完全异步的</li><li>消息是不可变的</li></ul><h3 id="CSP编程模型"><a href="#CSP编程模型" class="headerlink" title="CSP编程模型"></a>CSP编程模型</h3><p>CSP（Communicating Sequential Processes）是由Tony Hoare在1978的论文上首次提出的。 它是处理并发编程的一种设计模式或者模型，指导并发程序的设计，提供了一种并发程序可实践的组织方法或者设计范式。通过此方法，可以减少并发程序引入的其它缺点，减少和规避并发程序的常见缺点和bug，并且可以被数学理论所论证。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程安全</title>
    <link href="/2019/08/26/Java/tools/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2019/08/26/Java/tools/Java%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><blockquote><p>一个方法或者一个实例可以在多线程环境中使用而不会出现问题</p></blockquote><h2 id="线程安全实现方式"><a href="#线程安全实现方式" class="headerlink" title="线程安全实现方式"></a>线程安全实现方式</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>使用synchronized是通过互斥的方式保证同步的，它对于同一条线程来说是可重入的；其次它是阻塞的。synchronized会将线程阻塞，当获得锁时会唤醒线程，将线程从用户状态转为内核状态，该操作会消耗大量的资源，顾synchronized是一个重量级锁。</p><h4 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h4><p>ReentrantLock是一个可重入锁。它与synchronized的区别是，它需要显示的去调动<code>lock</code>与<code>unlock</code>方法，手动去加锁并释放锁，一般释放锁的方法写在<code>finally</code>语句块中。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare And Swap）"></a>CAS（Compare And Swap）</h4><blockquote><p>CAS是原子操作，保证并发安全，不能保证并发同步</p><p>CAS是CPU的一个指令</p><p>CAS是非阻塞的、轻量级的乐观锁</p></blockquote><p>原理：CAS比较并替换，就是将内存值更新为需要的值，但是有个条件，内存值必须与期望值相同。</p><p>最佳应用：<code>java.util.concurrent.atomic</code>包下的原子操作类</p><ul><li>原子更新基本类型</li><li>原子更新数组</li><li>原子更新引用</li><li>原子更新字段</li></ul><p>CAS优点：</p><ul><li>乐观锁，通过CPU指令实现，性能高</li></ul><p>CAS缺点：</p><ul><li>自旋时间长，消耗CPU资源</li><li>非公平锁</li></ul><h3 id="synchronized使用方法"><a href="#synchronized使用方法" class="headerlink" title="synchronized使用方法"></a>synchronized使用方法</h3><blockquote><p>synchronized修饰的对象主要为四种：</p><ul><li>修饰代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</li><li>修饰方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象； </li><li>修饰一个静态方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象； </li><li>修饰一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</li></ul></blockquote><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p>被修饰的代码块被称为同步语句块，起作用范围是{}中的代码，作用的对象是这个代码块的对象。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>&#123;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;           System.out.println(<span class="hljs-string">"add user"</span>);        &#125;    &#125;&#125;</code></pre><p>多个线程访问同一个对象的代码块时，线程被阻塞；</p><p>多个线程访问不同对象的代码块，线程不会被阻塞。</p><p>即synchronized修饰的是一个对象，每个访问这个对象的线程都将被阻塞，直到该对象的锁被释放。</p><p>如果没有明确的对象加锁，可以在类中定义一个常量来实现：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;        <span class="hljs-keyword">private</span> String lock = <span class="hljs-string">"lock"</span>;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">(User user)</span></span>&#123;        <span class="hljs-keyword">synchronized</span>(lock)&#123;           System.out.println(<span class="hljs-string">"add user"</span>);        &#125;    &#125;&#125;</code></pre><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>&#123;         System.out.println(<span class="hljs-string">"update user"</span>);    &#125;&#125;</code></pre><p>synchronized修饰方法时，它锁定的是调用这个同步方法的对象。即一个对象在不同的线程中调用该方法将被阻塞。</p><h4 id="synchronized修饰一个静态的方法"><a href="#synchronized修饰一个静态的方法" class="headerlink" title="synchronized修饰一个静态的方法"></a>synchronized修饰一个静态的方法</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>&#123;         System.out.println(<span class="hljs-string">"update user"</span>);    &#125;&#125;</code></pre><p>synchronized作用的对象是一个静态方法，则它去得是类的所，该类素有的对象同一把锁，所有对象都会被阻塞。</p><h4 id="synchronized作用于一个类"><a href="#synchronized作用于一个类" class="headerlink" title="synchronized作用于一个类"></a>synchronized作用于一个类</h4><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>&#123;        <span class="hljs-keyword">synchronized</span>(UserService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>&#123;         System.out.println(<span class="hljs-string">"update user"</span>);        &#125;    &#125;&#125;</code></pre><p>synchronized作用于一个类时，是给这个类加锁，这个类的所有对象用的是同一把锁。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>无论synchronized关键字加在方法上还是对象上，如果它作用的对象是非静态的，则它取得的锁是对象；如果synchronized作用的对象是一个静态方法或一个类，则它取得的锁是对类，该类所有的对象同一把锁。</li><li>每个对象只有一个锁（lock）与之相关联，谁拿到这个锁谁就可以运行它所控制的那段代码。</li><li>实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</li></ul><h2 id="线程安全的集合"><a href="#线程安全的集合" class="headerlink" title="线程安全的集合"></a>线程安全的集合</h2><h3 id="最原始的集合"><a href="#最原始的集合" class="headerlink" title="最原始的集合"></a>最原始的集合</h3><blockquote><p>原始的线程安全集合都是通过在方法上添加<code>synchronized</code>关键字，该方法效率较低。</p></blockquote><p><strong>Vector：</strong>长度可变的数组</p><p><strong>HashTable：</strong>线程安全的HashMap</p><h3 id="concurrent包中的集合"><a href="#concurrent包中的集合" class="headerlink" title="concurrent包中的集合"></a>concurrent包中的集合</h3><p><strong>ConcurrentHashMap：</strong>线程安全的HashMap，jdk1.8之前采用Segment分段锁，jdk1.8取消了分段锁，直接在table元素上加锁，实现对每一行进行加锁。</p><p><strong>CopyOnWriteArrayList：</strong>具有写锁</p><p><strong>CopyOnWritArraySet：</strong>具有写锁</p><p><strong>ConcurrentSkipListMap：</strong>利用跳表实现的有序的、支持高并发的Map</p><p><strong>ConcurrentSkipListSet：</strong>利用跳表实现的有序的、支持高并发的Set</p><p><strong>ConcurrentLinkedQueue：</strong>高并发场景下的队列</p><p><strong>ConcurrentLinkedDeque：</strong>高并发场景下的双端队列</p><h2 id="线程安全Queue"><a href="#线程安全Queue" class="headerlink" title="线程安全Queue"></a>线程安全Queue</h2><p>在Java多线程应用中，Queue主要分为两种：</p><ul><li>BlockingQueue：阻塞队列</li><li>ConcurrentLinkedQueue：高性能队列</li></ul><h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><p><code>BlockingQueue</code>是一个接口，定义了一套阻塞队列的规则。它的常用方法为：</p><ul><li>add(e) remove() element() 方法不会阻塞线程。当不满足约束条件时，会抛出IllegalStateException 异常。例如：当队列被元素填满后，再调用add(e)，则会抛出异常。</li><li>offer(e) poll() peek() 方法即不会阻塞线程，也不会抛出异常。例如：当队列被元素填满后，再调用offer(e)，则不会插入元素，函数返回false。</li><li>要想要实现阻塞功能，需要调用put(e) take() 方法。当不满足约束条件时，会阻塞线程。</li></ul><h5 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h5><p><code>ArrayBlockingQueue</code>是基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数组，以便缓存队列中的数据对象，其内部没实现读写分离，也就意味着生产和消费不能完全并行，长度是需要定义的，可以指定先进先出或者先进后出，也叫有界队列，在很多场合非常适合使用。</p><h5 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h5><p><code>LinkedBlockingQueue</code>是基于链表的阻塞队列，同ArrayBlockingQueue类似，其内部也维持着一个数据缓冲队列〈该队列由一个链表构成），LinkedBlockingQueue之所以能够高效的处理并发数据，是因为其内部实现采用分离锁（读写分离两个锁），从而实现生产者和消费者操作的完全并行运行,他是一个无界队列。</p><h5 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h5><p><code>SynchronousQueue</code>是一种没有缓冲的队列，生产者产生的数据直接会被消费者获取并消费。</p><h5 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h5><p><code>PriorityBlockingQueue</code>是基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定，也就是说传入队列的对象必须实现Comparable接口），在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁，他也是一个无界的队列。</p><h5 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h5><p><code>DelayQueue</code>：带有延迟时间的<code>Queue</code>，其中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。<code>DelayQueue</code>中的元素必须实现<code>Delayed</code>接口，<code>DelayQueue</code>是一个没有大小限制的队列，应用场景很多，比如对缓存超时的数据进行移除、任务超时处理、空闲连接的关闭等等。</p><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><p><code>ConcurrentLinkedQueue</code>是一个适用于高并发场景下的队列，通过无锁的方式，实现了高并发状态下的高性能，通常ConcurrentLinkedQueue性能好于BlockingQueueo它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。头是最先加入的，尾是最近加入的，该队列不允许null元素。</p><p>其核心方法为：</p><ul><li><code>add</code>、<code>offer</code>：将元素加入队列，两个方法没有区别</li><li><code>poll</code>：取头元素节点，该方法会删除元素</li><li><code>Peek</code>：取头元素节点</li></ul><h2 id="java-utils-cuncurrent下的锁"><a href="#java-utils-cuncurrent下的锁" class="headerlink" title="java.utils.cuncurrent下的锁"></a>java.utils.cuncurrent下的锁</h2><h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><ul><li>一个可重入的互斥锁 Lock</li><li>ReentrantLock 将由最近成功获得锁，并且还没有释放该锁的线程所拥有</li><li>此类的构造方法接受一个可选的公平参数。当设置为<code>true</code>时，在多个线程的争用下，这些锁倾向于将访问权授予等待时间最长的线程。采用默认设置（使用不公平锁）。</li><li>使用公平锁的程序在许多线程访问时表现为很低的总体吞吐量（即速度很慢，常常极其慢），优点是在获得锁和保证锁分配的均衡性时差异较小。</li></ul><h3 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h3><p><code>ReadWriteLock</code>维护了一对相关的锁，一个用于只读操作，另一个用于写入操作。只要没有 writer，读取锁可以由多个 reader 线程同时保持。写入锁是独占的。</p><ul><li>与互斥锁相比，读-写锁允许对共享数据进行更高级别的并发访问。</li><li>一次只有一个线程（<em>writer</em> 线程）可以修改共享数据；在许多情况下，任何数量的线程可以同时读取共享数据（<em>reader</em> 线程）</li><li>与互斥锁相比，使用读-写锁所允许的<code>并发性</code>增强将带来更大的性能提高</li></ul><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a><strong>ReentrantReadWriteLock</strong></h3><p><code>ReentrantReadWriteLock</code>是<code>ReadWriteLock</code>的实现类。它具有以下属性：</p><ul><li>获取顺序：<code>ReentrantReadWriteLock</code>不会将读取者优先或写入者优先强加给锁访问的排序</li><li>公平性：默认为非公平锁，可以在构造函数中设置为公平锁</li><li>重复性：可重入。</li><li>锁降级：重入还允许从写入锁降为读取锁。实现方式是先获取写入所，然后获取读取锁，最后释放写入锁。即写入线程可以获取读取锁，读取锁中不能获取写入锁。</li></ul><h3 id="Stampedlock"><a href="#Stampedlock" class="headerlink" title="Stampedlock"></a>Stampedlock</h3><blockquote><p>StampedLock是并发包里面jdk8版本新增的一个锁，该锁提供了三种模式的读写控制，三种模式分别如下</p></blockquote><p><strong>写锁writeLock：</strong>排它锁（独占锁），同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当目前没有线程持有读锁或者写锁的时候才可以获取到该锁，请求该锁成功后会返回一个stamp票据变量用来表示该锁的版本，当释放该锁时候需要unlockWrite并传递参数stamp。</p><p><strong>悲观读锁readLock：</strong>共享锁，在没有线程获取独占写锁的情况下，同时多个线程可以获取该锁，如果已经有线程持有写锁，其他线程请求获取该读锁会被阻塞。</p><p><strong>乐观读锁tryOptimisticRead：</strong>乐观锁，运用CAS原理。适用于读多写少的场景，因为获取读锁只是使用与或操作进行检验，不涉及CAS操作，所以效率会高很多。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java多线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java8新特性</title>
    <link href="/2019/08/25/Java/tools/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2019/08/25/Java/tools/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="接口默认方法与静态方法"><a href="#接口默认方法与静态方法" class="headerlink" title="接口默认方法与静态方法"></a>接口默认方法与静态方法</h2><h3 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h3><p>实现方式：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInterface</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addUser</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"add user"</span>);    &#125;&#125;</code></pre><p>在接口定义中使用<code>default</code>关键字即可定义一个自带方法内容的接口方法，子类可以不实现该方法。</p><h4 id="接口冲突"><a href="#接口冲突" class="headerlink" title="接口冲突"></a>接口冲突</h4><p>接口是允许实现多个接口的，试想如果有两个接口，分别为<code>UserInterface1</code>、<code>UserInterface2</code>，他们均定义了一名名为<code>addUser</code>的默认方法，此时，如果有一个子类同时实现了这两个接口，实现方调用<code>addUser</code>则产生冲突。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>使得口作为协议，类作为具体实现的界限开始变得有点模糊。如果继承关系较多，可能增加一些开发成本。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInterface</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"this user"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">"user"</span>;    &#125;&#125;</code></pre><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><code>Lambda</code>表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong>行为参数化</strong>，函数作为参数传递进方法中）。</p><p>一个<code>Lambda</code>可以由用逗号分隔的参数列表、<code>–&gt;</code>符号与函数体三部分表示。</p><p>遍历List的两种方式：</p><pre><code class="hljs java"><span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">t1</span><span class="hljs-params">()</span></span>&#123;  List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();  list.add(<span class="hljs-string">"A"</span>);  list.add(<span class="hljs-string">"B"</span>);  list.add(<span class="hljs-string">"C"</span>);  System.out.println(<span class="hljs-string">"普通遍历："</span>);  <span class="hljs-keyword">for</span>(String str : list)&#123;    System.out.println(str);  &#125;  System.out.println(<span class="hljs-string">"java8遍历："</span>);  list.forEach(str-&gt;&#123;    System.out.println(str);  &#125;);&#125;</code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是指一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。</p><p>一个<code>Lambda</code>表达式就是一个抽象方法的实现。</p><p><code>@FunctionalInterface</code>定义的接口都可以使用在<code>Lambda</code>表达式上。</p><h3 id="Java8自带的函数式接口"><a href="#Java8自带的函数式接口" class="headerlink" title="Java8自带的函数式接口"></a>Java8自带的函数式接口</h3><p><strong>Comparator (比较器接口)</strong></p><pre><code class="hljs java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</code></pre><p><strong>Consumer (消费型接口)</strong></p><p><code>Consumer</code>接口表示执行在单个参数上的操作。 </p><p>扩展：</p><ul><li>BiConsumer</li><li>DoubleConsumer</li><li>IntConsumer</li><li>LongConsumer</li><li>ObjDoubleConsumer</li><li>ObjIntConsumer</li><li>ObjLongConsumer</li></ul><p><strong>Supplier（供应型接口）</strong></p><p><code>Supplier</code>接口是不需要参数并返回一个任意范型的值</p><p>扩展：</p><ul><li>BooleanSupplier</li><li>DoubleSupplier</li><li>IntSupplier</li><li>LongSupplier</li></ul><p><strong>Predicate（断言型接口）</strong></p><p><code>Predicate</code>接口只有一个参数，返回<code>boolean</code>类型。</p><p>扩展：</p><ul><li>BiPredicate</li><li>DoublePredicate</li><li>IntPredicate</li><li>LongPredicate</li></ul><p><strong>Function (功能型接口)</strong></p><p><code>Function</code>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（<code>compose</code>, <code>andThen</code>）</p><p>扩展：</p><ul><li>BiFunction</li><li>DoubleFunction</li><li>IntFunction</li><li>LongFunction</li><li>ToDoubleFunction</li><li>ToDoubleBiFunction</li></ul><p><strong>Operator</strong></p><p><code>Operator</code>其实就是<code>Function</code>，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。</p><ul><li>UnaryOperator</li><li>BinaryOperator</li></ul><p><strong>示例代码</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;    <span class="hljs-keyword">private</span> Work work;    <span class="hljs-function"><span class="hljs-keyword">public</span> Work <span class="hljs-title">getWork</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> work;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWork</span><span class="hljs-params">(Work work)</span> </span>&#123;        <span class="hljs-keyword">this</span>.work = work;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String food, Consumer&lt;String&gt; consumer)</span> </span>&#123;        consumer.accept(food);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String food, Supplier&lt;String&gt; supplier)</span> </span>&#123;        String s = supplier.get();        System.out.println(<span class="hljs-string">"Supplier -&gt;&gt; "</span> + food + <span class="hljs-string">":"</span> + s);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(String food, Predicate&lt;String&gt; predicate)</span> </span>&#123;        <span class="hljs-keyword">if</span> (predicate.test(<span class="hljs-string">"admin"</span>)) &#123;            System.out.println(<span class="hljs-string">"Predicate -&gt;&gt; admin eat "</span> + food);        &#125;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">(Integer month,Function&lt;Work, Integer&gt; function)</span> </span>&#123;        Integer amount1 = function.compose(w-&gt; &#123;            Work ww = <span class="hljs-keyword">new</span> Work();            ww.setSalary(((Work)w).getSalary()*month);            <span class="hljs-keyword">return</span> ww;        &#125;).apply(<span class="hljs-keyword">this</span>.getWork());        System.out.println(<span class="hljs-string">"Function compose -&gt;&gt; amount:"</span>+ amount1);        Integer amount2 = function.andThen(salary -&gt; salary * month).apply(<span class="hljs-keyword">this</span>.getWork());        System.out.println(<span class="hljs-string">"Function andThen -&gt;&gt; amount:"</span>+ amount2);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        User user = <span class="hljs-keyword">new</span> User();        user.eat(<span class="hljs-string">"banana"</span>, (Consumer&lt;String&gt;)s -&gt; System.out.println(<span class="hljs-string">"Consumer -&gt;&gt; food is : "</span> + s));        user.eat(<span class="hljs-string">"banana"</span>, (Predicate&lt;String&gt;)s -&gt; s.equals(<span class="hljs-string">"admin"</span>));        user.eat(<span class="hljs-string">"apple"</span>, () -&gt; <span class="hljs-string">"sdf"</span>);        Work work = <span class="hljs-keyword">new</span> Work();        work.setSalary(<span class="hljs-number">100</span>);        user.setWork(work);        user.work(<span class="hljs-number">8</span>, s -&gt; &#123;            Integer salary = s.getSalary();            <span class="hljs-comment">//奖金</span>            Integer bons = <span class="hljs-number">100000</span>;            <span class="hljs-keyword">return</span> salary + bons;        &#125;);        UnaryOperator&lt;Integer&gt; increment = x -&gt; x + <span class="hljs-number">1</span>;        System.out.println(<span class="hljs-string">"UnaryOperator -&gt;&gt; "</span> + increment.apply(<span class="hljs-number">2</span>));        BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;        System.out.println(<span class="hljs-string">"BinaryOperator -&gt;&gt; "</span> + add.apply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));        BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy((o1, o2) -&gt; o1 - o2);        System.out.println(<span class="hljs-string">"BinaryOperator -&gt;&gt; "</span> + min.apply(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>));    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Work</span> </span>&#123;    <span class="hljs-keyword">private</span> Integer salary;    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> salary;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(Integer salary)</span> </span>&#123;        <span class="hljs-keyword">this</span>.salary = salary;    &#125;&#125;</code></pre><p><strong>示例输出</strong></p><pre><code class="hljs text">Consumer -&gt;&gt; food is : bananaPredicate -&gt;&gt; admin eat bananaSupplier -&gt;&gt; apple:sdfFunction compose -&gt;&gt; amount:100800Function andThen -&gt;&gt; amount:800800UnaryOperator -&gt;&gt; 3BinaryOperator -&gt;&gt; 5BinaryOperator -&gt;&gt; 2</code></pre><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><p>自定义函数式接口只需要在接口中添加<code>@FunctionalInterface</code>注解，并为这个接口提供至少一个公共方法即可。下面示例代码将自定义个将map转为list的函数式接口：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-meta">@FunctionalInterface</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ListToMapFunction</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;K,V&gt; <span class="hljs-title">apply</span><span class="hljs-params">(List&lt;V&gt; list)</span></span>;&#125;</code></pre><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>首先列举一下java8中使用stream将list转为map的代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>));        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">2</span>));        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">3</span>));        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">4</span>));        users.add(<span class="hljs-keyword">new</span> User(<span class="hljs-number">5</span>));        users.stream().collect(Collectors.toMap(u-&gt;u.getId(),u-&gt;u));    &#125;</code></pre><p>在java8中我们可以直接通过方法应用来简写<code>Lambda</code>表达式中已经存在的方法，修改为：</p><pre><code class="hljs java">users.stream().collect(Collectors.toMap(User::getId,u-&gt;u));</code></pre><p>其中<code>User::getId</code>就是方法引用，方法引用的操作符是双冒号<code>::</code>。</p><p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p><p>方法引用有四种写法：</p><ul><li>引用静态方法: ContainingClass::staticMethodName</li><li>引用某个对象的实例方法: containingObject::instanceMethodName</li><li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li><li>引用构造方法: ClassName::new</li></ul><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><code>Stream</code>是java8新增的类，主要是用来补充集合类。它代表数据流，流中的数据元素的数量可能是有限的，也可能是无限的。</p><p><code>Stream</code>与集合类的区别：集合类关注有限数量的数据访问和有效管理，而<code>Stream</code>是在数据源上执行可计算的操作。在一个流中，可以执行一个或者多个中间操作，再执行一个最终操作来返回结果。</p><p>中间操作有：</p><ul><li><code>filter</code></li><li><code>map</code>：归类为一组数据</li><li><code>flatMap</code>：将map生成的流合并成单个流</li><li><code>peek</code>:与<code>map</code>类型，区别是它接受一个没有返回值的表达式</li><li><code>distinct</code>:去重</li><li><code>sorted</code>:对流中的元素进行排序</li><li><code>limit</code>:减少流的大小</li><li><code>substream</code></li></ul><p>终止操作有：</p><ul><li><code>forEach</code>：遍历该流中的每个元素</li><li><code>toArray</code></li><li><code>reduce</code>:用于对两个顺序流的计算</li><li><code>collect</code>:方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li><li><code>min</code></li><li><code>max</code></li><li><code>count</code></li><li><code>anyMatch</code>:是否存在任意一个元素满足条件（返回布尔值）</li><li><code>allMatch</code>:是否所有元素都满足条件（返回布尔值）</li><li><code>noneMatch</code>:是否所有条件都不满足（返回布尔值）</li><li><code>findFirst</code>:查找到第一个就返回Optional</li><li><code>findAny</code>:查找到任意一个就返回Optional</li><li><code>java.util.stream.Collectors</code></li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>方法说明：</p><ul><li><code>isPresent</code>:为空返回true,否返回false</li><li><code>orElse</code>:为空，则返回默认值</li><li><code>orElseGet</code>:为空，调动get回调函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rocketmq基础实践</title>
    <link href="/2019/07/14/Java/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/"/>
    <url>/2019/07/14/Java/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Rocketmq基础实践"><a href="#Rocketmq基础实践" class="headerlink" title="Rocketmq基础实践"></a>Rocketmq基础实践</h1><h2 id="为什么使用RocketMQ"><a href="#为什么使用RocketMQ" class="headerlink" title="为什么使用RocketMQ"></a>为什么使用RocketMQ</h2><blockquote><p><a href="https://rocketmq.apache.org/docs/motivation/" target="_blank" rel="noopener">https://rocketmq.apache.org/docs/motivation/</a></p><p><a href="https://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/" target="_blank" rel="noopener">https://rocketmq.apache.org/rocketmq/how-to-support-more-queues-in-rocketmq/</a></p></blockquote><p><strong>消息队列的优点：</strong></p><ul><li>解耦</li><li>异步</li><li>削峰</li></ul><p><strong>消息队列缺点：</strong></p><ul><li>系统可用性降低</li><li>系统复杂度提高</li><li>存在一致性问题</li></ul><p><strong>常见MQ对比</strong></p><table><thead><tr><th>MQ</th><th>单机吞吐量</th><th>时效性</th><th>可用性</th><th>备注</th></tr></thead><tbody><tr><td>ActiveMQ</td><td>万级</td><td>ms</td><td>高</td><td>社区不活跃</td></tr><tr><td>RabbitMQ</td><td>万级</td><td>μs</td><td>高</td><td>并发性能很强，性能较好，延时低</td></tr><tr><td>RocketMQ</td><td>10万级</td><td>ms</td><td>非常高</td><td>分布式系统，适用于topic较多（几百、几千）的场景</td></tr><tr><td>Kafaka</td><td>100万级</td><td>ms</td><td>非常高</td><td>一般配合大数据类的系统来进行实时数据计算、日志采集等场景(ELK+Kafka)，不适用topic较多的场景</td></tr></tbody></table><h2 id="RocketMQ-特点"><a href="#RocketMQ-特点" class="headerlink" title="RocketMQ 特点"></a>RocketMQ 特点</h2><blockquote><p>RocketMQ 是阿里巴巴在2012年开源的分布式消息中间件，目前已经捐赠给 Apache 软件基金会，并于2017年9月25日成为 Apache 的顶级项目。作为经历过多次阿里巴巴双十一这种“超级工程”的洗礼并有稳定出色表现的国产中间件，以其高性能、低延时和高可靠等特性近年来已经也被越来越多的国内企业使用。</p><p>目前RocketMQ在阿里集团被广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，binglog分发等场景。</p></blockquote><ul><li>灵活可扩展性</li><li>海量消息堆积能力</li><li>支持顺序消息</li><li>支持多种消息过滤方式</li><li>支持事务消息</li><li>支持回溯消费</li></ul><h2 id="RocketMQ物理结构"><a href="#RocketMQ物理结构" class="headerlink" title="RocketMQ物理结构"></a>RocketMQ物理结构</h2><p> <img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/mq/%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" alt="物理结构图"></p><p><strong>NameServer：</strong></p><ul><li><p>NameServer是RocketMQ的寻址服务，存储Broker的路由信息以及配置信息，用户端（生成者消费者）依靠NameServer去选择对于的Broker服务</p></li><li><p>NameServer集群成员之间互补通信</p></li><li><p>NameServer本身不存储数据，其数据均来自Broker与用户端</p></li></ul><p><strong>Broker：</strong></p><p>Broker负责存储生产者发送的消息，并为消费者提供消费支撑。</p><ul><li>Broker以group分开，每个group只允许存在一个master</li><li>Master、Slave之间数据同步可选择同步、异步复制，同理Master与Master之间也存在同步</li><li>Broker向所有NameServer节点简历长连接，注册Topic信息</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><blockquote><p>服务器：CentOS7 64位</p><p>JDK：1.8</p><p>内存：官方建议8G内存</p></blockquote><h3 id="下载软件包"><a href="#下载软件包" class="headerlink" title="下载软件包"></a>下载软件包</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/</span><span class="hljs-meta">#</span><span class="bash"> wget http://mirror.bit.edu.cn/apache/rocketmq/4.3.2/rocketmq-all-4.3.2-bin-release.zip</span><span class="hljs-meta">#</span><span class="bash"> unzip rocketmq-all-4.3.2-bin-release.zip</span><span class="hljs-meta">#</span><span class="bash"> mv rocketmq-all-4.3.2-bin-release rocketmq</span></code></pre><h3 id="修改日志目录"><a href="#修改日志目录" class="headerlink" title="修改日志目录"></a>修改日志目录</h3><p>在<code>rocketmq/conf</code>目录下的<code>logback*.log</code>文件中配置了日志目录为<code>${user.home}/logs/....</code>，如果想要改变目录只需将<code>${user.home}</code>改为指定目录即可。</p><p>可以使用send命令替换所有logback配置文件中的${usr.home}</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/rocketmq/conf/</span><span class="hljs-meta">#</span><span class="bash"> sed -i <span class="hljs-string">'s#$&#123;user.home&#125;#/usr/local/rocketmq#g'</span> *.xml</span></code></pre><p>修改启动内存</p><p>rocketmq官方预设的NameServer内存为4G，Broker内存为8G。而在开发测试的往往服务器资源较低，建议降低内存大小。</p><p>切换到rocketmq的bin目录下（<code>cd /usr/local/rocketmq/bin</code>），分别修改<code>runbroker.sh</code>与<code>runserver.sh</code>脚本中的<code>JAVA_OPT</code>参数</p><p>runserver.sh</p><pre><code class="hljs sh">JAVA_OPT=<span class="hljs-string">"<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -server -Xms4g -Xmx4g -Xmn2g -XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=320m"</span></code></pre><p>runbroker.sh</p><pre><code class="hljs sh">JAVA_OPT=<span class="hljs-string">"<span class="hljs-variable">$&#123;JAVA_OPT&#125;</span> -server -Xms8g -Xmx8g -Xmn4g"</span></code></pre><h3 id="启动RocketMQ"><a href="#启动RocketMQ" class="headerlink" title="启动RocketMQ"></a>启动RocketMQ</h3><blockquote><p>对于NameServer与Broker的启动，均可以在启动命令中增加参数，比如使用<code>-c</code>指定配置文件，</p></blockquote><p>因为Broker要依赖NameServer，所以应先启动NameServer再启动Broker</p><p><strong>启动NameServer</strong></p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/rocketmq/conf/bin</span><span class="hljs-meta">#</span><span class="bash"> nohup sh mqnamesrv &gt;/dev/null 2&gt;&amp;1 &amp;</span><span class="hljs-meta">#</span><span class="bash"> 也可以使用-c为其指定配置文件</span><span class="hljs-meta">#</span><span class="bash"> nohup sh mqnamesrv -c namesrv.conf &gt;/dev/null 2&gt;&amp;1 &amp;</span></code></pre><p><strong>启动Broker</strong></p><p>启动Broker之前先为其指定一个配置文件(<code>broker.conf</code>)，内容如下：</p><pre><code class="hljs properties"><span class="hljs-attr">namesrvAddr</span>=<span class="hljs-string">192.168.152.134:9876</span><span class="hljs-attr">brokerName</span> = <span class="hljs-string">broker-a</span><span class="hljs-attr">brokerId</span> = <span class="hljs-string">0</span><span class="hljs-attr">deleteWhen</span> = <span class="hljs-string">04</span><span class="hljs-attr">fileReservedTime</span> = <span class="hljs-string">48</span><span class="hljs-attr">storePathRootDir</span>=<span class="hljs-string">/usr/local/rocketmq/store</span><span class="hljs-attr">brokerRole</span> = <span class="hljs-string">ASYNC_MASTER</span><span class="hljs-attr">flushDiskType</span> = <span class="hljs-string">ASYNC_FLUSH</span></code></pre><p>启动Broker同时通过-c指定该配置文件</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> nohup sh mqbroker -c ../conf/broker.conf &gt;/dev/null 2&gt;&amp;1 &amp;</span></code></pre><p><strong>检测服务是否启动</strong></p><p>使用<code>jps</code>命令查看当前java进程，也可以使用<code>ps</code>命令</p><pre><code class="hljs shell">[root@rocketmq-nameserver2 bin]# jps3104 Jps2689 NamesrvStartup2979 BrokerStartup[root@rocketmq-nameserver2 bin]# ps -ef|grep mqnamesrvroot       2683   2303  0 03:57 pts/0    00:00:00 sh mqnamesrvroot       3120   2303  0 04:08 pts/0    00:00:00 grep --color=auto mqnamesrv[root@rocketmq-nameserver2 bin]# ps -ef|grep mqbrokerroot       2972   2303  0 04:06 pts/0    00:00:00 sh mqbroker -c ../conf/broker.confroot       3122   2303  0 04:08 pts/0    00:00:00 grep --color=auto mqbroker</code></pre><h3 id="控制台安装"><a href="#控制台安装" class="headerlink" title="控制台安装"></a>控制台安装</h3><blockquote><p>apache/rocketmq-externals： <a href="https://github.com/apache/rocketmq-externals" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals</a></p><p>rocketmq-externals中的rocketmq-console目录为控制台源码，下载源码，使用<code>mvn spring-boot:run</code>命令启动项目，访问地址：<a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a></p></blockquote><ol><li>目前官方版本pom文件存在问题，如果直接启动会导致控制台报如下错误：</li></ol><pre><code class="hljs plain">[ERROR] Failed to execute goal on project rocketmq-console-ng: Could not resolve dependencies for project org.apache:rocketmq-console-ng:jar:1.0.0: Failed to collect dependencies for [org.springframework.boot:spring-boot-starter-web:jar:1.4.3.RELEASE (compile), org.springframework.boot:spring-boot-starter-actuator:jar:1.4.3.RELEASE (compile), org.springframework.boot:spring-boot-starter-test:jar:1.4.3.RELEASE (test), commons-collections:commons-collections:jar:3.2.2 (compile), org.apache.rocketmq:rocketmq-tools:jar:4.4.0-SNAPSHOT (compile), org.apache.rocketmq:rocketmq-namesrv:jar:4.4.0-SNAPSHOT (compile), org.apache.rocketmq:rocketmq-broker:jar:4.4.0-SNAPSHOT (compile), com.google.guava:guava:jar:16.0.1 (compile), org.aspectj:aspectjrt:jar:1.6.11 (compile), org.aspectj:aspectjweaver:jar:1.6.11 (compile), cglib:cglib:jar:2.2.2 (compile), org.jooq:joor:jar:0.9.6 (compile)]: Failed to read artifact descriptor for org.apache.rocketmq:rocketmq-tools:jar:4.4.0-SNAPSHOT: Could not transfer artifact org.apache.rocketmq:rocketmq-tools:pom:4.4.0-SNAPSHOT from&#x2F;to nexus (http:&#x2F;&#x2F;repo.thunisoft.com&#x2F;maven2&#x2F;content&#x2F;groups&#x2F;public-snapshots&#x2F;)</code></pre><p>官方issues说是因为pom文件中rocketmq版本问题，将其改为4.4.0即可，原文地址：<a href="https://github.com/apache/rocketmq-externals/issues/208" target="_blank" rel="noopener">https://github.com/apache/rocketmq-externals/issues/208</a></p><ol start="2"><li>在<code>rocketmq-console\src\main\resources\application.properties</code>文件中指定配置</li></ol><pre><code class="hljs properties"><span class="hljs-meta">server.contextPath</span>=<span class="hljs-string"></span><span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span><span class="hljs-comment">#spring.application.index=true</span><span class="hljs-meta">spring.application.name</span>=<span class="hljs-string">rocketmq-console</span><span class="hljs-meta">spring.http.encoding.charset</span>=<span class="hljs-string">UTF-8</span><span class="hljs-meta">spring.http.encoding.enabled</span>=<span class="hljs-string">true</span><span class="hljs-meta">spring.http.encoding.force</span>=<span class="hljs-string">true</span><span class="hljs-meta">logging.config</span>=<span class="hljs-string">classpath:logback.xml</span><span class="hljs-comment">#if this value is empty,use env value rocketmq.config.namesrvAddr  NAMESRV_ADDR | now, you can set it in ops page.default localhost:9876</span><span class="hljs-meta">rocketmq.config.namesrvAddr</span>=<span class="hljs-string">192.168.152.134:9876</span><span class="hljs-comment">#if you use rocketmq version &lt; 3.5.8, rocketmq.config.isVIPChannel should be false.default true</span><span class="hljs-meta">rocketmq.config.isVIPChannel</span>=<span class="hljs-string"></span><span class="hljs-comment">#rocketmq-console's data path:dashboard/monitor</span><span class="hljs-meta">rocketmq.config.dataPath</span>=<span class="hljs-string">/tmp/rocketmq-console/data</span><span class="hljs-comment">#set it false if you don't want use dashboard.default true</span><span class="hljs-meta">rocketmq.config.enableDashBoardCollect</span>=<span class="hljs-string">true</span><span class="hljs-comment">#set the message track trace topic if you don't want use the default one</span><span class="hljs-meta">rocketmq.config.msgTrackTopicName</span>=<span class="hljs-string"></span></code></pre><ol start="3"><li>RocketMQ-Console中的消息状态，对于源码包中的<code>org.apache.rocketmq.tools.admin.api.TrackType</code><ol><li>CONSUMED 代表该消息已经被消费</li><li>NOT_CONSUME_YET 还没被消费</li><li>UNKNOW_EXCEPTION 消费出现异常</li><li>NOT_ONLINE 消费者离线</li></ol></li></ol><h3 id="NameServer配置项"><a href="#NameServer配置项" class="headerlink" title="NameServer配置项"></a>NameServer配置项</h3><table><thead><tr><th>配置项</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>listenPort</td><td>监昕端口，值默认9876</td><td></td></tr><tr><td>serverWorkerThreads</td><td>Netty 业务线程池线程个数，默认值为8</td><td></td></tr><tr><td>serverCallbackExecutorThreads</td><td>Netty public 任务线程池线程个数</td><td>Netty网络设计，根据业务类型会创建不同的线程池，比如处理消息发送、消息消费、心跳检测等</td></tr><tr><td>serverSelectorThreads</td><td>IO 线程池线程个数，默认为3，主要是 NameServer Broker 端解析请求、返回相应的线程个数</td><td>这类线程主要是处理网络请求的，解析请求包， 然后转发到各个业务线程池完成具体的业务操作，然后将结果再返回调用方</td></tr><tr><td>serverOnewaySemaphoreValue</td><td>单次消息最大并发度，默认256</td><td>消息请求并发度</td></tr><tr><td>serverAsyncSemaphoreValue</td><td>异步消息最大并发度，默认64</td><td></td></tr><tr><td>serverChannelMaxIdleTimeSeconds</td><td>网络最大空闲时间，默认120秒</td><td></td></tr></tbody></table><h3 id="Broker配置项"><a href="#Broker配置项" class="headerlink" title="Broker配置项"></a>Broker配置项</h3><table><thead><tr><th>配置项</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>brokerClusterName</td><td>所属集群名字</td><td>默认值DefaultCluster</td></tr><tr><td>brokerName</td><td>broker 名字</td><td>不同的主节点应配置不同的名称</td></tr><tr><td>brokerId</td><td>broker Id</td><td>0 表示 Master，&gt;0 表示 Slave</td></tr><tr><td>namesrvAddr</td><td>namesrvAddr地址</td><td>多个地址用分号分隔</td></tr><tr><td>defaultTopicQueueNums</td><td>默认主题队列数，默认4</td><td>在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数</td></tr><tr><td>autoCreateTopicEnable</td><td>自动创建主题状态，默认false</td><td>是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭</td></tr><tr><td>autoCreateSubscriptionGroup</td><td>自动创建订阅组状态，默认false</td><td>是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</td></tr><tr><td>listenPort</td><td>监听端口</td><td>Broker 对外服务的监听端口</td></tr><tr><td>deleteWhen</td><td>删除文件时间点，默认凌晨 4 点（04）</td><td>与清理机制有关</td></tr><tr><td>fileReservedTime</td><td>文件保留时间，默认48小时</td><td>与清理机制有关</td></tr><tr><td>mapedFileSizeCommitLog</td><td>commitLog 每个文件的大小默认 1G</td><td>文件超过该值后，会新建一个文件</td></tr><tr><td>mapedFileSizeConsumeQueue</td><td>ConsumeQueue 每个文件存储个数，默认存 30W 条</td><td></td></tr><tr><td>destroyMapedFileIntervalForcibly</td><td>文件拒绝删除后存活的最大时间，毫秒</td><td>第一次拒绝删除之后能保留的最大时间</td></tr><tr><td>deletePhysicFilesInterval</td><td>删除物理文件间隔，毫秒</td><td>因为在一次清除过程中，可能需要删除的文件不止一个，该值指定两次删除文件的间隔时间。</td></tr><tr><td>diskMaxUsedSpaceRatio</td><td>检测物理文件磁盘空间，默认75</td><td></td></tr><tr><td>diskSpaceWarningLevelRatio</td><td>磁盘空间警戒大小</td><td>磁盘空间警戒大小，超过，则停止接收新消息（出于保护自身目的）默认是90</td></tr><tr><td>diskSpaceCleanForciblyRatio</td><td>磁盘空间强制删除文件大小。默认是85</td><td></td></tr><tr><td>storePathRootDir</td><td>文件存储路径</td><td></td></tr><tr><td>storePathCommitLog</td><td>commitLog 存储路径</td><td>存储消息</td></tr><tr><td>storePathConsumeQueue</td><td>消费队列存储路径存储路径</td><td></td></tr><tr><td>storePathIndex</td><td>消息索引存储路径</td><td></td></tr><tr><td>storeCheckpoint</td><td>checkpoint 文件存储路径</td><td>异常恢复时根据checkpoint点来恢复消息</td></tr><tr><td>abortFile</td><td>abort 文件存储路径</td><td>临时文件，主要记录是否正常关闭</td></tr><tr><td>maxMessageSize</td><td>消息最大大小</td><td></td></tr><tr><td>brokerRole</td><td>Broker 的角色</td><td>ASYNC_MASTER 异步复制主节点 ；SYNC_MASTER 同步双写主节点； SLAVE 从节点</td></tr><tr><td>flushDiskType</td><td>刷盘方式</td><td>ASYNC_FLUSH 异步刷盘;SYNC_FLUSH 同步刷盘</td></tr></tbody></table><h3 id="Broker高可用"><a href="#Broker高可用" class="headerlink" title="Broker高可用"></a>Broker高可用</h3><p><strong>主从同步方式：</strong></p><ul><li><p>同步双写：Master节点收到消息后，同步消息到Slave节点，主备都写成功，再向返回成功</p></li><li><p>异步复制：Master节点收到消息后，先返回成功，再同步到Slave节点</p></li></ul><p><strong>刷盘方式：</strong></p><ul><li><p>同步刷盘：节点收到消息后，将数据持久化到硬盘后，再返回成功</p></li><li><p>异步刷盘：节点收到消息后，将消息存储在内存中，先返回成功，再持久化到硬盘中</p></li></ul><p><strong>官方提供的配置：</strong></p><p>在<code>rocketmq/conf</code>目录下存在3个配置文件示例，分别为：</p><ul><li>2m-2s-async 异步复制、异步刷盘</li><li>2m-2s-sync 同步双写，异步刷盘</li><li>2m-noslave 多主节点、异步刷盘</li></ul><p><strong>推荐使用：</strong>同步双写，异步刷盘</p><p><strong>最稳妥的方式：</strong>同步双写、同步刷盘</p><h2 id="消息存储"><a href="#消息存储" class="headerlink" title="消息存储"></a>消息存储</h2><h3 id="消息存储结构"><a href="#消息存储结构" class="headerlink" title="消息存储结构"></a>消息存储结构</h3><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/mq/%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84%E5%9B%BE.png" srcset="/img/loading.gif" alt="消息结构图"></p><h3 id="偏移量（Offset）"><a href="#偏移量（Offset）" class="headerlink" title="偏移量（Offset）"></a>偏移量（<code>Offset</code>）</h3><ul><li>Offset是消费进度的核心</li><li>Offset的存储实现分为远程存储于本地存储两种</li><li>对于PushConsumer（集群），Offset存储在Broker端；对于PullComsumer，Offset需要消费者自己维护，将其存在在消费者端</li><li>集群消费模式，Offset存储在Broker端；广播消费模式，Offset春常在消费者端</li><li>Consumer Offset用于标记Consumer Group在一条Consumer Queue上的消费进度</li></ul><h2 id="生成者"><a href="#生成者" class="headerlink" title="生成者"></a>生成者</h2><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><ul><li>producerGroup：组名唯一</li><li>createTopicKey：创建主题时需要的密钥</li><li>defaultTopicQueueNums：在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数，默认4</li><li>sendMsgTimeout：发送消息超时时间</li><li>compressMsgBodyOverHowmuch：消息压缩字节，默认4096字节，超过该值，rocketmq就会对消息进行压缩</li><li>retryTimesWhenSendFailed：重发策略，同理存在异步的（retryTimesWhenSendAsyncFailed）</li><li>retryAnotherBrokerWhenNotStoreOk:默认false</li><li>maxMessagerSize：消息最大容量，默认128k</li></ul><h3 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h3><p>同步发送消息：DefaultMQProducerImpl.producer.send(msg);</p><p>异步发送消息：producer.send(Message msg,SendCallback sendCallback);</p><h2 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h2><h3 id="消费模式"><a href="#消费模式" class="headerlink" title="消费模式"></a>消费模式</h3><p><strong>集群模式：</strong></p><ul><li>RocketMQ默认采用集群消费模式</li><li>同一ComsumerGroup中的消费者只消费一次</li></ul><p><strong>广播模式：</strong></p><ul><li>广播模式下，每个Consumer都会对消息进行消费</li></ul><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><blockquote><p>首先先定义一个MessageListenerConcurrently</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageListenerConcurrently</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MessageListenerConcurrently</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> ConsumeConcurrentlyStatus <span class="hljs-title">consumeMessage</span><span class="hljs-params">(List&lt;MessageExt&gt; list,</span></span><span class="hljs-function"><span class="hljs-params">        ConsumeConcurrentlyContext consumeConcurrentlyContext)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            MessageExt messageExt = list.get(<span class="hljs-number">0</span>);            String body = <span class="hljs-keyword">new</span> String(messageExt.getBody(), RemotingHelper.DEFAULT_CHARSET);            System.out.printf(<span class="hljs-string">"QueueId:%s;Book:%s%n"</span>, messageExt.getQueueId(), body);            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.CONSUME_SUCCESS;        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;            e.printStackTrace();            <span class="hljs-keyword">return</span> ConsumeConcurrentlyStatus.RECONSUME_LATER;        &#125;    &#125;&#125;</code></pre><h4 id="定时消息"><a href="#定时消息" class="headerlink" title="定时消息"></a>定时消息</h4><blockquote><p>定时消息是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费</p></blockquote><p>目前Rocket只支持固定精度的定时消息，官方解释为：</p><blockquote><p>如果要支持任意的时间精度，在 Broker 层面，必须要做消息排序，如果再涉及到持久化，那么消息排序要不可避免的产生巨大性能开销</p></blockquote><p>其精度如下：</p><table><thead><tr><th>延迟级别</th><th>时间</th><th>延迟级别</th><th>时间</th></tr></thead><tbody><tr><td>1</td><td>1s</td><td>2</td><td>5s</td></tr><tr><td>3</td><td>10s</td><td>4</td><td>30s</td></tr><tr><td>5</td><td>1m</td><td>6</td><td>2m</td></tr><tr><td>7</td><td>3m</td><td>8</td><td>4m</td></tr><tr><td>9</td><td>5m</td><td>10</td><td>6m</td></tr><tr><td>11</td><td>7m</td><td>12</td><td>8m</td></tr><tr><td>13</td><td>9m</td><td>14</td><td>10m</td></tr><tr><td>15</td><td>20m</td><td>16</td><td>30m</td></tr><tr><td>17</td><td>1h</td><td>18</td><td>2h</td></tr></tbody></table><p><strong>producer代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        DefaultMQProducer producer = <span class="hljs-keyword">new</span> DefaultMQProducer(<span class="hljs-string">"test_producer_group"</span>);        producer.setNamesrvAddr(MessageConstants.NAMESRV_ADDR);        producer.start();        <span class="hljs-keyword">int</span> totalMessagesToSend = <span class="hljs-number">100</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; totalMessagesToSend; i++) &#123;            Message message = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">"schedule_message_test_topic"</span>, (<span class="hljs-string">"Hello scheduled message "</span> + i).getBytes());            <span class="hljs-comment">//设置级别为3，延迟10s</span>            message.setDelayTimeLevel(<span class="hljs-number">3</span>);            producer.send(message);        &#125;        producer.shutdown();    &#125;&#125;</code></pre><p><strong>consumer代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;        DefaultMQPushConsumer consumer = <span class="hljs-keyword">new</span> DefaultMQPushConsumer(<span class="hljs-string">"test_consumer_group"</span>);        consumer.setNamesrvAddr(MessageConstants.NAMESRV_ADDR);        consumer.subscribe(<span class="hljs-string">"test_scheduled"</span>, <span class="hljs-string">"*"</span>);        consumer.registerMessageListener(<span class="hljs-keyword">new</span> MyMessageListenerConcurrently());        consumer.start();        System.out.printf(<span class="hljs-string">"Consumer Started.%n"</span>);    &#125;&#125;</code></pre><h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><ul><li>顺序消息：指的是消息的消费顺序与生存顺序相同</li><li>全局顺序：在某个topic下，所有消息都要保证顺序，设置一个队列</li><li>局部顺序：只要保证每一组消息被顺序消费即可，根据消息特性，投放到指定队列</li></ul><p><strong>producer代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException, InterruptedException </span>&#123;        DefaultMQProducer producer = <span class="hljs-keyword">new</span> DefaultMQProducer(<span class="hljs-string">"test_producer_group"</span>);        producer.setNamesrvAddr(MessageConstants.NAMESRV_ADDR);        producer.start();        Map&lt;Integer, Book&gt; bookMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        bookMap.put(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> Book(<span class="hljs-number">1</span>, <span class="hljs-string">"语文"</span>));        bookMap.put(<span class="hljs-number">2</span>, <span class="hljs-keyword">new</span> Book(<span class="hljs-number">2</span>, <span class="hljs-string">"数学"</span>));        bookMap.put(<span class="hljs-number">3</span>, <span class="hljs-keyword">new</span> Book(<span class="hljs-number">3</span>, <span class="hljs-string">"英语"</span>));        bookMap.put(<span class="hljs-number">4</span>, <span class="hljs-keyword">new</span> Book(<span class="hljs-number">4</span>, <span class="hljs-string">"物理"</span>));        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">8</span>; i++) &#123;            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">int</span> bookId = i % <span class="hljs-number">4</span>;                <span class="hljs-keyword">if</span> (bookId == <span class="hljs-number">0</span>) &#123;                    bookId = <span class="hljs-number">4</span>;                &#125;                Book book = bookMap.get(bookId);                Message msg = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">"test_book"</span>, <span class="hljs-string">"TagA"</span>,                    JSON.toJSONString(book).getBytes(RemotingHelper.DEFAULT_CHARSET));                msg.setKeys(<span class="hljs-string">"book_id_"</span> + book.getId());                SendResult sendResult = producer.send(msg, <span class="hljs-keyword">new</span> MessageQueueSelector() &#123;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> MessageQueue <span class="hljs-title">select</span><span class="hljs-params">(List&lt;MessageQueue&gt; list, Message message, Object o)</span> </span>&#123;                        Integer id = (Integer)o;                        <span class="hljs-keyword">int</span> index = id % list.size();                        <span class="hljs-keyword">return</span> list.get(index);                    &#125;                &#125;, book.getId());                System.out.printf(<span class="hljs-string">"%s%n"</span>, sendResult);            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                e.printStackTrace();                Thread.sleep(<span class="hljs-number">1000</span>);            &#125;        &#125;        producer.shutdown();    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;        <span class="hljs-keyword">this</span>.name = name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;        <span class="hljs-keyword">this</span>.id = id;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> name;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">this</span>.name = name;    &#125;&#125;</code></pre><p><strong>consumer代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;        DefaultMQPushConsumer consumer = <span class="hljs-keyword">new</span> DefaultMQPushConsumer(<span class="hljs-string">"test_consumer_group"</span>);        consumer.setNamesrvAddr(MessageConstants.NAMESRV_ADDR);        consumer.subscribe(<span class="hljs-string">"test_book"</span>, <span class="hljs-string">"TagA"</span>);        consumer.registerMessageListener(<span class="hljs-keyword">new</span> MyMessageListenerConcurrently());        consumer.start();        System.out.printf(<span class="hljs-string">"Consumer Started.%n"</span>);    &#125;&#125;</code></pre><h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/mq/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF.png" srcset="/img/loading.gif" alt="事务消息"></p><p><strong>MyTransactionListener代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTransactionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TransactionListener</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title">executeLocalTransaction</span><span class="hljs-params">(Message message, Object o)</span> </span>&#123;        System.out.printf(<span class="hljs-string">"executeLocalTransaction，Obejct:%s%n"</span>, JSON.toJSONString(o));        <span class="hljs-keyword">try</span> &#123;            Thread.sleep(<span class="hljs-number">5000</span>);        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-comment">// 该方法主要是设置本地事务状态，与业务方代码在一个事务中，只要本地事务提交成功，该方法也会提交成功</span>        <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title">checkLocalTransaction</span><span class="hljs-params">(MessageExt messageExt)</span> </span>&#123;        <span class="hljs-comment">// 告知RocketMQ是提交还是回滚</span>        <span class="hljs-comment">// 新版本将该方法与executeLocalTransaction进行合并</span>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><p><strong>producer代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;        TransactionMQProducer producer = <span class="hljs-keyword">new</span> TransactionMQProducer(<span class="hljs-string">"test_trans_group"</span>);        producer.setNamesrvAddr(MessageConstants.NAMESRV_ADDR);        ExecutorService executorService = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>, TimeUnit.SECONDS,            <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">2000</span>), <span class="hljs-keyword">new</span> ThreadFactory() &#123;                <span class="hljs-meta">@Override</span>                <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;                    Thread thread = <span class="hljs-keyword">new</span> Thread(r);                    thread.setName(<span class="hljs-string">"TransactionMQProducer-CheckThread"</span>);                    <span class="hljs-keyword">return</span> thread;                &#125;            &#125;);        producer.setExecutorService(executorService);        producer.setTransactionListener(<span class="hljs-keyword">new</span> MyTransactionListener());        producer.start();        ArgBean arg = <span class="hljs-keyword">new</span> ArgBean();        arg.setA(<span class="hljs-string">"testa"</span>);        arg.setB(<span class="hljs-string">"testb"</span>);        Message message            = <span class="hljs-keyword">new</span> Message(<span class="hljs-string">"test_trans"</span>, <span class="hljs-string">"TagA"</span>, (<span class="hljs-string">"test trans messsage!!obj:"</span> + JSON.toJSONString(arg)).getBytes());        producer.sendMessageInTransaction(message, arg);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArgBean</span> </span>&#123;    <span class="hljs-keyword">private</span> String a;    <span class="hljs-keyword">private</span> String b;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getA</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> a;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setA</span><span class="hljs-params">(String a)</span> </span>&#123;        <span class="hljs-keyword">this</span>.a = a;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getB</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> b;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setB</span><span class="hljs-params">(String b)</span> </span>&#123;        <span class="hljs-keyword">this</span>.b = b;    &#125;&#125;</code></pre><p><strong>consumer代码：</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MQClientException </span>&#123;        DefaultMQPushConsumer consumer = <span class="hljs-keyword">new</span> DefaultMQPushConsumer(<span class="hljs-string">"test_consumer_group"</span>);        consumer.setNamesrvAddr(MessageConstants.NAMESRV_ADDR);        consumer.subscribe(<span class="hljs-string">"test_trans"</span>, <span class="hljs-string">"TagA"</span>);        consumer.registerMessageListener(<span class="hljs-keyword">new</span> MyMessageListenerConcurrently());        consumer.start();        System.out.printf(<span class="hljs-string">"Consumer Started.%n"</span>);    &#125;&#125;</code></pre><h3 id="消费总览"><a href="#消费总览" class="headerlink" title="消费总览"></a>消费总览</h3><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/mq/rocketmq%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B.png" srcset="/img/loading.gif" alt="rocketmq消费者消费消息流程"></p><p>几个重要的变量：</p><ul><li>PullMessageService.pullRequestQueue 记录要发送到broker的请求</li><li>PullRequest.processQueue 流量控制，控制ConsumeRequest的并发访问</li><li>PullRequestHoldService.pullRequestTable 保存正在进行长轮询的请求信息</li><li>ManyPullRequest.pullRequestList 记录正在进行长轮询的PullRequest</li></ul><h3 id="Rebalance介绍"><a href="#Rebalance介绍" class="headerlink" title="Rebalance介绍"></a>Rebalance介绍</h3><h4 id="Consumer与ConsumerQueue"><a href="#Consumer与ConsumerQueue" class="headerlink" title="Consumer与ConsumerQueue"></a>Consumer与ConsumerQueue</h4><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/mq/%E6%B6%88%E8%B4%B9%E8%80%85%E4%B8%8E%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B3%E7%B3%BB.png" srcset="/img/loading.gif" alt="消费者与队列的关系"></p><h4 id="平衡算法"><a href="#平衡算法" class="headerlink" title="平衡算法"></a>平衡算法</h4><p>核心代码<code>RebalanceImpl#rebalanceByTopic</code>:</p><pre><code class="hljs java">allocateResult = strategy.allocate(                            <span class="hljs-keyword">this</span>.consumerGroup,                            <span class="hljs-keyword">this</span>.mQClientFactory.getClientId(),                            mqAll,                            cidAll);</code></pre><p>平衡算法<code>AllocateMessageQueueStrategy</code>的实现类</p><h2 id="消息队列同步实践"><a href="#消息队列同步实践" class="headerlink" title="消息队列同步实践"></a>消息队列同步实践</h2><p><strong>涉及知识点：</strong></p><ul><li>利用观察者模式，收集数据的变化，触发SpringEvent事件，从而进行消息发送</li><li>利用SpringEvent负责收集消息进行发送；消费消息时分责分发到不同的处理方法</li></ul><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/mq/%E7%9B%91%E7%8B%B1%E4%B8%80%E7%AB%99%E5%BC%8F%E7%BD%AA%E7%8A%AF%E4%BF%A1%E6%81%AF%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86.png" srcset="/img/loading.gif" alt="同步实践"></p><h2 id="钉钉社区"><a href="#钉钉社区" class="headerlink" title="钉钉社区"></a>钉钉社区</h2><ul><li>阿里中间件Aliware开发者中心 21711817</li><li>Apache RocketMQ 中国开发者钉钉群 21791227</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rocketmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rocketmq安装</title>
    <link href="/2019/07/14/Java/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%AE%89%E8%A3%85/"/>
    <url>/2019/07/14/Java/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/rocketmq%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.下载rocketmq</p><pre><code class="hljs plain"># wget http:&#x2F;&#x2F;mirror.bit.edu.cn&#x2F;apache&#x2F;rocketmq&#x2F;4.3.2&#x2F;rocketmq-all-4.3.2-bin-release.zip</code></pre><p>2.解压并从命名为rocketmq</p><pre><code class="hljs plain"># tar -zvxf rocketmq-all-4.3.2-bin-release.zip# mv rocketmq-all-4.3.2-bin-release rocketmq</code></pre><p>3.新建日志与存储目录</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;local&#x2F;rocketmq# mkdir logs# mkdir store# mkdir store&#x2F;commitlog  # mkdir store&#x2F;consumequeue  # mkdir store&#x2F;index # mkdir store&#x2F;checkpoint  # mkdir store&#x2F;abort</code></pre><p>4.修改rocketmq日志文件地址</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;local&#x2F;rocketmq# sed -i &#39;s#$&#123;user.home&#125;#&#x2F;usr&#x2F;local&#x2F;rocketmq#g&#39; *.xml</code></pre><p>5.配置文件</p><pre><code class="hljs plain">#所属集群名字brokerClusterName&#x3D;DefaultCluster#broker 名字brokerName&#x3D;broker-a#broker IdbrokerId&#x3D;0#nameServer 地址，如果有多个地址用分号分割namesrvAddr&#x3D;192.168.152.133:9876#在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数defaultTopicQueueNums&#x3D;4#是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭autoCreateTopicEnable&#x3D;true#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭autoCreateSubscriptionGroup&#x3D;true#Broker 对外服务的监听端口listenPort&#x3D;10911#删除文件时间点，默认凌晨 4 点deleteWhen&#x3D;04#文件保留时间，默认 48 小时fileReservedTime&#x3D;120#commitLog 每个文件的大小默认 1GmapedFileSizeCommitLog&#x3D;1073741824#ConsumeQueue 每个文件默认存 30W 条，根据业务情况调整mapedFileSizeConsumeQueue&#x3D;300000#destroyMapedFileIntervalForcibly&#x3D;120000#redeleteHangedFileInterval&#x3D;120000#检测物理文件磁盘空间diskMaxUsedSpaceRatio&#x3D;88#存储路径storePathRootDir&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store#commitLog 存储路径storePathCommitLog&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store&#x2F;commitlog#消费队列存储路径存储路径storePathConsumeQueue&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store&#x2F;consumequeue#消息索引存储路径storePathIndex&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store&#x2F;index#checkpoint 文件存储路径storeCheckpoint&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store&#x2F;checkpoint#abort 文件存储路径abortFile&#x3D;&#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;store&#x2F;abort#限制的消息大小maxMessageSize&#x3D;65536#Broker 的角色#- ASYNC_MASTER 异步复制 Master#- SYNC_MASTER 同步双写 Master#- SLAVEbrokerRole&#x3D;ASYNC_MASTER#刷盘方式#- ASYNC_FLUSH 异步刷盘#- SYNC_FLUSH 同步刷盘flushDiskType&#x3D;ASYNC_FLUSH# 检测事务checkTransactionMessageEnable&#x3D;false#发消息线程池数量sendMessageThreadPoolNums&#x3D;128#拉消息线程池数量pullMessageThreadPoolNums&#x3D;128</code></pre><p>6.修改启动参数</p><pre><code class="hljs plain"># cd &#x2F;usr&#x2F;local&#x2F;rocketmq&#x2F;bin</code></pre><p>在<code>bin</code>目录中</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>1.启动nameserver</p><pre><code class="hljs plain"># nohup sh mqnamesrv &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</code></pre><p>namesrc默认端口为9876，如果需要修改端口，创建一个配置文件，然后启动时指定该配置文件即可。</p><p>配置文件内容：</p><pre><code class="hljs plain"># listenPort&#x3D;9877</code></pre><pre><code class="hljs plain"># nohup sh mqnamesrv -c ..&#x2F;conf&#x2F;namesrv.properties &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</code></pre><p>2.启动broker</p><pre><code class="hljs plain"># nohup sh mqbroker -c ..&#x2F;conf&#x2F;2m-2s-async&#x2F;broker-a.properties &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;</code></pre><h2 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h2><table><thead><tr><th>配置项</th><th>名称</th><th>备注</th></tr></thead><tbody><tr><td>brokerClusterName</td><td>所属集群名字</td><td></td></tr><tr><td>brokerName</td><td>broker 名字</td><td>不同的主节点应配置不同的名称</td></tr><tr><td>brokerId</td><td>broker Id</td><td>0 表示 Master，&gt;0 表示 Slave</td></tr><tr><td>namesrvAddr</td><td>namesrvAddr地址</td><td>多个地址用分号分隔</td></tr><tr><td>defaultTopicQueueNums</td><td>默认主题队列数，默认4</td><td>在发送消息时，自动创建服务器不存在的 topic，默认创建的队列数</td></tr><tr><td>autoCreateTopicEnable</td><td>自动创建主题状态，默认false</td><td>是否允许 Broker 自动创建 Topic，建议线下开启，线上关闭</td></tr><tr><td>autoCreateSubscriptionGroup</td><td>自动创建订阅组状态，默认false</td><td>是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</td></tr><tr><td>listenPort</td><td>监听端口</td><td>Broker 对外服务的监听端口</td></tr><tr><td>deleteWhen</td><td>删除文件时间点，默认凌晨 4 点（04）</td><td>与清理机制有关</td></tr><tr><td>fileReservedTime</td><td>文件保留时间，默认48小时</td><td>与清理机制有关</td></tr><tr><td>mapedFileSizeCommitLog</td><td>commitLog 每个文件的大小默认 1G</td><td>文件超过该值后，会新建一个文件</td></tr><tr><td>mapedFileSizeConsumeQueue</td><td>ConsumeQueue 每个文件存储个数，默认存 30W 条</td><td></td></tr><tr><td>destroyMapedFileIntervalForcibly</td><td>文件拒绝删除后存活的最大时间，毫秒</td><td>第一次拒绝删除之后能保留的最大时间</td></tr><tr><td>deletePhysicFilesInterval</td><td>删除物理文件间隔，毫秒</td><td>因为在一次清除过程中，可能需要删除的文件不止一个，该值指定两次删除文件的间隔时间。</td></tr><tr><td>diskMaxUsedSpaceRatio</td><td>检测物理文件磁盘空间，默认75</td><td></td></tr><tr><td>diskSpaceWarningLevelRatio</td><td>磁盘空间警戒大小</td><td>磁盘空间警戒大小，超过，则停止接收新消息（出于保护自身目的）默认是90</td></tr><tr><td>diskSpaceCleanForciblyRatio</td><td>磁盘空间强制删除文件大小。默认是85</td><td></td></tr><tr><td>storePathRootDir</td><td>文件存储路径</td><td></td></tr><tr><td>storePathCommitLog</td><td>commitLog 存储路径</td><td>存储消息</td></tr><tr><td>storePathConsumeQueue</td><td>消费队列存储路径存储路径</td><td></td></tr><tr><td>storePathIndex</td><td>消息索引存储路径</td><td></td></tr><tr><td>storeCheckpoint</td><td>checkpoint 文件存储路径</td><td>异常恢复时根据checkpoint点来恢复消息</td></tr><tr><td>abortFile</td><td>abort 文件存储路径</td><td>临时文件，主要记录是否正常关闭</td></tr><tr><td>maxMessageSize</td><td>消息最大大小</td><td></td></tr><tr><td>brokerRole</td><td>Broker 的角色</td><td>ASYNC_MASTER 异步复制主节点 ；SYNC_MASTER 同步双写主节点； SLAVE 从节点</td></tr><tr><td>flushDiskType</td><td>刷盘方式</td><td>ASYNC_FLUSH 异步刷盘;SYNC_FLUSH 同步刷盘</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>消息中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rocketmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jekyllcn在windows下安装</title>
    <link href="/2019/05/23/normal/jekyllcn%E5%9C%A8windows%E4%B8%8B%E5%AE%89%E8%A3%85/"/>
    <url>/2019/05/23/normal/jekyllcn%E5%9C%A8windows%E4%B8%8B%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="首先安装Chocolatey"><a href="#首先安装Chocolatey" class="headerlink" title="首先安装Chocolatey"></a>首先安装Chocolatey</h2><blockquote><p>关于Chocolatey的安装可以查看其官网 <a href="https://chocolatey.org/install" target="_blank" rel="noopener">https://chocolatey.org/install</a></p></blockquote><p>cmd命令(管理员运行)</p><pre><code class="hljs plain">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;chocolatey.org&#x2F;install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH&#x3D;%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre><p>win10下可使用PowerShell(管理员运行)</p><pre><code class="hljs plain">Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString(&#39;https:&#x2F;&#x2F;chocolatey.org&#x2F;install.ps1&#39;))</code></pre><p>值得注意的是：</p><p>在运行任何这些脚本之前，请检查<a href="https://chocolatey.org/install.ps1" target="_blank" rel="noopener">https://chocolatey.org/install.ps1</a>是否能够正常访问。</p><h2 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a>安装ruby</h2><p>在成功安装Chocolatey后，我们可以使用choco来安装软件包</p><pre><code class="hljs plain">choco install ruby -version 2.2.4choco install ruby2.devkit</code></pre><p>其中 ruby2.devkit 是编译json gem时使用</p><p>配置Ruby development kitPermalink</p><p>Ruby开发工具包并没有设置Ruby环境变量，所以我们需要手动设置：</p><ul><li><p>在<code>C:\tools\DevKit2</code>目录下打开命令行界面</p></li><li><p>执行<code>ruby dk.rb init</code>命令创建配置文件<code>config.yml</code></p></li><li><p>编辑文件<code>config.yml</code>在其中包含Ruby路径<code>- C:/tools/ruby22</code></p></li><li><p>执行命令创建路径： <code>ruby dk.rb install</code></p></li></ul><p>其中需要注意的是，如果是在win10 PowerShell中执行可能会报如下错误：</p><pre><code class="hljs plain">ruby : 无法将“ruby”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。所在位置 行:1 字符: 1+ ruby dk.rb install+ ~~~~    + CategoryInfo          : ObjectNotFound: (ruby:String) [], CommandNotFoundException    + FullyQualifiedErrorId : CommandNotFoundException</code></pre><p>这是因为windows默认不允许执行任何脚本，解决办法是设置ExecutionPolicy为Unrestricted（可以运行脚本或者读取配置文件，如果执行的是从网上下载的脚本，那么会有一个申请权限的提示。 ）</p><pre><code class="hljs plain">Set-ExecutionPolicy Unrestricted</code></pre><p> 当然你也可以在<code>CMD</code>中执行<code>ruby dk.rb install</code>命令</p><h2 id="Nokogiri软件包安装"><a href="#Nokogiri软件包安装" class="headerlink" title="Nokogiri软件包安装"></a>Nokogiri软件包安装</h2><p>github-pages运行时需要Nokogiri这个软件包，但是要运行在64位Windows系统上还需要执行以下命令： </p><p><strong>注意:</strong> 在当前版本 <a href="https://github.com/sparklemotion/nokogiri/issues/1456#issuecomment-206481794" target="_blank" rel="noopener">pre release</a> 中提供了64位Windows系统支持，但是github-pages中并没有引用这个版本。 </p><pre><code class="hljs plain">choco install libxml2 -Source &quot;https:&#x2F;&#x2F;www.nuget.org&#x2F;api&#x2F;v2&#x2F;&quot;choco install libxslt -Source &quot;https:&#x2F;&#x2F;www.nuget.org&#x2F;api&#x2F;v2&#x2F;&quot;choco install libiconv -Source &quot;https:&#x2F;&#x2F;www.nuget.org&#x2F;api&#x2F;v2&#x2F;&quot;</code></pre><p>然后找到通过choco安装的三个包的路径，我的电脑安装在<code>C:\ProgramData\chocolatey\lib</code>下</p><pre><code class="hljs plain">c:\tools\DevKit2&gt;gem install nokogiri --^ --with-xml2-include&#x3D;C:\ProgramData\chocolatey\lib\libxml2\build\native\include^ --with-xml2-lib&#x3D;C:\ProgramData\chocolatey\lib\libxml2.redist\build\native\bin\v110\x64\Release\dynamic\cdecl^ --with-iconv-include&#x3D;C:\ProgramData\chocolatey\lib\libiconv\build\native\include^ --with-iconv-lib&#x3D;C:\ProgramData\chocolatey\lib\libiconv.redist\build\native\bin\v110\x64\Release\dynamic\cdecl^ --with-xslt-include&#x3D;C:\ProgramData\chocolatey\lib\libxslt\build\native\include^ --with-xslt-lib&#x3D;C:\ProgramData\chocolatey\lib\libxslt.redist\build\native\bin\v110\x64\Release\dynamic</code></pre><h2 id="安装-github-pagesPermalink"><a href="#安装-github-pagesPermalink" class="headerlink" title="安装 github-pagesPermalink"></a>安装 github-pagesPermalink</h2><ul><li>打开命令行界面安装 <a href="http://bundler.io/" target="_blank" rel="noopener">Bundler</a>: <code>gem install bundler</code></li><li>在你的博客根目录中创建名为 <code>Gemfile</code> 不带任何后缀名的文件</li><li>拷贝复制下面两行到文件中：</li></ul><pre><code class="hljs plain">source &#39;http:&#x2F;&#x2F;rubygems.org&#39;gem &#39;github-pages&#39;</code></pre><ul><li><strong>注意:</strong> 由于在使用的Ruby版本中使用SSL链接报错，所以这里我们使用不加密的链接</li><li>打开命令行界面，切换到你本地博客库的根目录，安装github-pages: <code>bundle install</code></li></ul><p>这个过程完成之后你应该就已经在系统上安装了github-pages，此时你可以通过 <code>jekyll s</code> 命令来在本地启动你的博客。<br>在启动的过程你会得到一个警告信息，提示你应该在 <code>Gemfile</code> 中包含 <code>gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?</code>， 但是我在文件中添加了这一行之后 <code>jekyll s</code> 就不能正常启动了，所以我就直接无视了这个警告。</p><p>将来github-pages的安装应该像安装博客一样的简单，但是目前 Nokogiri (<a href="https://github.com/sparklemotion/nokogiri/releases" target="_blank" rel="noopener">v1.6.8</a>) 的最新版并不是稳定版本，没有在github-pages中应用，故我们在Windows上还是要手动安装配置。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>githubpage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot2.0整合Activiti6.0问题梳理</title>
    <link href="/2019/05/23/Java/tools/SpringBoot2.0%E6%95%B4%E5%90%88Activiti6.0%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/"/>
    <url>/2019/05/23/Java/tools/SpringBoot2.0%E6%95%B4%E5%90%88Activiti6.0%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot2-0整合Activiti6-0问题梳理"><a href="#SpringBoot2-0整合Activiti6-0问题梳理" class="headerlink" title="SpringBoot2.0整合Activiti6.0问题梳理"></a>SpringBoot2.0整合Activiti6.0问题梳理</h1><p>SpringBoot整合Activiti很简单，我们可以通过springboot的starter来快速整合，只需要在pom文件中引入一下内容即可：</p><pre><code class="hljs plain">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;version&gt;6.0.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre><p>详细源码请见:<a href="https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act" target="_blank" rel="noopener">https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act</a></p><p>在Activiti6.0发布的时候，SpringBoot2.0还未发布，所以直接启动，会出现如下错误:</p><pre><code class="hljs plain">org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;requestMappingHandlerMapping&#39; defined in class path resource [org&#x2F;springframework&#x2F;boot&#x2F;autoconfigure&#x2F;web&#x2F;servlet&#x2F;WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxyat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1706) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:579) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:501) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:760) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:869) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:395) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]at pers.jarome.scs.act.ActApplication.main(ActApplication.java:17) [classes&#x2F;:na]Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxyat sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_181]at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_181]at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_181]at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_181]at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_181]at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_181]at java.lang.Class.createAnnotationData(Class.java:3521) ~[na:1.8.0_181]at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_181]at java.lang.Class.createAnnotationData(Class.java:3526) ~[na:1.8.0_181]at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_181]at java.lang.Class.getAnnotation(Class.java:3415) ~[na:1.8.0_181]at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258) ~[na:1.8.0_181]at java.lang.Class.isAnnotationPresent(Class.java:3425) ~[na:1.8.0_181]at org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation(AnnotatedElementUtils.java:573) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.isHandler(RequestMappingHandlerMapping.java:177) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:217) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:188) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:129) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1765) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]... 16 common frames omitted</code></pre><p>查阅网上资料得知是因为，Activiti6.0发布时，SpringBoot2.0 并没有发布，所以Activiti6.0仅支持1.2.6以上，2.0.0以下版本的SpringBoot。</p><p>通过调试（调试方式可以参照这一篇博客：<a href="http://hengyunabc.github.io/spring-boot-ArrayStoreException/" target="_blank" rel="noopener">深入Spring Boot：怎样排查 java.lang.ArrayStoreException</a>）查看源码很容易发现<code>SecurityAutoConfiguration</code>源码因为SpringBoot内部结构的变化，从而引起该类出现编译错误。</p><p>针对这一类情况有三种解决办法，分别如下：</p><ul><li>将springboot2.0换成1.X版本</li><li>在springboot启动类上排除<code>SecurityAutoConfiguration</code>类</li><li>修改SecurityAutoConfiguration源码，使其支持SpringBoot2.0</li></ul><p>对于上诉的三种方法，第一种最为简单，直接切换版本即可，但这样就不能使用SpringBoot2.0的特性，所以并不推荐；对于第三种方法，我认为难度较大，且具备极大的风险，并且Activiti的更高版本肯定也会修复，所以也不推荐该方法。</p><p>所以，最优的方法当属第二种，其具体操作如下：</p><pre><code class="hljs plain">@SpringBootApplication(exclude &#x3D; org.activiti.spring.boot.SecurityAutoConfiguration.class)public class ActApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ActApplication.class);    &#125;&#125;public class ActApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ActApplication.class);    &#125;&#125;</code></pre><p>但是，如果你的启动类中加入了<code>@EnableAutoConfiguration</code>注解，上面的方法就失效了，此时应该使用下面的方式：</p><pre><code class="hljs plain">@SpringBootApplication@EnableAutoConfiguration(exclude &#x3D;   org.activiti.spring.boot.SecurityAutoConfiguration.class)public class ActApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ActApplication.class);    &#125;&#125;</code></pre><p>详细源码请见:<a href="https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act" target="_blank" rel="noopener">https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础学习</title>
    <link href="/2019/05/23/normal/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/05/23/normal/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript基础学习"><a href="#JavaScript基础学习" class="headerlink" title="JavaScript基础学习"></a>JavaScript基础学习</h1><blockquote><p>JavaScript，简称JS，是一种高级的、解释执行的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式语言，它支持面向对象编程，以及函数式编程。它被世界上的绝大多数网站使用，也被世界主流浏览器支持。</p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在JavaScript中，对象和函数同样也是变量。</p><p>在JavaScript中，作用域可访问变量，对象，函数的集合。</p><p>对于变量而言，在JavaScript中有两个范围：全局和局部。在函数定义之外的声明的变量属全局变量，它在整个应用程序（也就是整个页面的js）都可以访问；反之，函数定义之内的声明的变量属局部变量，每当函数执行时，会创建变量，当函数执行完成后，都会销毁变量，并且该函数之外的内容无法访问该变量。</p><p>在JavaScript中同样也支持块作用域。</p><p>块作用域主要有for,if,with,tyr/catch,let,const。</p><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=o;i&lt;<span class="hljs-number">10</span>;i++)&#123;    <span class="hljs-built_in">console</span>.log(i);&#125;</code></pre><p>因为在for循环内部定义了i变量，顾i变量只能在for循环体内使用。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-literal">true</span>;<span class="hljs-keyword">if</span> (foo) &#123; <span class="hljs-keyword">var</span> bar = foo * <span class="hljs-number">2</span>; bar = something( bar );  <span class="hljs-built_in">console</span>.log( bar );&#125;</code></pre><p>bar变量仅声明在if的上下文中，因此在使用bar变量的时候，只能在if的方法体内使用。</p><p>with语句的作用是将代码的作用域设置到一个特定的作用域中，with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p><p>比如：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">// 单调乏味的重复 "obj"</span>obj.a = <span class="hljs-number">2</span>;obj.b = <span class="hljs-number">3</span>;obj.c = <span class="hljs-number">4</span>;<span class="hljs-comment">// 简单的快捷方式</span><span class="hljs-keyword">with</span> (obj) &#123; a = <span class="hljs-number">3</span>; b = <span class="hljs-number">4</span>; c = <span class="hljs-number">5</span>;&#125;</code></pre><p>try/catch相对比较容易理解，就是try与catch创建的{}代码块属于一个块作用域。</p><p>let是ES6提出的一个新的声明变量的关键字，let关键字可以将变量绑定在其所在的任意作用域中，通常是{}中，但这是一种隐式行为。</p><p>const，与let相似的，const也是ES6引入的一个新的声明变量的关键字，但其值是固定的，即常量。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>在JavaScript中共有6中基本数据类型：</p><ul><li>Undefined：表示一个对象未定义</li><li>Null：对象已经定义，但这个对象是空的，即空指针对象</li><li>Boolean：布尔类型，该类型只有两个值true、false</li><li>Number：数字类型，包括整数、浮点数，当然也支持十进制、八进制、十六进制表示。另外Number还有一个特殊的值，NaN，该值用于表示一个本来要返回数值的对象，但未返回数值的情况</li><li>String：字符串类型</li><li>Symbol：ES6新引入的数据类型，它表示一个独一无二的值，其作用是放置属性名冲突</li></ul><p>基础类型比较：</p><p>在JavaScript中，比较两个基础类型，JS会自动读数据进行隐式转换，比如:</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> b = <span class="hljs-literal">true</span>;<span class="hljs-built_in">console</span>.log(a == b);    <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(a === b);   <span class="hljs-comment">// false</span></code></pre><p>在JavaScript中， ==，双等号只进行值比较，如果两者数据不同意，则会自动转成同意的数据格式进行比较，当然如果转换格式失败，则会抛出异常。===，三等又称强等号，三等不仅会验证值是否一致，同时也是验证数据格式是否一致。</p><p>基础类型的变量存在在栈内存(Stack)中。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>JavaScript中的引用类型，即Object类型，对象类型，对象可以是一个类型的实例化对象，也可以是一组数据源，也可以是一个功能函数。在JavaScript中，Object又有许多子类型，如：Array，Date，RegExp，Function等。</p><p>RegExp类型，即正则表达式，在JavaScript中，它是用于描述字符模式的对象，正则表达式用于对字符模式匹配、检索替换，是操作字符串执行模式匹配的强大工具。其使用方式如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">//验证字符串是否全数字</span><span class="hljs-keyword">var</span> re = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">"^[0-9]*$"</span>);<span class="hljs-keyword">var</span> str = <span class="hljs-string">'123213123'</span>re.test(str)<span class="hljs-comment">//true</span></code></pre><p>对于RegExp支持的字符串方法有：search、match、replace、split。</p><p>Function，函数类型，每个函数都是Function类型的实例。</p><p>对于函数，其返回值比较特殊，如果其方法体内没有返回值，则返回一个undefined。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test3</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">return</span> ;&#125;<span class="hljs-keyword">var</span> t1 = test1();<span class="hljs-keyword">var</span> t2 = test2();<span class="hljs-keyword">var</span> t3 = test3();<span class="hljs-built_in">console</span>.log(t1);<span class="hljs-comment">//undefined</span><span class="hljs-built_in">console</span>.log(t2);<span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(t3);<span class="hljs-comment">//undefined</span></code></pre><p>对于引用类型的值是按照引用访问的。所以在比较引用类型的时候，双等号与三等号作用相同，比较的是两个对象的引用地址，引用地址相同，才会返回true。例如：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123;&#125;;    <span class="hljs-comment">// 新建一个空对象 obj1</span><span class="hljs-keyword">var</span> obj2 = &#123;&#125;;    <span class="hljs-comment">// 新建一个空对象 obj2</span><span class="hljs-built_in">console</span>.log(obj1 == obj2);    <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(obj1 === obj2);   <span class="hljs-comment">// false</span></code></pre><p>引用类型的值存在堆内存(Heap)中。</p><p>虽然引用类型保存在堆内存中，但是JavaScript不能直接操作堆内存，所以在JavaScript中，栈内存中保存了变量标识符和指向堆内存中该对象的指针，堆内存中保存了对象的内容。</p><h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><p>在JavaScript中，有两个较特殊的关键字，分别为typeof、instanceof。</p><p>typeof主要用来检测一个变量是否为基本的数据类型。</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// undefined</span>a = <span class="hljs-literal">null</span>;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// object</span>a = <span class="hljs-literal">true</span>;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// boolean</span>a = <span class="hljs-number">666</span>;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// number </span>a = <span class="hljs-string">"hello"</span>;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// string</span>a = <span class="hljs-built_in">Symbol</span>();<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// symbol</span>a = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// function</span>a = [];<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// object</span>a = &#123;&#125;;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// object</span>a = <span class="hljs-regexp">/aaa/g</span>;<span class="hljs-keyword">typeof</span> a;    <span class="hljs-comment">// object</span></code></pre><p>instanceof主要用来检测构造函数的prototype属性所指向的对象是否存在于另一个检测对象的原型链（关于原型链见下文）上。</p><pre><code class="hljs javascript">(&#123;&#125;) <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>              <span class="hljs-comment">// true</span>([]) <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>               <span class="hljs-comment">// true</span>(<span class="hljs-regexp">/aa/g</span>) <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>           <span class="hljs-comment">// true</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;) <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>  <span class="hljs-comment">// true</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud快速构建</title>
    <link href="/2019/05/22/Java/spring/SpringCloud%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA/"/>
    <url>/2019/05/22/Java/spring/SpringCloud%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud快速构建"><a href="#SpringCloud快速构建" class="headerlink" title="SpringCloud快速构建"></a>SpringCloud快速构建</h1><blockquote><p>SpringCloud是2014年底Spring团队基于SpringBoot开发的，推出的Java领域微服务架构完整解决方案。主要包括服务注册于发现、配置中心、全链路监控、API网关、熔断器等选型中立的开源组件。</p></blockquote><p>基础组件列表如下：</p><table><thead><tr><th>名称</th><th>功能</th><th>简介</th></tr></thead><tbody><tr><td>Eureka</td><td>注册中心</td><td>保证一致性与高可用</td></tr><tr><td>Consul</td><td>注册中心</td><td>保证强一致性</td></tr><tr><td>Zuul</td><td>网关</td><td>第一代网关</td></tr><tr><td>Gateway</td><td>网关</td><td>第二代网关</td></tr><tr><td>Ribbon</td><td>负载均衡</td><td>进程内负载均衡</td></tr><tr><td>Hystrix</td><td>熔断器</td><td>延迟、容错</td></tr><tr><td>Fegin</td><td>声明式HTTP客户端</td><td></td></tr><tr><td>Sleuth</td><td>链路追踪</td><td></td></tr><tr><td>Config</td><td>配置中心</td><td></td></tr><tr><td>Bus</td><td>总线</td><td></td></tr></tbody></table><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。</p><p>添加依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>在启动类中添加<code>@EnableEurekaServer</code>注解：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringCloudEurekaApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(SpringCloudEurekaApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><p>编写对应的配置文件：</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><span class="hljs-attr">application:</span><span class="hljs-attr">name:</span> <span class="hljs-string">spring-cloud-eureka</span><span class="hljs-attr">server:</span><span class="hljs-attr">port:</span> <span class="hljs-number">8000</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">client:</span><span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span><span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span><span class="hljs-attr">serviceUrl:</span><span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:$&#123;server.port&#125;/eureka/</span></code></pre><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p><p>引入依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>在启动类中添加<code>@EnableFeignClients</code>注解</p><pre><code class="hljs java"><span class="hljs-meta">@EnableFeignClients</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<span class="hljs-keyword">new</span> SpringApplicationBuilder(Application<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">web</span>(<span class="hljs-title">true</span>).<span class="hljs-title">run</span>(<span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><p>创建一个Feign的客户端接口定义。使用<code>@FeignClient</code>注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定<code>eureka-client</code>服务的<code>/dc</code>接口的例子：</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(<span class="hljs-string">"eureka-client"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DcClient</span> </span>&#123;    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">"/dc"</span>)    <span class="hljs-function">String <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>;&#125;</code></pre><p><code>@FeignClient</code>注解：</p><ul><li><p>name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现</p></li><li><p>url: url一般用于调试，可以手动指定@FeignClient调用的地址</p></li><li><p>decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException</p></li><li><p>configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract</p></li><li><p>fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口</p></li><li><p>fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码</p></li><li><p>path: 定义当前FeignClient的统一前缀</p></li></ul><h2 id="Hystix"><a href="#Hystix" class="headerlink" title="Hystix"></a>Hystix</h2><p><code>Hystix</code>是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。</p><p>添加依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>启动类上增加Hystrix的注解：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableDiscoveryClient</span><span class="hljs-meta">@EnableCircuitBreaker</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixRibbonApp</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(HystrixRibbonApp<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;        <span class="hljs-meta">@Bean</span>    <span class="hljs-meta">@LoadBalanced</span>    <span class="hljs-function">RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();    &#125;&#125;</code></pre><p>修改代码逻辑，在需要熔断的方法上增加@HystrixCommand注解，当调用有问题的时候就会使用fallbackMethod参数指定的方法进行服务降级：</p><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    HystrixRibbonService helloService;        <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">"/hi"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> helloService.helloService(<span class="hljs-string">"姓名"</span>);    &#125;&#125;<span class="hljs-meta">@Service</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixRibbonService</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SERVICE_NAME = <span class="hljs-string">"EUREKACLIENT"</span>;        <span class="hljs-meta">@Autowired</span>    RestTemplate restTemplate;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancerClient;    <span class="hljs-meta">@HystrixCommand</span>(fallbackMethod = <span class="hljs-string">"helloServiceFallBack"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloService</span><span class="hljs-params">(String name)</span> </span>&#123;        ServiceInstance serviceInstance = <span class="hljs-keyword">this</span>.loadBalancerClient.choose(SERVICE_NAME);        System.out.println(<span class="hljs-string">"服务主机："</span> + serviceInstance.getHost());        System.out.println(<span class="hljs-string">"服务端口："</span> + serviceInstance.getPort());                <span class="hljs-comment">//  通过服务名来访问</span>        <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">"http://"</span> + SERVICE_NAME + <span class="hljs-string">"/hello?name="</span>+name,String<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unused"</span>)    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">helloServiceFallBack</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"这个是失败的信息！"</span>;    &#125;&#125;</code></pre><p>在<code>Feign</code>中同样可以使用<code>Hystix</code>，在<code>Feign</code>中指定<code>fallback</code>，示例如下：</p><pre><code class="hljs java"><span class="hljs-meta">@FeignClient</span>(value=<span class="hljs-string">"EUREKACLIENT"</span>, fallback = HystrixFeignServiceFallback<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class"><span class="hljs-title">public</span> <span class="hljs-title">interface</span> <span class="hljs-title">HystrixFeignService</span> </span>&#123;    <span class="hljs-meta">@RequestMapping</span>(value = <span class="hljs-string">"/hello"</span>,method = RequestMethod.GET)     <span class="hljs-function">String <span class="hljs-title">sayHiUseFeign</span><span class="hljs-params">(@RequestParam(value = <span class="hljs-string">"name"</span>)</span> String name)</span>;&#125;<span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HystrixFeignServiceFallback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HystrixFeignService</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHiUseFeign</span><span class="hljs-params">(String name)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"feign调用错误！"</span>;    &#125;&#125;</code></pre><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>在说Zuul之前，应先理解API Gateway(API网关)的概念，API网关即给用户规定一个统一的入口，接收到用户请求后，网关在内部会分发到各个对应的服务服务上。API网关的好处：</p><ul><li>简化客户端调用复杂度</li><li>数据裁剪以及聚合</li><li>多渠道支持</li><li>遗留系统的微服务化改造</li></ul><p>Spring Cloud Zuul路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p><p>引用依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置文件:</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><span class="hljs-attr">application:</span><span class="hljs-attr">name:</span> <span class="hljs-string">gateway-service-zuul</span><span class="hljs-attr">server:</span><span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><span class="hljs-comment">#这里的配置表示，访问/goo/** 直接重定向到http://www.google.com</span><span class="hljs-attr">zuul:</span><span class="hljs-attr">routes:</span><span class="hljs-attr">baidu:</span><span class="hljs-attr">path:</span> <span class="hljs-string">/goo/**</span><span class="hljs-attr">url:</span> <span class="hljs-string">http://www.google.com</span></code></pre><p>启动类：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableZuulProxy</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayServiceZuulApplication</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;SpringApplication.run(GatewayServiceZuulApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;&#125;&#125;</code></pre><h3 id="网关服务化"><a href="#网关服务化" class="headerlink" title="网关服务化"></a>网关服务化</h3><p>添加eureka依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置文件：</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><span class="hljs-attr">application:</span><span class="hljs-attr">name:</span> <span class="hljs-string">gateway-service-zuul</span><span class="hljs-attr">server:</span><span class="hljs-attr">port:</span> <span class="hljs-number">8888</span><span class="hljs-attr">zuul:</span><span class="hljs-attr">routes:</span><span class="hljs-attr">server-a:</span><span class="hljs-attr">path:</span> <span class="hljs-string">/goo/**</span><span class="hljs-attr">serviceId:</span> <span class="hljs-string">server-a</span><span class="hljs-attr">eureka:</span><span class="hljs-attr">client:</span><span class="hljs-attr">serviceUrl:</span><span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8000/eureka/</span></code></pre><p>其中<code>server-a</code>为<code>eureka</code>中的服务。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><p>Sleuth是Spring Cloud的组成部分之一，为SpringCloud应用实现了一种分布式追踪解决方案，其兼容了Zipkin, HTrace和log-based追踪</p><p>几个基本术语：</p><ul><li>Span：基本工作单元，发送一个远程调度任务 就会产生一个Span，Span是一个64位ID唯一标识的，Trace是用另一个64位ID唯一标识的，Span还有其他数据信息，比如摘要、时间戳事件、Span的ID、以及进度ID。</li><li>Trace：一系列Span组成的一个树状结构。请求一个微服务系统的API接口，这个API接口，需要调用多个微服务，调用每个微服务都会产生一个新的Span，所有由这个请求产生的Span组成了这个Trace。</li><li>Annotation：用来及时记录一个事件的，一些核心注解用来定义一个请求的开始和结束 。这些注解包括以下：<ul><li>cs - Client Sent -客户端发送一个请求，这个注解描述了这个Span的开始</li><li>sr-Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络传输的时间。</li><li>ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户端)，如果ss的时间戳减去sr时间戳，就可以得到服务器请求的时间。</li><li>cr - Client Received （客户端接收响应）-此时Span的结束，如果cr的时间戳减去cs时间戳便可以得到整个请求所消耗的时间。</li></ul></li></ul><h3 id="Spring-Cloud-Sleuth和Zipkin分布式链路跟踪"><a href="#Spring-Cloud-Sleuth和Zipkin分布式链路跟踪" class="headerlink" title="Spring Cloud Sleuth和Zipkin分布式链路跟踪"></a>Spring Cloud Sleuth和Zipkin分布式链路跟踪</h3><h4 id="Zipkin服务端构建"><a href="#Zipkin服务端构建" class="headerlink" title="Zipkin服务端构建"></a>Zipkin服务端构建</h4><p>Zipkin 是一个开放源代码分布式的跟踪系统，由Twitter公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。</p><p>每个服务向zipkin报告计时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。</p><p>Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。接下来的测试为方便直接采用In-Memory方式进行存储，生产推荐Elasticsearch。</p><p>首先在项目中添加依赖</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.zipkin.java<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span></code></pre><p>编写对应的启动类，使用了<code>@EnableZipkinServer</code>注解，启用Zipkin服务。</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><span class="hljs-meta">@EnableEurekaClient</span><span class="hljs-meta">@EnableZipkinServer</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZipkinApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(ZipkinApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>修改配置文件</p><pre><code class="hljs yaml"><span class="hljs-attr">eureka:</span>  <span class="hljs-attr">client:</span>    <span class="hljs-attr">serviceUrl:</span>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://127.0.0.1:8761/eureka/</span><span class="hljs-attr">server:</span>  <span class="hljs-attr">port:</span> <span class="hljs-number">9000</span><span class="hljs-attr">spring:</span>  <span class="hljs-attr">application:</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">zipkin-server</span></code></pre><p>配置完成后依次启动示例项目：<code>spring-cloud-eureka</code>、<code>zipkin-server</code>项目。刚问地址:<code>http://localhost:9000/zipkin/</code>可以看到Zipkin后台页面</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/tracing3.png" srcset="/img/loading.gif" alt=""></p><h3 id="客户端添加zipkin支持"><a href="#客户端添加zipkin支持" class="headerlink" title="客户端添加zipkin支持"></a>客户端添加zipkin支持</h3><p>在项目中添加如下依赖：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>配置文件中添加如下代码：</p><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <span class="hljs-attr">zipkin:</span>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://localhost:9000</span>  <span class="hljs-attr">sleuth:</span>    <span class="hljs-attr">sampler:</span>      <span class="hljs-attr">percentage:</span> <span class="hljs-number">1.0</span></code></pre><p>spring.zipkin.base-url指定了Zipkin服务器的地址，spring.sleuth.sampler.percentage将采样比例设置为1.0，也就是全部都需要。</p><p>Spring应用在监测到Java依赖包中有sleuth和zipkin后，会自动在RestTemplate的调用过程中向HTTP请求注入追踪信息，并向Zipkin Server发送这些信息。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网关</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringCloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitLab CI/CD 介绍和使用</title>
    <link href="/2019/03/26/normal/GitLabCI_CD%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2019/03/26/normal/GitLabCI_CD%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="GitLab-CI-CD-介绍和使用"><a href="#GitLab-CI-CD-介绍和使用" class="headerlink" title="GitLab CI/CD 介绍和使用"></a>GitLab CI/CD 介绍和使用</h1><h2 id="一、持续集成介绍"><a href="#一、持续集成介绍" class="headerlink" title="一、持续集成介绍"></a>一、持续集成介绍</h2><blockquote><p>持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。—— Martin Fowler</p></blockquote><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h3><ul><li><strong>持续集成</strong>(<code>Continuous Integration</code>)：<strong>频繁地(一天多次)将代码集成到主干。</strong>让产品可以快速迭代，同时还能保持高质量。它的核心措施是，代码集成到主干之前，必须通过自动化测试。只要有一个测试用例失败，就不能集成。“持续集成并不能消除 Bug，而是让它们非常容易发现和改正。”</li><li><strong>持续交付</strong>(<code>Continuous Delivery</code>)：<strong>频繁地将软件的新版本，交付给质量团队或者用户，以供评审。</strong>如果评审通过，代码就进入生产阶段。持续交付可以看作持续集成的下一步。它强调的是，不管怎么更新，软件是随时随地可以交付的。</li><li><strong>持续部署</strong>(<code>continuous Deployment</code>)：<strong>代码通过评审以后，自动部署到生产环境。</strong>是持续部署是持续交付的下一步，持续部署的目标是，代码在任何时刻都是可部署的，可以进入生产阶段。</li></ul><h3 id="2-持续集成的好处"><a href="#2-持续集成的好处" class="headerlink" title="2 持续集成的好处"></a>2 持续集成的好处</h3><ul><li><strong>自动化构建且状态对每个人可见</strong>。可以使用<code>Maven</code>、<code>Gradle</code>等来实现自动化构建，可以在构建过程中实现自动化测试（前提是有写单元测试用例）。集成服务器在持续集成过程中发现问题可以及时发送警告给相关的干系人。</li><li><strong>解放了重复性劳动。</strong>自动化部署工作可以解放集成、测试、部署等重复性劳动，而机器集成的频率明显比手工高很多。</li><li><strong>更快地发现和修复问题。</strong>持续集成更早的获取变更，更早的进入测试，更早的发现问题，解决问题的成本显著下降。</li><li><strong>更快的交付成果。</strong>更早发现错误减少解决错误所需的工作量。集成服务器在构建环节发现错误可以及时通知开发人员修复。集成服务器在部署环节发现错误可以回退到上一版本，服务器始终有一个可用的版本。</li><li><strong>减少手工的错误。</strong>在重复性动作上，人容易犯错，而机器犯错的几率几乎为零。</li><li><strong>减少了等待时间。</strong>缩短了从开发、集成、测试、部署各个环节的时间，从而也就缩短了中间可以出现的等待时机。持续集成，意味着开发、集成、测试、部署也得以持续。</li><li><strong>更高的产品质量。</strong>集成服务器往往提供代码质量检测等功能，对不规范或有错误的地方会进行标致，也可以设置邮件和短信等进行警告。</li></ul><h3 id="3-常用持续集成工具"><a href="#3-常用持续集成工具" class="headerlink" title="3 常用持续集成工具"></a>3 常用持续集成工具</h3><ul><li><a href="https://jenkins.io/" target="_blank" rel="noopener">Jenkins</a></li><li><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">GitLab CI</a></li><li><a href="https://www.jetbrains.com/teamcity/" target="_blank" rel="noopener">TeamCity</a></li><li><a href="https://www.travis-ci.org/" target="_blank" rel="noopener">Travis CI</a></li><li><a href="https://www.atlassian.com/software/bamboo" target="_blank" rel="noopener">Bamboo</a></li><li><a href="https://circleci.com/" target="_blank" rel="noopener">CircleCI</a></li><li>…</li></ul><h2 id="二、Gitlab-持续集成"><a href="#二、Gitlab-持续集成" class="headerlink" title="二、Gitlab 持续集成"></a>二、Gitlab 持续集成</h2><p><img src="https://docs.gitlab.com/ee/ci/img/cicd_pipeline_infograph.png" srcset="/img/loading.gif" alt="GitLab CI/CD"></p><h3 id="1-概念介绍"><a href="#1-概念介绍" class="headerlink" title="1 概念介绍"></a>1 概念介绍</h3><h4 id="1-GitLab"><a href="#1-GitLab" class="headerlink" title="(1) GitLab"></a>(1) GitLab</h4><p><a href="https://about.gitlab.com/" target="_blank" rel="noopener">GitLab</a> 是一个利用<code>Ruby on Rails</code>开发的开源应用程序，实现一个自托管的 Git 项目仓库，可通过 Web 界面进行访问公开的或者私人项目。它拥有与<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>类似的功能，能够浏览源代码，管理缺陷和注释。可以管理团队对仓库的访问，它非常易于浏览提交过的版本并提供一个文件历史库。</p><h4 id="2-GitLab-CI-CD"><a href="#2-GitLab-CI-CD" class="headerlink" title="(2) GitLab CI/CD"></a>(2) GitLab CI/CD</h4><p><a href="https://docs.gitlab.com/ee/ci/README.html" target="_blank" rel="noopener">GitLab CI/CD</a> 是<code>GitLab Continuous Integration</code>（Gitlab持续集成）的简称。GitLab 自<code>GitLab 8.0</code>开始提供了持续集成的功能，且对所有项目默认开启。只要在项目仓库的根目录添加<code>.gitlab-ci.yml</code>文件，并且配置了Runner（运行器），那么每一次<code>push</code>或者合并请求（<code>Merge Request</code>）都会触发<a href="https://docs.gitlab.com/ce/ci/pipelines.html" target="_blank" rel="noopener">CI Pipeline</a>。</p><h4 id="3-GitLab-Runner"><a href="#3-GitLab-Runner" class="headerlink" title="(3) GitLab Runner"></a>(3) GitLab Runner</h4><p><a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">GitLab Runner</a> <code>GitLab Runner</code>是一个开源项目，可以运行在 GNU / Linux，macOS 和 Windows 操作系统上。每次<code>push</code>的时候 GitLab CI 会根据<code>.gitlab-ci.yml</code>配置文件运行你流水线（<code>Pipeline</code>）中各个阶段的任务（<code>Job</code>），并将结果发送回 GitLab。GitLab Runner 是基于 Gitlab CI 的 API 进行构建的相互隔离的机器（或虚拟机）。GitLab Runner 不需要和 Gitlab 安装在同一台机器上，且考虑到 GitLab Runner 的资源消耗问题和安全问题，也不建议这两者安装在同一台机器上。</p><p>Gitlab Runner 分为三种：</p><ul><li>共享Runner(<code>Shared runners</code>)</li><li>专享Runner(<code>Specific runners</code>)</li><li>分组Runner(<code>Group Runners</code>)</li></ul><h4 id="4-Pipelines"><a href="#4-Pipelines" class="headerlink" title="(4) Pipelines"></a>(4) Pipelines</h4><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html" target="_blank" rel="noopener">Pipelines</a> 中文称为流水线，是分阶段执行的构建任务。如：安装依赖、运行测试、打包、部署开发服务器、部署生产服务器等流程。每一次<code>push</code>或者<code>Merge Request</code>都会触发生成一条新的Pipeline。</p><p>下面是流水线示例图：</p><p><img src="https://docs.gitlab.com/ce/ci/img/pipelines_index.png" srcset="/img/loading.gif" alt="Pipeline Status"></p><h4 id="5-Stages"><a href="#5-Stages" class="headerlink" title="(5) Stages"></a>(5) Stages</h4><p><a href="https://docs.gitlab.com/ce/ci/yaml/README.html#stages" target="_blank" rel="noopener">Stages</a> 表示构建阶段，可以理解为上面所说“安装依赖”、“运行测试”等环节的流程。我们可以在一次 Pipeline 中定义多个 Stages，这些 Stages 会有以下特点：</p><ul><li>所有 Stages 会按照顺序运行，即当一个 Stage 完成后，下一个 Stage 才会开始（当然可以在<code>.gitlab-ci.yml</code>文件中配置上一阶段失败时下一阶段也执行）</li><li>只有当所有 Stages 完成后，该构建任务 (Pipeline) 才会成功</li><li>如果任何一个 Stage 失败，那么后面的 Stages 不会执行，该构建任务 (Pipeline) 失败</li></ul><p>下面是一个流水线内的阶段任务示例图：</p><p><img src="https://docs.gitlab.com/ce/ci/img/pipelines.png" srcset="/img/loading.gif" alt="Job Status"></p><h4 id="6-Jobs"><a href="#6-Jobs" class="headerlink" title="(6) Jobs"></a>(6) Jobs</h4><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html#jobs" target="_blank" rel="noopener">Jobs</a> 表示构建的作业（或称之为任务），表示某个 Stage 里面执行的具体任务。我们可以在 Stages 里面定义多个 Jobs，这些 Jobs 会有以下特点：</p><ul><li>相同 Stage 中的 Jobs 无执行顺序要求，会并行执行</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 才会成功</li><li>如果任何一个 Job 失败，那么该 Stage 失败，即该构建任务 (Pipeline) 也失败（可以在<code>.gitlab-ci.yml</code>文件中配置允许某 Job 可以失败，也算该 Stage 成功）</li></ul><h4 id="7-gitlab-ci-yml"><a href="#7-gitlab-ci-yml" class="headerlink" title="(7) .gitlab-ci.yml"></a>(7) .gitlab-ci.yml</h4><p>GitLab 中默认开启了 Gitlab CI/CD 的支持，且使用<a href="http://yaml.org/" target="_blank" rel="noopener">YAML</a>文件<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#examples" target="_blank" rel="noopener">.gitlab-ci.yml</a>来管理项目构建配置。该文件需要存放于项目仓库的根目录（默认路径，可在 GitLab 中修改），它定义该项目的 CI/CD 如何配置。所以，我们只需要在<code>.gitlab-ci.yml</code>配置文件中定义流水线的各个阶段，以及各个阶段中的若干作业（任务）即可。</p><p>下面是<code>.gitlab-ci.yml</code>文件的一个简单的<code>Hello World</code>示例：</p><pre><code class="hljs yml"><span class="hljs-comment"># 定义 test 和 package 两个 Stages</span><span class="hljs-attr">stages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">package</span><span class="hljs-comment"># 定义 package 阶段的一个 job</span><span class="hljs-attr">package-job:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">package</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"Hello, package-job"</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"I am in package stage"</span><span class="hljs-comment"># 定义 test 阶段的一个 job</span><span class="hljs-attr">test-job:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"Hello, test-job"</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">"I am in test stage"</span></code></pre><p>以上配置中，用 stages 关键字来定义 Pipeline 中的各个构建阶段，然后用一些非关键字来定义 jobs。每个 job 中可以可以再用 stage 关键字来指定该 job 对应哪个 stage。job 里面的<code>script</code>关键字是每个 job 中必须要包含的，它表示每个 job 要执行的命令。</p><blockquote><p><strong>注</strong>：猜猜上面例子的运行结果？</p></blockquote><h4 id="8-Badges"><a href="#8-Badges" class="headerlink" title="(8) Badges"></a>(8) Badges</h4><p><a href="https://docs.gitlab.com/ce/ci/pipelines.html#badges" target="_blank" rel="noopener">Badges</a> 即：<strong>徽章</strong>，当 Pipelines 执行过程中或者执行完成时会生成徽章，你可以将这些徽章加入到你的<code>README.md</code>文件中，便于从仓库主页看到最新的构建状态。</p><p>徽章的链接形如下：</p><pre><code class="hljs bash">http://example.gitlab.com/namespace/project/badges/branch/build.svg</code></pre><p>我们用 GitLab 项目的徽章作为例子，效果如下：</p><p><img src="https://gitlab.com/gitlab-org/gitlab-ce/badges/master/build.svg" srcset="/img/loading.gif" alt="Gitlab build badges"> <img src="https://gitlab.com/gitlab-org/gitlab-ce/badges/master/coverage.svg?job=coverage" srcset="/img/loading.gif" alt="Gitlab coverage badges"></p><h3 id="2-安装-GitLab-Runner"><a href="#2-安装-GitLab-Runner" class="headerlink" title="2 安装 GitLab Runner"></a>2 安装 GitLab Runner</h3><p><a href="https://docs.gitlab.com/runner/install/index.html" target="_blank" rel="noopener">这里</a>有 GitLab Runner安装相关的资源和文档可供大家参考。以下仅以咱们公司常用的<code>Centos</code>为例来做安装说明。</p><h4 id="1-在线安装"><a href="#1-在线安装" class="headerlink" title="(1) 在线安装"></a>(1) 在线安装</h4><pre><code class="hljs bash"><span class="hljs-comment"># 添加官方的repo.</span>curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh | sudo bash<span class="hljs-comment"># yum 安装Gtilab Runner.</span>sudo yum install gitlab-runner</code></pre><h4 id="2-离线安装"><a href="#2-离线安装" class="headerlink" title="(2) 离线安装"></a>(2) 离线安装</h4><pre><code class="hljs bash"><span class="hljs-comment"># 安装Git</span>sudo yum –y install git<span class="hljs-comment"># rpm离线安装事先下载好的 Gitlab Runner rpm包.</span>rpm -ivh gitlab-runner-10.5.0-1.x86_64.rpm</code></pre><blockquote><p><strong>注</strong>：Gitlab Runner 依赖了<code>Git</code>，所以，离线安装 Gitlab Runner 之前得首先安装Git，离线安装包可以从<a href="https://packages.gitlab.com/runner/gitlab-runner" target="_blank" rel="noopener">这里</a>下载。</p></blockquote><h3 id="3-注册-Gitlab-Runner"><a href="#3-注册-Gitlab-Runner" class="headerlink" title="3 注册 Gitlab Runner"></a>3 注册 Gitlab Runner</h3><p>安装了 GitLab Runner 之后,就可以为 GitLab 中的仓库<a href="https://docs.gitlab.com/runner/register/index.html" target="_blank" rel="noopener">注册一个 Runner</a>，注册的交互式命令如下：</p><pre><code class="hljs bash">sudo gitlab-runner register</code></pre><p>命令的交互式的过程如下：</p><pre><code class="hljs bash"><span class="hljs-comment"># 输入注册命令</span>sudo gitlab-runner register<span class="hljs-comment"># 输入 GitLab 网站地址</span>Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )http://gitlab.thunisoft.com/<span class="hljs-comment"># 你项目仓库的token，token可以在 Settings -&gt; CI/CD -&gt; Runners settings 中找到.</span>Please enter the gitlab-ci token <span class="hljs-keyword">for</span> this runnerxxx<span class="hljs-comment"># 输入描述这个 runner 的名称</span>Please enter the gitlab-ci description <span class="hljs-keyword">for</span> this runner[hostame] my-runner<span class="hljs-comment"># 输入 runner 的标签</span>Please enter the gitlab-ci tags <span class="hljs-keyword">for</span> this runner (comma separated):my-tag,another-tag<span class="hljs-comment"># 输入 runner 的执行器.</span>Please enter the executor: ssh, docker+machine, docker-ssh+machine, kubernetes, docker, parallels, virtualbox, docker-ssh, shell:shell</code></pre><p>以上流程注册成功之后，就可以在你的项目仓库中 <code>Settings</code> -&gt; <code>CI/CD</code> -&gt; <code>Runners settings</code> 看到这个 Runner 了。</p><h3 id="4-Gitlab-Runner-常用命令汇总"><a href="#4-Gitlab-Runner-常用命令汇总" class="headerlink" title="4 Gitlab Runner 常用命令汇总"></a>4 Gitlab Runner 常用命令汇总</h3><p>下面的表格中列出了一些常用的<a href="https://docs.gitlab.com/runner/commands/README.html#gitlab-runner-list" target="_blank" rel="noopener">Gitlab Runner命令</a>，以供参考：</p><table><thead><tr><th>命令</th><th align="left">描述</th></tr></thead><tbody><tr><td>gitlab-runner run</td><td align="left">运行一个runner服务</td></tr><tr><td>gitlab-runner register</td><td align="left">注册一个新的runner</td></tr><tr><td>gitlab-runner start</td><td align="left">启动服务</td></tr><tr><td>gitlab-runner stop</td><td align="left">关闭服务</td></tr><tr><td>gitlab-runner restart</td><td align="left">重启服务</td></tr><tr><td>gitlab-runner status</td><td align="left">查看各个runner的状态</td></tr><tr><td>gitlab-runner unregister</td><td align="left">注销掉某个runner</td></tr><tr><td>gitlab-runner list</td><td align="left">显示所有运行着的runner</td></tr><tr><td>gitlab-runner verify</td><td align="left">检查已注册的运行程序是否可以连接到GitLab，但它不验证GitLab Runner服务是否正在使用运行程序。</td></tr></tbody></table><h2 id="三、一个Web项目-CI-CD-简单实战"><a href="#三、一个Web项目-CI-CD-简单实战" class="headerlink" title="三、一个Web项目 CI/CD 简单实战"></a>三、一个Web项目 CI/CD 简单实战</h2><p>接下来，我用一个实际项目来演示 GitLab CI/CD 的配置和使用，其中主要包括：编译测试、项目打包、部署服务、Sonar手动检查、Sonar定时检查五个阶段。</p><p>为了照顾到很多没有使用<code>SpringBoot</code>开发的“老”项目，这里我用一个传统的 Java web 项目（<code>Artery5</code>框架）和<code>Tomcat</code>（我 Runner 的演示环境不用安装,所以用它为例）来作为示例，并用来展示常用配置的使用。当我每次<code>push</code>代码或者<code>Merge Request</code>时，都会生成一条流水线，且会自动执行我们上面所说的一些阶段，而Sonar手动检查我们设置为手动操作，且再额外配置Sonar定时检查的任务。</p><blockquote><p><strong>注</strong>：这里要知道，作为示例选用的Web框架和中间件关系不大，构建配置的大体流程和思想是共通的，只是具体脚本或者命令有些差异而已。</p></blockquote><pre><code class="hljs yml"><span class="hljs-comment"># 定义stages</span><span class="hljs-attr">stages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">test</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">install</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">run</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">sonar</span><span class="hljs-attr">variables:</span>  <span class="hljs-attr">XSBS_PACKAGE_DIR:</span> <span class="hljs-string">'/home/gitlab-runner/packages/xsbs/'</span>  <span class="hljs-attr">SERVER_HOME_DIR:</span> <span class="hljs-string">'/home/gitlab-runner/tomcat/xsbs-dev-tomcat/'</span><span class="hljs-comment">###################### 构建编译和单元测试的job. #######################</span><span class="hljs-string">编译测试任务:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">branches</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">xsbs</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">clean</span> <span class="hljs-string">test</span><span class="hljs-comment">###################### Maven安装得到war包的job. #######################</span><span class="hljs-string">打包任务:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">install</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">develop</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">xsbs/</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">install</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">'准备将最新的war包复制、保存到某个目录里面供后续使用.'</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">$XSBS_PACKAGE_DIR/*.war</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cp</span> <span class="hljs-string">target/*.war</span> <span class="hljs-string">$XSBS_PACKAGE_DIR/xsbs.war</span><span class="hljs-comment">####################### 部署运行war包的job. #######################</span><span class="hljs-string">部署运行任务:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">run</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">develop</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">'准备部署和运行war包！(为了方便部署到了Tomcat中运行)'</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">$SERVER_HOME_DIR</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">sh</span> <span class="hljs-string">bin/shutdown.sh</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">rm</span> <span class="hljs-string">-rf</span> <span class="hljs-string">webapps/xsbs.war</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cp</span> <span class="hljs-string">$XSBS_PACKAGE_DIR/xsbs.war</span> <span class="hljs-string">$SERVER_HOME_DIR/webapps/xsbs.war</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">nohup</span> <span class="hljs-string">sh</span> <span class="hljs-string">./bin/startup.sh</span> <span class="hljs-string">&gt;</span> <span class="hljs-string">logs/xsbs_nohup.log</span> <span class="hljs-number">2</span><span class="hljs-string">&gt;&amp;1</span> <span class="hljs-string">&amp;</span><span class="hljs-comment">###################### Sonar手动构建的job. #######################</span><span class="hljs-string">Sonar手动检查:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">sonar</span>  <span class="hljs-attr">when:</span> <span class="hljs-string">manual</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">develop</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">'准备对项目代码做sonar的质量检查！'</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">xsbs</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">compile</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">mvn</span> <span class="hljs-string">sonar:sonar</span> <span class="hljs-string">-Dsonar.host.url=http://172.16.34.102:9000</span> <span class="hljs-string">-Dsonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34</span><span class="hljs-comment">###################### Sonar每晚定时构建的job. #######################</span><span class="hljs-string">Sonar定时检查:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">sonar</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">schedules</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">'开始定时对项目代码做sonar的质量检查！'</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">xsbs</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">mvn</span> <span class="hljs-string">compile</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">mvn</span> <span class="hljs-string">sonar:sonar</span> <span class="hljs-string">-D</span> <span class="hljs-string">sonar.host.url=http://172.16.34.102:9000</span> <span class="hljs-string">-D</span> <span class="hljs-string">sonar.login=497a0e0e2fc07f64c4b54edc17bb47dfa251ba34</span></code></pre><h2 id="四、Gitlab-CI-CD-yaml-常用配置介绍"><a href="#四、Gitlab-CI-CD-yaml-常用配置介绍" class="headerlink" title="四、Gitlab CI/CD yaml 常用配置介绍"></a>四、Gitlab CI/CD yaml 常用配置介绍</h2><p>开始构建之前<code>.gitlab-ci.yml</code>文件定义了一系列带有约束说明的任务。这些任务都是以任务名开始并且至少要包含script部分，<code>.gitlab-ci.yml</code>允许指定无限量 jobs。每个 jobs 必须有一个唯一的名字，且名字不能是下面列出的保留字段：</p><ul><li><code>image</code></li><li><code>services</code></li><li><code>stages</code></li><li><code>types</code></li><li><code>before_script</code></li><li><code>after_script</code></li><li><code>variables</code></li><li><code>cache</code></li></ul><p>job由一列参数来定义 jobs 的行为：</p><table><thead><tr><th>Keyword</th><th>Required</th><th>Description</th></tr></thead><tbody><tr><td>script</td><td>yes</td><td>Runner执行的命令或脚本</td></tr><tr><td>extends</td><td>no</td><td>定义此作业将继承的配置条目</td></tr><tr><td>image</td><td>no</td><td>所使用的docker镜像，查阅<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener">使用docker镜像</a></td></tr><tr><td>services</td><td>no</td><td>所使用的docker服务，查阅<a href="https://docs.gitlab.com/ce/ci/docker/using_docker_images.html#define-image-and-services-from-gitlab-ciyml" target="_blank" rel="noopener">使用docker镜像</a></td></tr><tr><td>stage</td><td>no</td><td>定义job stage（默认：<code>test</code>）</td></tr><tr><td>type</td><td>no</td><td><code>stage</code>的别名（已弃用）</td></tr><tr><td>variables</td><td>no</td><td>定义job级别的变量</td></tr><tr><td>only</td><td>no</td><td>定义一列git分支，并为其创建job</td></tr><tr><td>except</td><td>no</td><td>定义一列git分支，不创建job</td></tr><tr><td>tags</td><td>no</td><td>定义一列tags，用来指定选择哪个Runner（同时Runner也要设置tags）</td></tr><tr><td>allow_failure</td><td>no</td><td>允许job失败。失败的job不影响commit状态</td></tr><tr><td>when</td><td>no</td><td>定义何时开始job。可以是<code>on_success</code>，<code>on_failure</code>，<code>always</code>或者<code>manual</code></td></tr><tr><td>dependencies</td><td>no</td><td>定义job依赖关系，这样他们就可以互相传递artifacts</td></tr><tr><td>cache</td><td>no</td><td>定义应在后续运行之间缓存的文件列表</td></tr><tr><td>before_script</td><td>no</td><td>重写一组在作业前执行的命令</td></tr><tr><td>after_script</td><td>no</td><td>重写一组在作业后执行的命令</td></tr><tr><td>environment</td><td>no</td><td>定义此作业完成部署的环境名称</td></tr><tr><td>coverage</td><td>no</td><td>定义给定作业的代码覆盖率设置</td></tr><tr><td>etry</td><td>no</td><td>定义在发生故障时可以自动重试作业的时间和次数</td></tr><tr><td>parallel</td><td>no</td><td>定义应并行运行的作业实例数</td></tr></tbody></table><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><blockquote><p>是在 GitLab 11.3 中引入的。</p></blockquote><p><code>extends</code>定义了一个使用<code>extends</code>的作业将继承的条目名称。它是使用<a href="https://docs.gitlab.com/ee/ci/yaml/README.html#anchors" target="_blank" rel="noopener">YAML锚点</a>的替代方案，并且更加灵活和可读：</p><pre><code class="hljs yml"><span class="hljs-string">.tests:</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">rake</span> <span class="hljs-string">test</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">only:</span>    <span class="hljs-attr">refs:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">branches</span><span class="hljs-attr">rspec:</span>  <span class="hljs-attr">extends:</span> <span class="hljs-string">.tests</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">rake</span> <span class="hljs-string">rspec</span>  <span class="hljs-attr">only:</span>    <span class="hljs-attr">variables:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">$RSPEC</span></code></pre><p>在上面的示例中，<code>rspec</code>作业继承自<code>.tests</code>模板作业。 GitLab 将根据键执行反向深度合并。 GitLab将：</p><ul><li>将<code>rspec</code>内容以递归方式合并到<code>.tests</code>中。</li><li>不合并键的值。</li></ul><p>这实际生成的是以下<code>rspec</code>作业：</p><pre><code class="hljs yml"><span class="hljs-attr">rspec:</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">rake</span> <span class="hljs-string">rspec</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">only:</span>    <span class="hljs-attr">refs:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">branches</span>    <span class="hljs-attr">variables:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">$RSPEC</span></code></pre><blockquote><p><strong>注</strong>: <code>rake test</code>已被<code>rake rspec</code>脚本覆盖。</p></blockquote><h3 id="image-和-services"><a href="#image-和-services" class="headerlink" title="image 和 services"></a>image 和 services</h3><p>这两个关键字允许使用一个自定义的 Docker 镜像和一系列的服务，并且可以用于整个 job 周期。详细配置文档请查看<a href="https://docs.gitlab.com/ee/ci/docker/README.html" target="_blank" rel="noopener">a separate document</a>。</p><h3 id="before-script-和-after-script"><a href="#before-script-和-after-script" class="headerlink" title="before_script 和 after_script"></a>before_script 和 after_script</h3><p><code>before_script</code>用来定义所有 job 之前运行的命令，<code>after_script</code>用来定义所有 job 之后运行的命令。它们可以是一个数组或者是多行字符串。</p><h3 id="stages"><a href="#stages" class="headerlink" title="stages"></a>stages</h3><p>stages 用来定义可以被 job 调用的 stages。stages 的规范允许有灵活的多级 pipelines。</p><p>stages中的元素顺序决定了对应job的执行顺序：</p><ol><li>相同 stage 的 job 可以平行执行。</li><li>下一个 stage 的 job 会在前一个 stage 的 job 成功后开始执行。</li></ol><p>接下仔细看看这个例子，它包含了3个 stage：</p><pre><code class="hljs yml"><span class="hljs-attr">stages:</span> <span class="hljs-bullet">-</span> <span class="hljs-string">build</span> <span class="hljs-bullet">-</span> <span class="hljs-string">test</span> <span class="hljs-bullet">-</span> <span class="hljs-string">deploy</span></code></pre><ol><li>首先，所有 build 的 jobs 都是并行执行的。</li><li>所有 build 的 jobs 执行成功后，test 的 jobs 才会开始并行执行。</li><li>所有 test 的 jobs 执行成功，deploy 的 jobs 才会开始并行执行。</li><li>所有的 deploy 的 jobs 执行成功，<code>commit</code>才会标记为<code>success</code>。</li><li>任何一个前置的 jobs 失败了，<code>commit</code>会标记为<code>failed</code>并且下一个 stages 的 jobs 都不会执行。</li></ol><p>这有两个特殊的例子值得一提：</p><ol><li>如果<code>.gitlab-ci.yml</code>中没有定义stages，那么 job’s stages 会默认定义为<code>build</code>，<code>test</code>和<code>deploy</code>。</li><li>如果一个 job 没有指定 stage，那么这个任务会分配到 test stage。</li></ol><h3 id="only-和-except"><a href="#only-和-except" class="headerlink" title="only 和 except"></a>only 和 except</h3><p><code>only</code>和<code>except</code>是两个参数用分支策略来限制 jobs 构建：</p><ul><li><code>only</code>定义哪些分支和标签的git项目将会被job执行。</li><li><code>except</code>定义哪些分支和标签的git项目将不会被job执行。</li></ul><p>下面是refs策略的使用规则：</p><ul><li>only 和 except 可同时使用。如果<code>only</code>和<code>except</code>在一个 job 配置中同时存在，则以 only 为准，跳过 except(从下面示例中得出)。</li><li>only 和 except 可以使用正则表达式。</li><li>only 和 except 允许使用特殊的关键字：<code>branches</code>，<code>tags</code>和<code>triggers</code>。</li><li>only 和 except 允许使用指定仓库地址但不是forks的仓库(查看示例3)。</li></ul><p>在下面这个例子中，job 将只会运行以<code>issue-</code>开始的refs(分支)，然而<code>except</code>中设置将被跳过。</p><pre><code class="hljs yml"><span class="hljs-attr">job:</span>  <span class="hljs-comment"># use regexp</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">/^issue-.*$/</span>  <span class="hljs-comment"># use special keyword</span>  <span class="hljs-attr">except:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">branches</span></code></pre><p>在下面这个例子中，job 将只会执行有<code>tags</code>的refs，或者通过<code>API</code>触发器明确地请求构建。</p><pre><code class="hljs yml"><span class="hljs-attr">job:</span>  <span class="hljs-comment"># use special keywords</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">tags</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">triggers</span></code></pre><p>下面这个例子将会为所有的分支执行job，但 master 分支除外。</p><pre><code class="hljs yml"><span class="hljs-attr">job:</span>  <span class="hljs-attr">only:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">branches@gitlab-org/gitlab-ce</span>  <span class="hljs-attr">except:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">master@gitlab-org/gitlab-ce</span></code></pre><h3 id="variables"><a href="#variables" class="headerlink" title="variables"></a>variables</h3><p>GItLab CI 允许在<code>.gitlab-ci.yml</code>文件中添加变量，并在 job 环境中起作用。因为这些配置是存储在 git 仓库中，所以<strong>最好是存储项目的非敏感配置</strong>，例如：</p><pre><code class="hljs yml"><span class="hljs-attr">variables:</span>  <span class="hljs-string">DATABASE_URL:"postgres://postgres@postgres/my_database"</span></code></pre><p>这些变量可以被后续的命令和脚本使用。</p><p>除了用户自定义的变量外，Runner 也可以定义它自己的变量。<code>CI_COMMIT_REG_NAME</code>就是一个很好的例子，它的值表示用于构建项目的分支或tag名称。除了在<code>.gitlab-ci.yml</code>中设置变量外，还有可以通过 GitLab 的界面上设置私有变量。</p><p>这里有更多关于<a href="https://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="noopener">variables</a>的介绍。</p><h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><h4 id="cache-paths"><a href="#cache-paths" class="headerlink" title="cache: paths"></a>cache: paths</h4><p>使用<code>paths</code>指令选择要缓存的文件或目录。也可以使用通配符。</p><p>如果 cache 定义在 jobs 的作用域之外，那么它就是全局缓存，所有 jobs 都可以使用该缓存。</p><p>缓存<code>binaries</code>和<code>.config</code>中的所有文件：</p><pre><code class="hljs yml"><span class="hljs-attr">rspec:</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">cache:</span>    <span class="hljs-attr">paths:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">binaries/</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">.config</span></code></pre><p>缓存<code>git</code>中没有被跟踪的文件：</p><pre><code class="hljs yml"><span class="hljs-attr">rspec:</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">cache:</span>    <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><p>缓存<code>binaries</code>下没有被<code>git</code>跟踪的文件：</p><pre><code class="hljs yml"><span class="hljs-attr">rspec:</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">cache:</span>    <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span>    <span class="hljs-attr">paths:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">binaries/</span></code></pre><p>job 中优先级高于全局的。下面这个<code>rspec</code> job中将只会缓存<code>binaries/</code>下的文件：</p><pre><code class="hljs yml"><span class="hljs-attr">cache:</span>  <span class="hljs-attr">paths:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">my/files</span><span class="hljs-attr">rspec:</span>  <span class="hljs-attr">script:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">cache:</span>    <span class="hljs-attr">key:</span> <span class="hljs-string">rspec</span>    <span class="hljs-attr">paths:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">binaries/</span></code></pre><p>注意，缓存是在 jobs 之前进行共享的。如果你不同的 jobs 缓存不同的文件路径，必须设置不同的<code>cache:key</code>，否则缓存内容将被重写。缓存只是尽力而为之，所以别期望缓存会一直存在。</p><h4 id="cache-key"><a href="#cache-key" class="headerlink" title="cache: key"></a>cache: key</h4><p><code>key</code>指令允许我们定义缓存的作用域(亲和性)，可以是所有 jobs 的单个缓存，也可以是每个 job，也可以是每个分支或者是任何你认为合适的地方。它也可以让你很好的调整缓存，允许你设置不同 jobs 的缓存，甚至是不同分支的缓存。</p><p><code>cache:key</code>可以使用任何的<a href="https://docs.gitlab.com/ce/ci/variables/README.html" target="_blank" rel="noopener">预定义变量</a>。</p><p>默认key是默认设置的这个项目缓存，因此默认情况下，从GitLab 9.0开始，每个 pipelines 和 jobs 中可以共享一切。</p><p>配置示例</p><p>缓存每个job：</p><pre><code class="hljs yml"><span class="hljs-attr">cache:</span>  <span class="hljs-attr">key:</span> <span class="hljs-string">"$CI_JOB_NAME"</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><p>缓存每个分支：</p><pre><code class="hljs yml"><span class="hljs-attr">cache:</span>  <span class="hljs-attr">key:</span> <span class="hljs-string">"$CI_COMMIT_REF_NAME"</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><p>缓存每个 job 且每个分支：</p><pre><code class="hljs yml"><span class="hljs-attr">cache:</span>  <span class="hljs-attr">key:</span> <span class="hljs-string">"$CI_JOB_NAME/$CI_COMMIT_REF_NAME"</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><p>缓存每个分支且每个stage：</p><pre><code class="hljs yml"><span class="hljs-attr">cache:</span>  <span class="hljs-attr">key:</span> <span class="hljs-string">"$CI_JOB_STAGE/$CI_COMMIT_REF_NAME"</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><p>如果使用的Windows Batch(windows批处理)来跑脚本需要用%替代$：</p><pre><code class="hljs yml"><span class="hljs-attr">cache:</span>  <span class="hljs-attr">key:</span> <span class="hljs-string">"%CI_JOB_STAGE%/%CI_COMMIT_REF_NAME%"</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><h3 id="allow-failure"><a href="#allow-failure" class="headerlink" title="allow_failure"></a>allow_failure</h3><p><code>allow_failure</code>可以用于当你想设置一个 job 失败的之后并不影响后续的CI组件的时候。失败的 jobs 不会影响到<code>commit</code>状态。</p><p>当开启了允许 job 失败，所有的 intents 和 purposes 里的 pipeline 都是成功/绿色，但是也会有一个”<code>CI build passed with warnings</code>“信息显示在<code>Merge Request</code>或<code>commit</code>或<code>job page</code>。这被允许失败的作业使用，但是如果失败表示其他地方应采取其他（手动）步骤。</p><p>下面的这个例子中，job1和job2将会并列进行，如果job1失败了，它也不会影响进行中的下一个 stage，因为这里有设置了<code>allow_failure: true</code>。</p><pre><code class="hljs yml"><span class="hljs-attr">job1:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">execute_script_that_will_fail</span>  <span class="hljs-attr">allow_failure:</span> <span class="hljs-literal">true</span><span class="hljs-attr">job2:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">test</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">execute_script_that_will_succeed</span><span class="hljs-attr">job3:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">deploy</span>  <span class="hljs-attr">script:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">deploy_to_staging</span></code></pre><h3 id="when"><a href="#when" class="headerlink" title="when"></a>when</h3><p><code>when</code>用于实现在发生故障或尽管失败时运行的作业。when可以设置以下值：</p><ul><li><code>on_success</code> - 只有前面 stages 的所有工作成功时才执行。这是默认值。</li><li><code>on_failure</code> - 当前面 stages 中任意一个jobs失败后执行。</li><li><code>always</code> - 无论前面 stages 中 jobs 状态如何都执行。</li><li><code>manual</code> - 手动执行(GitLab8.10增加)。更多请查看手动操作。</li></ul><h3 id="artifacts"><a href="#artifacts" class="headerlink" title="artifacts"></a>artifacts</h3><p><code>artifacts</code>用于指定成功后应附加到 job 的文件和目录的列表。只能使用项目工作间内的文件或目录路径。在job成功完成后artifacts将会发送到GitLab中，同时也会在 GitLab UI 中提供下载。如果想要在不通的 job 之间传递<code>artifacts</code>，请查阅<a href="https://docs.gitlab.com/ce/ci/yaml/README.html#dependencies" target="_blank" rel="noopener">依赖关系</a>。以下是一些例子：</p><p>发送<code>binaries</code>和<code>.config</code>中的所有文件：</p><pre><code class="hljs yml"><span class="hljs-attr">artifacts:</span>  <span class="hljs-attr">paths:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">binaries/</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">.config</span></code></pre><p>发送所有没有被Git跟踪的文件：</p><pre><code class="hljs yml"><span class="hljs-attr">artifacts:</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span></code></pre><p>发送没有被Git跟踪和<code>binaries</code>中的所有文件：</p><pre><code class="hljs yml"><span class="hljs-attr">artifacts:</span>  <span class="hljs-attr">untracked:</span> <span class="hljs-literal">true</span>  <span class="hljs-attr">paths:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">binaries/</span></code></pre><h2 id="五、其他相关内容"><a href="#五、其他相关内容" class="headerlink" title="五、其他相关内容"></a>五、其他相关内容</h2><h3 id="1-API触发器-Triggers"><a href="#1-API触发器-Triggers" class="headerlink" title="1 API触发器 Triggers"></a>1 API触发器 Triggers</h3><p>Triggers 可用于强制使用API调用重建特定分支，<code>tag</code>或<code>commits</code>。API的使用示例可以在<code>Settings</code> -&gt; <code>CI/CD</code> -&gt; <code>Pipeline triggers</code>中找到。</p><p>在<code>triggers</code>文档中<a href="https://docs.gitlab.com/ce/ci/triggers/README.html" target="_blank" rel="noopener">查看更多</a>。</p><h3 id="2-配置定时任务"><a href="#2-配置定时任务" class="headerlink" title="2 配置定时任务"></a>2 配置定时任务</h3><p>GitLab CI 中可以在 GitLab <code>Settings</code> -&gt; <code>CI/CD</code> -&gt; <code>Schedules</code>中配置定时任务，点击<code>New Schedule</code>按钮，可以配置你流水线的定时执行任务，包括：描述信息、定时的Cron表达式、目标分支、变量等信息。</p><p>然后在需要定时执行的作业的<code>only</code>分支写上<code>schedules</code>即可。</p><h3 id="3-校验-gitlab-ci-yml"><a href="#3-校验-gitlab-ci-yml" class="headerlink" title="3 校验 .gitlab-ci.yml"></a>3 校验 .gitlab-ci.yml</h3><p>GitLab CI 的每个实例都有一个名为<code>Lint</code>的嵌入式调试工具。 你可以在 GitLab 实例的<code>-/ci/lint</code>下找到该链接。</p><h3 id="4-配置邮件发送"><a href="#4-配置邮件发送" class="headerlink" title="4 配置邮件发送"></a>4 配置邮件发送</h3><p>如果希望在每次构建完成后（或者在仅构建失败的情况下），想邮件发送给相关开发人员，则可以在 GitLab <code>Settings</code> -&gt; <code>Integrations</code> 中找到<code>Pipelines emails</code>，点击进去就可以配置邮件发送相关的内容了。</p><h3 id="5-配置Cocall消息提醒"><a href="#5-配置Cocall消息提醒" class="headerlink" title="5 配置Cocall消息提醒"></a>5 配置Cocall消息提醒</h3><p>在流水线构建完毕之后，为了能够更加实时的提醒到对应push的人员，任晓波基于<code>GitLab</code>和<code>Cocall</code>的相关接口，做了一个<a href="http://172.16.210.128:7777/" target="_blank" rel="noopener">集成服务</a>。可以在 GitLab 中的流水线、合并请求、Issues事件、Comments等事件发生后，给予对应开发人员 Cocall 提醒。通过这个集成服务生成一个回调的<code>url</code>，然后只需在 <code>Settings</code> -&gt; <code>Integrations</code> 中配置上这个<code>url</code>即可。</p><h3 id="6-GitLab-Pages"><a href="#6-GitLab-Pages" class="headerlink" title="6 GitLab Pages"></a>6 GitLab Pages</h3><p><a href="https://gitlab.com/pages/" target="_blank" rel="noopener">GitLab Pages</a>是用于托管静态文件的服务。而<code>pages</code>是一个特殊的job，用于将静态的内容上传到GitLab，可用于为您的网站提供服务。它有特殊的语法，因此必须满足以下两个要求：</p><ul><li>任何静态内容必须放在<code>public/</code>目录下</li><li>artifacts必须定义在<code>public/</code>目录下</li></ul><p>下面的这个例子是将所有文件从项目根目录移动到<code>public/</code>目录。<code>.public</code>工作流是<code>cp</code>，并且它不会循环复制<code>public/</code>本身。</p><pre><code class="hljs yml"><span class="hljs-attr">pages:</span>  <span class="hljs-attr">stage:</span> <span class="hljs-string">deploy</span>  <span class="hljs-attr">script:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">mkdir</span> <span class="hljs-string">.public</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">cp</span> <span class="hljs-string">-r</span> <span class="hljs-string">*</span> <span class="hljs-string">.public</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">mv</span> <span class="hljs-string">.public</span> <span class="hljs-string">public</span>  <span class="hljs-attr">artifacts:</span>    <span class="hljs-attr">paths:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">public</span>  <span class="hljs-attr">only:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">master</span></code></pre><p>更多内容请查看<a href="https://docs.gitlab.com/ce/user/project/pages/index.html" target="_blank" rel="noopener">GitLab Pages用户文档</a>。</p><h3 id="7-跳过-jobs"><a href="#7-跳过-jobs" class="headerlink" title="7 跳过 jobs"></a>7 跳过 jobs</h3><p>如果你的<code>commit</code>信息中包含<code>[ci skip]</code>或者<code>[skip ci]</code>，不论大小写，那么这个<code>commit</code>将会创建但是 jobs 也会跳过。</p><hr><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">官方文档地址</a></li><li><a href="https://segmentfault.com/a/1190000010442764#articleHeader24" target="_blank" rel="noopener">segmentfault yaml配置中文翻译</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitLab持续集成环境搭建</title>
    <link href="/2019/03/26/normal/gitlabci%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    <url>/2019/03/26/normal/gitlabci%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="GitLab持续集成环境搭建"><a href="#GitLab持续集成环境搭建" class="headerlink" title="GitLab持续集成环境搭建"></a>GitLab持续集成环境搭建</h1><blockquote><p>随着微服务的兴起，部署服务越来越繁琐，当然业内也有对应的持续集成方案，目前在企业中使用较为广泛的持续集成方案应是gitlab持续集成、持续部署（gitlab CI/CD）</p></blockquote><h2 id="安装GitLab与GitLab-Runner"><a href="#安装GitLab与GitLab-Runner" class="headerlink" title="安装GitLab与GitLab-Runner"></a>安装GitLab与GitLab-Runner</h2><blockquote><p>为了简化安装，本文使用docker进行操作</p></blockquote><p><strong>GitLab安装：</strong></p><p>首先拉去镜像：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker pull gitlab/gitlab-ce</span></code></pre><p>拉取成功后使用如下命令启动容器：</p><pre><code class="hljs shell">docker run -itd -p 8443:443 -p 8081:8081 -p 2222:22 \--name gitlab --restart always \--volume ~/develop/docker/gitlab/config:/etc/gitlab \--volume ~/develop/docker/gitlab/logs:/var/log/gitlab \--volume ~/develop/docker/gitlab/data:/var/opt/gitlab \gitlab/gitlab-ce:latest</code></pre><p>需要注意的是：</p><ul><li>端口<code>8443</code> ,<code>8081</code>,<code>2222</code>可任意选择一个物理机上可用的端口。</li><li>映射内部<code>8081</code>端口的原因是，如果直接启动，在拉取代码的时候，网页会返回对应的容器id作为拉取的url，例如：<code>http://1fj3280sd/jlh/test</code>,对于这种情况，只需在<code>--volume ~/develop/docker/gitlab/config</code>中找到<code>gitlab.rb</code>文件，修改其中的配置项即可，<code>external_url &quot;http://ip:8081&quot;</code>。但是如果直接设置该属性，会使得容器内gitlab端口改为8081，会导致端口映射失败，顾此处要暴露8081端口。</li><li><code>—volume</code>是将容器中的地址映射到物理机上。</li><li>第一次启动容器，由于要进行初始化，所以启动时间较慢。</li></ul><p><strong>GitLabRunner安装：</strong></p><p>拉取镜像：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker pull gitlab/gitlab-runner</span></code></pre><p>启动gitlab-runner容器：</p><pre><code class="hljs shell">docker run -d --name gitlab-runner --restart always \  -v /srv/gitlab-runner/config:/etc/gitlab-runner \  -v /var/run/docker.sock:/var/run/docker.sock \  gitlab/gitlab-runner:latest</code></pre><h2 id="注册Runner"><a href="#注册Runner" class="headerlink" title="注册Runner"></a>注册Runner</h2><h3 id="容器之间互联"><a href="#容器之间互联" class="headerlink" title="容器之间互联"></a>容器之间互联</h3><p>在注册Runner的时候需要输入gitlab的访问地址，而docker容器之间不能直接连接，所以需要进如下操作使得容器互联。</p><p>容器之间的互联有三种方式：</p><ul><li>通过容器ip直接连接</li></ul><p>使用命令<code>apt-get install iputils-ping</code>、<code>apt-get install net-tools</code>安装<code>ping</code>与<code>ifconfig</code>，安装完成之后查看容器ip</p><ul><li>运行容器的时候加上<code>--link 容器名称:容器别名</code>，此时可通过容器的别名进行连接</li><li>创建bridge网络</li></ul><p>使用<code>docker network create testnet</code>创建网络，然后在运行容器的时候使用该网络，使用方法：</p><p>docker run -it –name &lt;容器名&gt; —network <bridge> –network-alias &lt;网络别名&gt; &lt;镜像名&gt;</p><p>此处我选用的直接用ip连接。</p><p>查看容器的两种方法：</p><ul><li>使用<code>docker exex -it 容器id /bin/bash</code>进去容器，安装<code>ifconfig</code>，并使用该命令查看容器ip</li><li>安装docker控制台工具，在控制工具中可直接查看容器的ip等信息，我使用的是<code>portainer</code>，镜像网易云链接：<a href="https://c.163yun.com/hub#/m/repository/?repoId=78662" target="_blank" rel="noopener">https://c.163yun.com/hub#/m/repository/?repoId=78662</a></li></ul><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>首先进入容器，使用<code>gitlab-runner register</code>命令注册：</p><pre><code class="hljs shell">root@f3c47cad0bf8:/# gitlab-runner registerRuntime platform                                    arch=amd64 os=linux pid=82 revision=6946bae7 version=12.0.0Running in system-mode.                                                                               Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/):http://172.17.0.3:8081 #gitlab访问地址Please enter the gitlab-ci token for this runner:cFa_ASWeispNJRBxs7Uz #gitlab仓库注册令牌Please enter the gitlab-ci description for this runner:[f3c47cad0bf8]: test Please enter the gitlab-ci tags for this runner (comma separated):testRegistering runner... succeeded                     runner=cFa_ASWePlease enter the executor: docker-ssh+machine, kubernetes, docker, parallels, shell, ssh, virtualbox, docker+machine, docker-ssh:dockerPlease enter the default Docker image (e.g. ruby:2.6):alpine:latestRunner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! root@f3c47cad0bf8:/# gitlab-runner start #启动容器Runtime platform                                    arch=amd64 os=linux pid=90 revision=6946bae7 version=12.0.0root@f3c47cad0bf8:/#</code></pre><p>gitlab仓库注册令牌获取方式如图：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/gitlab/token.jpg" srcset="/img/loading.gif" alt="令牌获取方式"></p><p>在完成注册后，在gitlab里可以查看到如下内容：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/gitlab/runner-one-success.jpg" srcset="/img/loading.gif" alt="runner注册成功预览"></p><h3 id="注册群组runner"><a href="#注册群组runner" class="headerlink" title="注册群组runner"></a>注册群组runner</h3><p>注册群主runner与单个方式相同，首先在gitlab上新建一个群组，然后在该群组的[设置-&gt;CI/CD-&gt;Runner]中查看Runner注册令牌，然后在注册runner的时候使用该令牌即可。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitlabci项目集成</title>
    <link href="/2019/03/26/normal/gitlabci%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/"/>
    <url>/2019/03/26/normal/gitlabci%E6%9E%84%E5%BB%BA%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="gitlabci项目集成"><a href="#gitlabci项目集成" class="headerlink" title="gitlabci项目集成"></a>gitlabci项目集成</h1><pre><code class="hljs plain">Running with gitlab-runner 11.3.1 (0aa5179e)  on docker-ci 0f9fe2c4Using Docker executor with image node:latest ...ERROR: Preparation failed: Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running? (executor_docker.go:1150:0s)</code></pre><pre><code class="hljs plain">sudo docker run -d --name gitlab-runner --restart always \ -v ~&#x2F;srv&#x2F;gitlab-runner&#x2F;config:&#x2F;etc&#x2F;gitlab-runner \ -v ~&#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock \ gitlab&#x2F;gitlab-runner:latest</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gitlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx配置</title>
    <link href="/2018/12/22/server/nginx%E9%85%8D%E7%BD%AE/"/>
    <url>/2018/12/22/server/nginx%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h2 id="nginx常用编译参数"><a href="#nginx常用编译参数" class="headerlink" title="nginx常用编译参数"></a>nginx常用编译参数</h2><p>对于nginx，如果使用源码安装，在进行./configure编译的时候，需要为其指定一些参数。</p><ul><li><p>–prefix=PATH ： 指定nginx的安装目录。默认 /usr/local/nginx</p></li><li><p>–conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为<em>prefix/conf/nginx.conf</em></p></li><li><p>–user=name： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。–group=name类似</p></li><li><p>–with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。使用–with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本4.4 – 8.30）并解压，剩下的就交给Nginx的./configure和make来完成。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。</p></li><li><p>–with-zlib=PATH ： 指定 zlib（版本1.1.3 – 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。</p></li><li><p>–with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装</p></li><li><p>–with-http_stub_status_module ： 用来监控 Nginx 的当前状态</p></li><li><p>–with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址</p></li><li><p>–add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译）</p><h2 id="config基本配置概览"><a href="#config基本配置概览" class="headerlink" title="config基本配置概览"></a>config基本配置概览</h2></li></ul><p>Nginx的配置文件默认在Nginx程序安装目录的conf目录下，其中核心文件为nginx.conf，当然你也可以自己写配置文件，然后在nginx.conf中引用。</p><p>nginx.conf配置具体信息如下：</p><pre><code class="hljs plain">#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log info;#进程文件pid &#x2F;var&#x2F;run&#x2F;nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events&#123;    #参考事件模型，use [ kqueue | rtsig | epoll | &#x2F;dev&#x2F;poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I&#x2F;O模型，如果跑在FreeBSD上面，就用kqueue模型。use epoll;#单个进程最大连接数（最大连接数&#x3D;连接数*进程数）worker_connections 65535;&#125;#设定http服务器http&#123;include mime.types; #文件扩展名与文件类型映射表default_type application&#x2F;octet-stream; #默认文件类型#charset utf-8; #默认编码server_names_hash_bucket_size 128; #服务器名字的hash表大小client_header_buffer_size 32k; #上传文件大小限制large_client_header_buffers 4 64k; #设定请求缓client_max_body_size 8m; #设定请求缓sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。tcp_nopush on; #防止网络阻塞tcp_nodelay on; #防止网络阻塞keepalive_timeout 120; #长连接超时时间，单位是秒#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300;fastcgi_buffer_size 64k;fastcgi_buffers 4 64k;fastcgi_busy_buffers_size 128k;fastcgi_temp_file_write_size 128k;#gzip模块设置gzip on; #开启gzip压缩输出gzip_min_length 1k; #最小压缩文件大小gzip_buffers 4 16k; #压缩缓冲区gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）gzip_comp_level 2; #压缩等级gzip_types text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml;#压缩类型，默认就已经包含text&#x2F;html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。gzip_vary on;#limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用upstream blog.ha97.com &#123;#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。server 192.168.80.121:80 weight&#x3D;3;server 192.168.80.122:80 weight&#x3D;2;server 192.168.80.123:80 weight&#x3D;3;&#125;#虚拟主机的配置server&#123;#监听端口listen 80;#域名可以有多个，用空格隔开server_name www.ha97.com ha97.com;index index.html index.htm index.php;root &#x2F;data&#x2F;www&#x2F;ha97;location ~ .*.(php|php5)?$&#123;fastcgi_pass 127.0.0.1:9000;fastcgi_index index.php;include fastcgi.conf;&#125;#图片缓存时间设置location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$&#123;expires 10d;&#125;#JS和CSS缓存时间设置location ~ .*.(js|css)?$&#123;expires 1h;&#125;#日志格式设定log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;&#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;&#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;#定义本虚拟主机的访问日志access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;ha97access.log access;#对 &quot;&#x2F;&quot; 启用反向代理location &#x2F; &#123;            proxy_pass http:&#x2F;&#x2F;127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置，可选。            proxy_set_header Host $host;            client_max_body_size 10m; #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)            proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）            proxy_temp_file_write_size 64k;#设定缓存文件夹大小，大于这个值，将从upstream服务器传&#125;#设定查看Nginx状态的地址location &#x2F;NginxStatus &#123;            stub_status on;            access_log on;            auth_basic &quot;NginxStatus&quot;;            auth_basic_user_file conf&#x2F;htpasswd;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。&#125;#本地动静分离反向代理配置        #所有jsp的页面均交由tomcat或resin处理        location ~ .(jsp|jspx|do)?$ &#123;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;        &#125;#所有静态文件由nginx直接读取不经过tomcat或resinlocation ~ .*.(htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$&#123; expires 15d; &#125;location ~ .*.(js|css)?$&#123; expires 1h; &#125;&#125;&#125;</code></pre><h2 id="nginx常用配置说明"><a href="#nginx常用配置说明" class="headerlink" title="nginx常用配置说明"></a>nginx常用配置说明</h2><h3 id="nginx日志文件配置"><a href="#nginx日志文件配置" class="headerlink" title="nginx日志文件配置"></a>nginx日志文件配置</h3><p>关于日志文件的配置主要有两个属性log_format、access_log、error_log。</p><h4 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h4><p>log_format为日志格式，其语法为：</p><pre><code class="hljs plain">log_format name format &#123;format ... &#125;</code></pre><p>其中，name表示日志名字，format表示定义的格式样式。</p><p>log_format有一个默认的、无需配置的combined日志格式：</p><pre><code class="hljs plain">log_format combined &#39;$remote_addr-$remote_user [$time_local]&#39;&quot;$request&quot;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot;</code></pre><p>在日志格式中的变量主要有：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>反向代理服务器的IP地址</td><td>127.0.0.1</td></tr><tr><td>$remote_user</td><td>远程客户端用户名称</td><td>–</td></tr><tr><td>$time_local</td><td>访问时间与时区</td><td>18/Jul/2012:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求URL与HTTP协议</td><td>GET /article-10000.html HTTP/1.1</td></tr><tr><td>$status</td><td>请求状态，例如成功时状态为200，页面找不到时状态为404</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送客户端的文件主体内容大小</td><td>1000</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$http_referer</td><td>访问来源</td><td><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></td></tr><tr><td>$http_user_agent</td><td>客户浏览器的相关信息</td><td>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.10.10.100:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.205</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 192.168.1.1</td></tr></tbody></table><h4 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h4><p>access_log主要用于记录nginx访问日志。其语法如下：</p><pre><code class="hljs plain">access_log path [foramt &#123;buffer-size | off&#125;</code></pre><p>关闭日志方法：access_log off。</p><p>使用默认combined格式记录日志：access_log path。</p><p>使用自定义格式记录日志，首先定义一个log_format，如log_format customformat ‘具体配置’。</p><p>access_log path customformat  buffer=32k。</p><p>结尾的buffer代表缓冲区大小。</p><h4 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h4><p>与access_log不同的是，error_log主要记录nginx运行过程中的错误日志。其语法如下</p><pre><code class="hljs plain">error_log &lt;FILE&gt; &lt;LEVEL&gt;</code></pre><p>其中参数含义如下：</p><ul><li>FILE：代表日志文件存放目录。</li><li>LEVEL：错误日志级别。</li></ul><p>常见的错误日志级别有：debug | info | notice | warn | error | crit | alert | emerg ，级别越高记录的错误信息越少。对于我们而言，一般用到的为warn，error,crit。</p><h3 id="nginx压缩输出"><a href="#nginx压缩输出" class="headerlink" title="nginx压缩输出"></a>nginx压缩输出</h3><p>nginx压缩输出使用的技术为gzip(GNU-ZIP)压缩技术。经过gzip压缩后的页面大小可以变为原来的30%以下，压缩页面后可以降低用户在浏览页面时下载资源的时间，但gzip有个明显的去诶按，就是需要服务端与客户端同步支持gzip，即服务器压缩，浏览器解压。目前IE、Chrome等主流浏览器均具备解压gzip的功能。</p><p>nginx中的gzip指令如下：</p><p>开启或关闭gzip</p><pre><code class="hljs plain">gzip on|off</code></pre><p>设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流</p><pre><code class="hljs plain">gzip_buffers number size</code></pre><p>设置gzip压缩比例</p><pre><code class="hljs plain">gzip_comp_level 1..9</code></pre><p>设置允许压缩的页面最小字节数，当页面超过该数值时才进行压缩，其默认为0，即所有页面都进行压缩</p><pre><code class="hljs plain">gzip_min_length length</code></pre><h3 id="nginx作为静态服务器"><a href="#nginx作为静态服务器" class="headerlink" title="nginx作为静态服务器"></a>nginx作为静态服务器</h3><p>nginx其根本上是一个HTTP服务器，可以将服务器撒花姑娘的静态资源文件（如HTML、JS、Image）通过HTTP协议展现给客户端。</p><pre><code class="hljs plain">server &#123;    listen 80; # 端口号    location &#x2F; &#123;        root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; # 静态文件路径    &#125;&#125;</code></pre><h3 id="nginx负载均衡与反向代理"><a href="#nginx负载均衡与反向代理" class="headerlink" title="nginx负载均衡与反向代理"></a>nginx负载均衡与反向代理</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p>负载均衡就是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。</p></blockquote><p>常见的复杂均衡主要有：</p><ul><li>用户手动选择：通过用户手动选择线路。</li><li>DNS轮询：为域名添加多个解析记录。</li><li>四/七层负载均衡设备：硬件实现负载均衡，如F5。软件实现为LVS。</li><li>Nginx负载均衡</li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><blockquote><p>反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求发给内部网路上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p></blockquote><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在nginx中，通过Upstream可以设置一组在proxy_pass和fastcgi_pass指令中使用的代理服务器，默认的负载均衡方式为轮询，Upstream模块中的Server指令用于指定后端服务器的名称和参数，服务器的名称可以是一个域名、一个IP地址、端口号或UNIX Socket。</p><p>而在server{}虚拟主机内，可以通过proxy_pass和fastcgi_pass指令设置进行反向代理的服务器集群。</p><p>proxy_set_header指令用于在向反向代理的后端Web服务器发起请求时添加指定的Header头信息。</p><p>当后端Web服务器上有多个基于域名的虚拟主机时，要通过添加Header头信息Host，用于指定请求的域名，这样后端Web服务器才能识别该方向代理访问请求由哪一个虚拟主机来处理。</p><p>在使用方向代理后，连接通过代理服务器链接到目标服务器后，如果在目标服务器中存在获取用户真实IP的代码（比如，Java、PHP等后台语言）就会失效，这时服务器获取的是代理服务器的IP。如果要获取真实IP，需要在nginx反向代理配置里添加Header头信息：X-Forwarded-For,让目标服务器能够获取用户的真实IP。</p><p>具体配置如下：</p><pre><code class="hljs plain">upstream baidu.com &#123;# weight 设置权重      server 127.0.0.1:8881 weight&#x3D;3;      server 127.0.0.1:8882;      server 127.0.0.1:8888;&#125;server&#123;     listen 80;     server_name baidu.com;     location &#x2F; &#123;         proxy_pass         http:&#x2F;&#x2F;baidu.com;         proxy_set_header   Host             $host;         #获取真实IP设置        proxy_set_header   X-Real-IP        $remote_addr;         proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;     &#125; &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot本地化配置</title>
    <link href="/2018/10/22/Java/spring/SpringBoot%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%85%8D%E7%BD%AE/"/>
    <url>/2018/10/22/Java/spring/SpringBoot%E6%9C%AC%E5%9C%B0%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot本地化配置"><a href="#SpringBoot本地化配置" class="headerlink" title="SpringBoot本地化配置"></a>SpringBoot本地化配置</h1><h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><p>相信做过Spring项目的同学应该对下面一行代码比较熟悉：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"systemPropertiesModeName"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"SYSTEM_PROPERTIES_MODE_OVERRIDE"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"ignoreResourceNotFound"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span>/&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"locations"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>classpath:prop/*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>file:$&#123;XXXX_HOME&#125;/properties/launch.properties<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><p>其中，<code>${XXXX_HOME}</code>为环境变量（例如：XXXX_HOME=/usr/local/myjava），从代码可以看出，我们既加载了<code>classpath</code>下的配置文件，又加载了<code>${XXXX_HOME}</code>目录下的<code>properties/launch.properties</code>文件，通过这样的方式，我们可以对项目的配置文件进行集中管理，而不需要每个项目都去配置。</p><p>而<code>SpringBoot</code>则移除了上诉的配置方式，而给我们开放了5种加载方式，分别为：</p><ul><li>file:./config/</li><li>file:./</li><li>classpath:/config/</li><li>classpath:/</li><li>spring.config.location</li></ul><p>值得注意的是，其中spring.config.location为在启动SpringBoot时，为其指定的配置文件路：</p><pre><code class="hljs plain">java -jar demo.jar --Dspring.config.location&#x3D;application.properties</code></pre><p>当然，如果你在开发项目的时候也可给启动方式添加 <code>VM options</code>参数。</p><p>虽然以上方式能解决大部分用户的需求，但我仍然觉得通过环境变量去对项目进行配置的方式更好。</p><h2 id="动态管理配置文件"><a href="#动态管理配置文件" class="headerlink" title="动态管理配置文件"></a>动态管理配置文件</h2><p><code>SpringBoot</code>移除了传统的配置方式，并新增了5种新的配置方式，但好在上帝关上一扇门，同时也会为我们打开一扇窗。<code>SpringBoot</code>或许就是为了关照我这类的用户，特意留了一个扩展接口<code>org.springframework.boot.env.EnvironmentPostProcessor</code>，我们使用这个接口就可以对配置文件进行集中管理。</p><p>了解SpringBoot的都知道，它在启动过程中会通过<code>spring.factories</code>文件去加载启动需要的监听器。此处我将使用<code>spring.factories</code>与<code>EnvironmentPostProcessor</code>来构建一个配置文件集中管理的功能。</p><p>如果对<code>spring.factories</code>不了解，可以查阅SpringBoot的启动过程：<a href="https://blog.csdn.net/jlh912008548/article/details/81437036" target="_blank" rel="noopener">https://blog.csdn.net/jlh912008548/article/details/81437036</a></p><p>首先，在项目中定义一个类<code>CustomEnvironmentPostProcessor</code>实现<code>EnvironmentPostProcessor</code>接口，其代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.env.EnvironmentPostProcessor;<span class="hljs-keyword">import</span> org.springframework.core.env.ConfigurableEnvironment;<span class="hljs-keyword">import</span> org.springframework.core.env.PropertiesPropertySource;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.exception.CustomizedRuntimeException;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.system.constant.SystemConstants;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.system.util.EnvironmentUtils;<span class="hljs-keyword">import</span> java.io.FileInputStream;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * CustomEnvironmentPostProcessor</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 加载外部文件</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/8/12 0:24</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomEnvironmentPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EnvironmentPostProcessor</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(CustomEnvironmentPostProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 配置文件存在文件夹</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CONFIG_PATH = <span class="hljs-string">"/config/application.properties"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SOURCE_NAME = <span class="hljs-string">"cus"</span>;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessEnvironment</span><span class="hljs-params">(ConfigurableEnvironment configurableEnvironment, SpringApplication springApplication)</span> </span>&#123;        LOGGER.info(<span class="hljs-string">"Load the configuration file under the environment variable,starting."</span>);        <span class="hljs-comment">//获取环境变量</span>        String rcHomeEnv = EnvironmentUtils.getEnv(<span class="hljs-string">"XXX_HOME"</span>);        <span class="hljs-keyword">try</span>(InputStream input = <span class="hljs-keyword">new</span> FileInputStream(rcHomeEnv+CONFIG_PATH)) &#123;            Properties properties = <span class="hljs-keyword">new</span> Properties();            properties.load(input);            PropertiesPropertySource propertySource = <span class="hljs-keyword">new</span> PropertiesPropertySource(SOURCE_NAME, properties);            configurableEnvironment.getPropertySources().addLast(propertySource);            LOGGER.info(<span class="hljs-string">"Load the configuration file under the environment variable,end."</span>);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> CustomizedRuntimeException(<span class="hljs-string">"Failed to load configuration file under environment variable!"</span>,e);        &#125;    &#125;&#125;</code></pre><p>需要注意的是，此处必须要加上<code>@Component</code>注解，同时所在包必须在<code>SpringBoot</code>的扫描范围内。</p><p>这里再将<code>EnvironmentUtils.getEnv</code>代码贴出来：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> pers.jarome.redis.wclient.common.system.util;<span class="hljs-keyword">import</span> org.apache.commons.lang3.StringUtils;<span class="hljs-keyword">import</span> org.slf4j.Logger;<span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * EnvironmentUtils</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 环境变量相关工具类</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/8/12 0:31</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnvironmentUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger LOGGER = LoggerFactory.getLogger(EnvironmentUtils<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 获取环境变量</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> envName</span><span class="hljs-comment">     * <span class="hljs-doctag">@execption</span> pers.jarome.redis.wclient.common.exception.NoEnvException</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getEnv</span><span class="hljs-params">(String envName)</span></span>&#123;        <span class="hljs-comment">//获取环境变量</span>        String rcHomeEnv = System.getenv(envName);        <span class="hljs-keyword">if</span> (StringUtils.isBlank(rcHomeEnv)) &#123;            LOGGER.error(<span class="hljs-string">"没有找到环境变量:"</span> + envName);            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">"没有找到环境变量:"</span> + envName);        &#125;        <span class="hljs-keyword">return</span> rcHomeEnv;    &#125;&#125;</code></pre><p>准备好监听器后，我们需要在classpath定义一个<code>META-INF</code>文件夹然后在其下面先建<code>spring.factories</code>文件，在其中指定监听器。</p><p><code>spring.factories</code>内容如下：</p><pre><code class="hljs xml">org.springframework.boot.env.EnvironmentPostProcessor=pers.jarome.redis.wclient.init.CustomEnvironmentPostProcessor</code></pre><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/spring.factories.path.png" srcset="/img/loading.gif" alt="spring.factories.path"></p><p>此时，启动<code>SpringBoot</code>项目就行了。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot加载配置文件</title>
    <link href="/2018/10/22/Java/spring/SpringBoot%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2018/10/22/Java/spring/SpringBoot%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot加载配置文件"><a href="#SpringBoot加载配置文件" class="headerlink" title="SpringBoot加载配置文件"></a>SpringBoot加载配置文件</h1><blockquote><p>读过SpringBoot源码的同学应该都知道它会在启动过程中根据spring.factories加载监听器，而其中有一个名叫<code>ConfigFileApplicationListener</code>的监听器，它的作用为加载配置信息，即application.xml、application.yml。</p></blockquote><h2 id="常量值说明"><a href="#常量值说明" class="headerlink" title="常量值说明"></a>常量值说明</h2><p>在<code>ConfigFileApplicationListener</code>定义了一批常量，他们主要为加载配置文件服务，现在就总体地看看这些常量吧。</p><table><thead><tr><th>名称</th><th>类型</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>DEFAULT_SEARCH_LOCATIONS</td><td>String</td><td>classpath:/,classpath:/config/,file:./,file:./config/</td><td>配置文件加载顺序</td></tr><tr><td>DEFAULT_NAMES</td><td>String</td><td>application</td><td>默认配置文件名称</td></tr><tr><td>ACTIVE_PROFILES_PROPERTY</td><td>String</td><td>spring.profiles.active</td><td>“活动配置文件”属性名称</td></tr><tr><td>INCLUDE_PROFILES_PROPERTY</td><td>String</td><td>spring.profiles.include</td><td>“包含配置文件”属性名称。</td></tr><tr><td>CONFIG_NAME_PROPERTY</td><td>String</td><td>spring.config.name</td><td>“配置名称”属性名称。</td></tr><tr><td>CONFIG_LOCATION_PROPERTY</td><td>String</td><td>spring.config.location</td><td>“配置位置”属性名称。</td></tr><tr><td>DEFAULT_ORDER</td><td>int</td><td>Integer.MIN_VALUE+10</td><td>处理器的默认顺序。</td></tr></tbody></table><h2 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h2><h3 id="监听器入口"><a href="#监听器入口" class="headerlink" title="监听器入口"></a>监听器入口</h3><p>阅读SpringBoot启动源码时，我们都知道监听器真实生效的方法是<code>onApplicationEvent</code>，<code>ConfigFileApplicationListener</code>中的<code>onApplicationEvent</code>的源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationEnvironmentPreparedEvent) &#123;onApplicationEnvironmentPreparedEvent((ApplicationEnvironmentPreparedEvent) event);&#125;<span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationPreparedEvent) &#123;onApplicationPreparedEvent(event);&#125;&#125;</code></pre><p>通过<code>onApplicationEnvironmentPreparedEvent</code>=&gt;<code>postProcessEnvironment</code>方法</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessEnvironment</span><span class="hljs-params">(ConfigurableEnvironment environment,</span></span><span class="hljs-function"><span class="hljs-params">SpringApplication application)</span> </span>&#123;    <span class="hljs-comment">//将配置文件属性源添加到指定的环境</span>addPropertySources(environment, application.getResourceLoader());    <span class="hljs-comment">//设置spring.beaninfo.ignore变量</span>configureIgnoreBeanInfo(environment);    <span class="hljs-comment">//把环境绑定到SpringApplication。</span>bindToSpringApplication(environment, application);&#125;</code></pre><p>addPropertySources源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addPropertySources</span><span class="hljs-params">(ConfigurableEnvironment environment,</span></span><span class="hljs-function"><span class="hljs-params">ResourceLoader resourceLoader)</span> </span>&#123;RandomValuePropertySource.addToEnvironment(environment);<span class="hljs-keyword">new</span> Loader(environment, resourceLoader).load();&#125;</code></pre><p>通过上述代码，可以看出配置文件的接在就在<code>load</code>方法中。</p><h3 id="文件加载"><a href="#文件加载" class="headerlink" title="文件加载"></a>文件加载</h3><p>load方法源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.propertiesLoader = <span class="hljs-keyword">new</span> PropertySourcesLoader();<span class="hljs-keyword">this</span>.activatedProfiles = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">this</span>.profiles = Collections.asLifoQueue(<span class="hljs-keyword">new</span> LinkedList&lt;Profile&gt;());<span class="hljs-keyword">this</span>.processedProfiles = <span class="hljs-keyword">new</span> LinkedList&lt;Profile&gt;();<span class="hljs-comment">// Pre-existing active profiles set via Environment.setActiveProfiles()</span><span class="hljs-comment">// are additional profiles and config files are allowed to add more if</span><span class="hljs-comment">// they want to, so don't call addActiveProfiles() here.</span>Set&lt;Profile&gt; initialActiveProfiles = initializeActiveProfiles();<span class="hljs-keyword">this</span>.profiles.addAll(getUnprocessedActiveProfiles(initialActiveProfiles));<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.profiles.isEmpty()) &#123;<span class="hljs-keyword">for</span> (String defaultProfileName : <span class="hljs-keyword">this</span>.environment.getDefaultProfiles()) &#123;Profile defaultProfile = <span class="hljs-keyword">new</span> Profile(defaultProfileName, <span class="hljs-keyword">true</span>);<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.profiles.contains(defaultProfile)) &#123;<span class="hljs-keyword">this</span>.profiles.add(defaultProfile);&#125;&#125;&#125;<span class="hljs-comment">// The default profile for these purposes is represented as null. We add it</span><span class="hljs-comment">// last so that it is first out of the queue (active profiles will then</span><span class="hljs-comment">// override any settings in the defaults when the list is reversed later).</span>    <span class="hljs-comment">//翻译：下面一行代码的目的是将默认配置文件被表示为null。将null添加到最后，以便它首先从队列中取出（主动概要文件将在稍后颠倒列表时覆盖缺省情况下的任何设置）。</span><span class="hljs-keyword">this</span>.profiles.add(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">while</span> (!<span class="hljs-keyword">this</span>.profiles.isEmpty()) &#123;Profile profile = <span class="hljs-keyword">this</span>.profiles.poll();                 <span class="hljs-comment">//查找配置文件</span><span class="hljs-keyword">for</span> (String location : getSearchLocations()) &#123;<span class="hljs-keyword">if</span> (!location.endsWith(<span class="hljs-string">"/"</span>)) &#123;<span class="hljs-comment">// location is a filename already, so don't search for more</span><span class="hljs-comment">// filenames</span>load(location, <span class="hljs-keyword">null</span>, profile);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">for</span> (String name : getSearchNames()) &#123;load(location, name, profile);&#125;&#125;&#125;<span class="hljs-keyword">this</span>.processedProfiles.add(profile);&#125;addConfigurationProperties(<span class="hljs-keyword">this</span>.propertiesLoader.getPropertySources());&#125;</code></pre><h4 id="查找配置文件路径"><a href="#查找配置文件路径" class="headerlink" title="查找配置文件路径"></a>查找配置文件路径</h4><p>值得注意的是<code>getSearchLocations</code>方法，其源码如下：</p><pre><code class="hljs plain">private Set&lt;String&gt; getSearchLocations() &#123;Set&lt;String&gt; locations &#x3D; new LinkedHashSet&lt;String&gt;();&#x2F;&#x2F; User-configured settings take precedence, so we do them first&#x2F;&#x2F; 判断当前环境中是否有spring.config.location属性，如果有的话，则加载spring.config.location指定的配置文件if (this.environment.containsProperty(CONFIG_LOCATION_PROPERTY)) &#123;for (String path : asResolvedSet(this.environment.getProperty(CONFIG_LOCATION_PROPERTY), null)) &#123;if (!path.contains(&quot;$&quot;)) &#123;path &#x3D; StringUtils.cleanPath(path);if (!ResourceUtils.isUrl(path)) &#123;path &#x3D; ResourceUtils.FILE_URL_PREFIX + path;&#125;&#125;locations.add(path);&#125;&#125;&#x2F;&#x2F;添加默认的配置文件，按照类中定义的顺序加载文件：&#x2F;&#x2F;其顺序为：classpath:&#x2F;,classpath:&#x2F;config&#x2F;,file:.&#x2F;,file:.&#x2F;config&#x2F;locations.addAll(asResolvedSet(ConfigFileApplicationListener.this.searchLocations,DEFAULT_SEARCH_LOCATIONS));return locations;&#125;</code></pre><p>DEFAULT_SEARCH_LOCATIONS为文件默认加载顺序，其值为classpath:/,classpath:/config/,file:./,file:./config/，然后springboot会按照这几个位置的由后到前的顺序去加载。</p><p>通过查看<code>asResolvedSet</code>的源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Set&lt;String&gt; <span class="hljs-title">asResolvedSet</span><span class="hljs-params">(String value, String fallback)</span> </span>&#123;List&lt;String&gt; list = Arrays.asList(StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(value != <span class="hljs-keyword">null</span>? <span class="hljs-keyword">this</span>.environment.resolvePlaceholders(value) : fallback)));Collections.reverse(list);<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;(list);&#125;</code></pre><p>不难看出，这里对list进行了<code>Collections.reverse</code>(反转处理)。</p><p>即配置文件真正的加载顺序为：</p><ul><li>file:./config/</li><li>file:./</li><li>classpath:/config/</li><li>classpath:/</li><li>spring.config.location</li></ul><h4 id="正式加载配置文件"><a href="#正式加载配置文件" class="headerlink" title="正式加载配置文件"></a>正式加载配置文件</h4><p><code>load(String location, String name, Profile profile)</code>方法源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">(String location, String name, Profile profile)</span> </span>&#123;String group = <span class="hljs-string">"profile="</span> + (profile == <span class="hljs-keyword">null</span> ? <span class="hljs-string">""</span> : profile);<span class="hljs-keyword">if</span> (!StringUtils.hasText(name)) &#123;<span class="hljs-comment">// Try to load directly from the location</span>loadIntoGroup(group, location, profile);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// Search for a file with the given name</span><span class="hljs-keyword">for</span> (String ext : <span class="hljs-keyword">this</span>.propertiesLoader.getAllFileExtensions()) &#123;<span class="hljs-keyword">if</span> (profile != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-comment">// Try the profile-specific file</span>loadIntoGroup(group, location + name + <span class="hljs-string">"-"</span> + profile + <span class="hljs-string">"."</span> + ext,<span class="hljs-keyword">null</span>);<span class="hljs-keyword">for</span> (Profile processedProfile : <span class="hljs-keyword">this</span>.processedProfiles) &#123;<span class="hljs-keyword">if</span> (processedProfile != <span class="hljs-keyword">null</span>) &#123;loadIntoGroup(group, location + name + <span class="hljs-string">"-"</span>+ processedProfile + <span class="hljs-string">"."</span> + ext, profile);&#125;&#125;<span class="hljs-comment">// Sometimes people put "spring.profiles: dev" in</span><span class="hljs-comment">// application-dev.yml (gh-340). Arguably we should try and error</span><span class="hljs-comment">// out on that, but we can be kind and load it anyway.</span>loadIntoGroup(group, location + name + <span class="hljs-string">"-"</span> + profile + <span class="hljs-string">"."</span> + ext,profile);&#125;<span class="hljs-comment">// Also try the profile-specific section (if any) of the normal file</span>loadIntoGroup(group, location + name + <span class="hljs-string">"."</span> + ext, profile);&#125;&#125;&#125;</code></pre><p>在Load方法中，首先会通过<code>getAllFileExtensions</code>方法去组装所有可加载文件的扩展名，然后在通过<code>loadIntoGroup</code>方法加载配置文件，而我们跟读到<code>loadIntoGroup</code>中会发现其只执行了 <code>doLoadIntoGroup</code>方法， <code>doLoadIntoGroup</code>源码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> PropertySource&lt;?&gt; doLoadIntoGroup(String identifier, String location,Profile profile) <span class="hljs-keyword">throws</span> IOException &#123;Resource resource = <span class="hljs-keyword">this</span>.resourceLoader.getResource(location);PropertySource&lt;?&gt; propertySource = <span class="hljs-keyword">null</span>;StringBuilder msg = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span> &amp;&amp; resource.exists()) &#123;String name = <span class="hljs-string">"applicationConfig: ["</span> + location + <span class="hljs-string">"]"</span>;String group = <span class="hljs-string">"applicationConfig: ["</span> + identifier + <span class="hljs-string">"]"</span>;propertySource = <span class="hljs-keyword">this</span>.propertiesLoader.load(resource, group, name,(profile == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : profile.getName()));<span class="hljs-keyword">if</span> (propertySource != <span class="hljs-keyword">null</span>) &#123;msg.append(<span class="hljs-string">"Loaded "</span>);handleProfileProperties(propertySource);&#125;<span class="hljs-keyword">else</span> &#123;msg.append(<span class="hljs-string">"Skipped (empty) "</span>);&#125;&#125;<span class="hljs-keyword">else</span> &#123;msg.append(<span class="hljs-string">"Skipped "</span>);&#125;msg.append(<span class="hljs-string">"config file "</span>);msg.append(getResourceDescription(location, resource));<span class="hljs-keyword">if</span> (profile != <span class="hljs-keyword">null</span>) &#123;msg.append(<span class="hljs-string">" for profile "</span>).append(profile);&#125;<span class="hljs-keyword">if</span> (resource == <span class="hljs-keyword">null</span> || !resource.exists()) &#123;msg.append(<span class="hljs-string">" resource not found"</span>);<span class="hljs-keyword">this</span>.logger.trace(msg);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">this</span>.logger.debug(msg);&#125;<span class="hljs-keyword">return</span> propertySource;&#125;</code></pre><p>上诉源码中有一段核心的方法</p><pre><code class="hljs java">propertySource = <span class="hljs-keyword">this</span>.propertiesLoader.load(resource, group, name,(profile == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : profile.getName()));<span class="hljs-keyword">if</span> (propertySource != <span class="hljs-keyword">null</span>) &#123;msg.append(<span class="hljs-string">"Loaded "</span>);handleProfileProperties(propertySource);&#125;</code></pre><p>如果propertySource存在，则调用handleProfileProperties方法。</p><p>handleProfileProperties源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleProfileProperties</span><span class="hljs-params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;SpringProfiles springProfiles = bindSpringProfiles(propertySource);maybeActivateProfiles(springProfiles.getActiveProfiles());addProfiles(springProfiles.getIncludeProfiles());&#125;</code></pre><p>bindSpringProfiles源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SpringProfiles <span class="hljs-title">bindSpringProfiles</span><span class="hljs-params">(PropertySource&lt;?&gt; propertySource)</span> </span>&#123;MutablePropertySources propertySources = <span class="hljs-keyword">new</span> MutablePropertySources();propertySources.addFirst(propertySource);<span class="hljs-keyword">return</span> bindSpringProfiles(propertySources);&#125;</code></pre><p>bindSpringProfiles源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> SpringProfiles <span class="hljs-title">bindSpringProfiles</span><span class="hljs-params">(PropertySources propertySources)</span> </span>&#123;SpringProfiles springProfiles = <span class="hljs-keyword">new</span> SpringProfiles();RelaxedDataBinder dataBinder = <span class="hljs-keyword">new</span> RelaxedDataBinder(springProfiles,<span class="hljs-string">"spring.profiles"</span>);dataBinder.bind(<span class="hljs-keyword">new</span> PropertySourcesPropertyValues(propertySources, <span class="hljs-keyword">false</span>));springProfiles.setActive(resolvePlaceholders(springProfiles.getActive()));springProfiles.setInclude(resolvePlaceholders(springProfiles.getInclude()));<span class="hljs-keyword">return</span> springProfiles;&#125;</code></pre><p>通过这样一步一步的跟读，我们能发现配置文件的装载主要是通过<code>new PropertySourcesPropertyValues</code>来完成。</p><p>查看<code>PropertySourcesPropertyValues</code>的构造方法可以发现，它在装载值时调用了这样一个方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processPropertySource</span><span class="hljs-params">(PropertySource&lt;?&gt; source,</span></span><span class="hljs-function"><span class="hljs-params">PropertySourcesPropertyResolver resolver)</span> </span>&#123;<span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> CompositePropertySource) &#123;            <span class="hljs-comment">//加载复杂的属性</span>processCompositePropertySource((CompositePropertySource) source, resolver);&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (source <span class="hljs-keyword">instanceof</span> EnumerablePropertySource) &#123;            <span class="hljs-comment">//加载枚举类型</span>processEnumerablePropertySource((EnumerablePropertySource&lt;?&gt;) source,resolver, <span class="hljs-keyword">this</span>.includes);&#125;<span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">//加载非枚举类型，即简单类型</span>processNonEnumerablePropertySource(source, resolver);&#125;&#125;</code></pre><h4 id="配置文件键值对加载方法"><a href="#配置文件键值对加载方法" class="headerlink" title="配置文件键值对加载方法"></a>配置文件键值对加载方法</h4><blockquote><p>此处以<code>yml</code>文件加载为例</p></blockquote><p>配置文件键值对加载方法，org.springframework.beans.factory.config.YamlProcessor#process(MatchCallback callback, Yaml yaml, Resource resource) </p><p>在该方法中通过<code>yaml.loadAll(reader)</code>去加载文件的属性，然后在下方<code>process(asMap(object), callback)</code>通过<code>callback</code>进行键值对组装。</p><p>关键代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;    <span class="hljs-keyword">for</span> (Object object : yaml.loadAll(reader)) &#123;        <span class="hljs-keyword">if</span> (object != <span class="hljs-keyword">null</span> &amp;&amp; process(asMap(object), callback)) &#123;            count++;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resolutionMethod == ResolutionMethod.FIRST_FOUND) &#123;                <span class="hljs-keyword">break</span>;            &#125;        &#125;    &#125;    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;        logger.debug(<span class="hljs-string">"Loaded "</span> + count + <span class="hljs-string">" document"</span> + (count &gt; <span class="hljs-number">1</span> ? <span class="hljs-string">"s"</span> : <span class="hljs-string">""</span>) +                     <span class="hljs-string">" from YAML resource: "</span> + resource);    &#125;&#125;<span class="hljs-keyword">finally</span> &#123;    reader.close();&#125;</code></pre><p>该代码中的callback为org.springframework.boot.env.YamlPropertySourceLoader#process()中new的一个，源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">process</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">final</span> Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, Object&gt;();process(<span class="hljs-keyword">new</span> MatchCallback() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Properties properties, Map&lt;String, Object&gt; map)</span> </span>&#123;result.putAll(getFlattenedMap(map));&#125;&#125;);<span class="hljs-keyword">return</span> result;&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>配置文件的加载主要分为两个步骤：</p><ol><li>查找配置文件</li><li>加载配置文件中的值</li></ol><p>其中查找配置文件加载顺序为：</p><ul><li>file:./config/</li><li>file:./</li><li>classpath:/config/</li><li>classpath:/</li><li>spring.config.location</li></ul><p>spring.config.location为在启动SpringBoot时，为其指定的配置文件路径，</p><p>设置方式为：</p><pre><code class="hljs plain">java -jar demo.jar --Dspring.config.location&#x3D;application.yml</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot介绍</title>
    <link href="/2018/10/22/Java/spring/SpringBoot%E4%BB%8B%E7%BB%8D/"/>
    <url>/2018/10/22/Java/spring/SpringBoot%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h1><blockquote><p>Spring框架为我们提供了多种解决方案，但在使用它的时候总免不了进行导包、配置等操作。于是在2012年10月，有人提出了新需求，要求在Spring框架中支持无容器Web应用程序体系结构，即无不需要将项目打包后放置在中间件中，直接通过main方法引导的Spring容器内配置Web容器服务。 于是，2014年4月,SpringBoot正式发布。</p></blockquote><h2 id="SpringBoot四大特性"><a href="#SpringBoot四大特性" class="headerlink" title="SpringBoot四大特性"></a>SpringBoot四大特性</h2><p>在Spring官网这样说到：</p><p>SpringBoot可以轻松创建一个独立的、基于昌平级别的Spring应用程序，我们可以不依赖服务器中间件，直接运行程序。我们的目标是：</p><ul><li>为所有Spring开发提供一个从根本上更快，且随处可得的入门体验。</li><li>开箱即用，但通过不采用默认设置可以快速摆脱这种方式。</li><li>提供一系列大型项目常用的非功能性特征，比如：内嵌服务器，安全，指标，健康检测，外部化配置。</li><li>绝对没有代码生成，也不需要XML配置。</li></ul><p>在我看来SpringBoot其实并不是一个新的框架，它更像是一个总指挥，能够按照我的需求去引入框架，比如，我需要使用SpringMVC，对于SpringBoot而言，我只需要引入一个spring-boot-starter-web，它就会默认去帮我把SpringMVC，tomcat等等都引入到我的工程里。</p><p>SpringBoot主要提供了四个特性，也正是这四个特性才能改变开发Spring引用程序的方式：</p><ul><li>SpringBoot Starter：它将常用的依赖分组进行了整合，将其合并到一个依赖中，这样可以一次性添加所有的依赖到项目中，注意，这里一般指的是Maven或Gradle。</li><li>自动配置：SpringBoot的自动配置特性利用了Spring4对条件华配置的支持，合理地推测应用所需的Bean并自动化配置他们。</li><li>命令行接口（Command-line interface,即<code>CLI</code>）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发。</li><li>Actuator：它为SprigBoot应用添加了一定的管理特性。</li></ul><h2 id="SpringBoot优缺点"><a href="#SpringBoot优缺点" class="headerlink" title="SpringBoot优缺点"></a>SpringBoot优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>SpringBoot的优点其实可以看做是基于上文四点衍生出来的。</p><ul><li>简化依赖，避免了我们手动去配置Maven/Gradle依赖，仅一个starter就能够搞定。</li><li>利用starter可以达到自动化配置的效果。</li><li>去除了大量的XML配置文件，采用全注解的方式。</li><li>舍弃外部的服务器中间件，可以利用其内嵌的tomcat/jetty直接运行。</li><li>使用CLI可以快速构建SpringBoot程序</li><li>拥有SpringCloud微服务解决方案</li></ul><p>在SpringBoot1.0正式发布之后，2014年年底，Spring团队基于SpringBoot推出SpringCloud，提供一套完整的微服务解决方案。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>升级难，不能友好的兼容老版本的SpringFramework项目。对于某些项目可能会存在升级的情况，即将老的框架升级为新框架，但如果你想升级使用SpringBoot，我想这应该是一个非常困难的过程。</li><li>配置服务器服务麻烦。</li><li>增量更新文件麻烦，因为是jar，如果遇见需要更新包类的一个js、html等文件，则需要先解压后再替换，最后再压缩。</li></ul><h2 id="SpringBoot2-0"><a href="#SpringBoot2-0" class="headerlink" title="SpringBoot2.0"></a>SpringBoot2.0</h2><p>SpringBoot2.0是2018年3月发布的版本，该版本基于Spring Framework5.0，与SpringFramework5.0对应的是，SpringBoot2.0同样支持的最低版本为Java8，同时也支持Java9。</p><p><strong>SpringBoot2.0新特性：</strong></p><ul><li>修改默认数据库连接池，从tomcat改为HikariCP。</li><li>优化NOSQL（Redis等）集成方式。</li><li>升级内嵌容器（Tomcat、Jetty）。</li><li>适配Spring5.0的WebFlux。</li><li>增加Quartz自动配置，增加Starter。</li></ul><p>当然，对于Spring2.0的新特性远不止于此。本文主要列举了几个较为明显且常见的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot启动过程源码分析</title>
    <link href="/2018/10/22/Java/spring/SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2018/10/22/Java/spring/SpringBoot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot启动过程源码分析"><a href="#SpringBoot启动过程源码分析" class="headerlink" title="SpringBoot启动过程源码分析"></a>SpringBoot启动过程源码分析</h1><blockquote><p>随着SpringBoot的热度越来越高，现在企业中对SpringBoot的使用也越来越频繁，而SpringBoot也没让我们失望，它极大的提高了编程的快捷性，今天就SpringBoot(1.5.8.RELEASE)启动源码来看看SpringBoot是如何避繁就简的吧。</p></blockquote><h2 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h2><p>SpringBoot为我们提供了一个简单快捷的启动方式，当我们需要更多功能时，只需要通过在<code>DemoApplication</code>类上增加相应的注解即可：</p><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<span class="hljs-meta">@SpringBootApplication</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplication</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        SpringApplication.run(DemoApplication<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span>)</span>;    &#125;&#125;</code></pre><p>此处简单描述一下<code>@SpringBootApplication</code>注解：</p><p>此注解注解在Spring Boot的XXXApplication类（有main函数，程序启动的入口）上，其结合了三个注解: @Configuration, @EnableAutoConfiguration 和 @ComponentScan。 </p><p><strong>@Configuration</strong>：</p><p> <code>@Configuration</code> 中所有带 <code>@Bean</code> 注解的方法都会被动态代理，因此调用该方法返回的都是同一个实例。 </p><p><strong>@EnableAutoConfiguration</strong>：</p><p>使用该注解后，Spring Boot将尝试根据项目引入的依赖来配置程序 。</p><p><strong>@ComponentScan</strong>：</p><p>指定要扫描的包，以及扫描的条件，默认扫描@ComponentScan注解所在类的同级类和同级目录下的所有类。</p><p>另外官方具有很详细的说明，请查阅：<a href="https://docs.spring.io/spring-framework/docs/4.3.5.RELEASE/javadoc-api/org/springframework/context/annotation/" target="_blank" rel="noopener">https://docs.spring.io/spring-framework/docs/4.3.5.RELEASE/javadoc-api/org/springframework/context/annotation/</a></p><h2 id="SpringApplication-run方法"><a href="#SpringApplication-run方法" class="headerlink" title="SpringApplication.run方法"></a>SpringApplication.run方法</h2><p>通过跟读代码发现，SpringApplication.run方法主要分为两个步骤，<code>new SpringApplication(sources)</code>,<code>run</code>：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Static helper that can be used to run a &#123;<span class="hljs-doctag">@link</span> SpringApplication&#125; from the</span><span class="hljs-comment"> * specified sources using default settings and user supplied arguments.</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sources the sources to load</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args the application arguments (usually passed from a Java main method)</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the running &#123;<span class="hljs-doctag">@link</span> ApplicationContext&#125;</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(Object[] sources, String[] args)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SpringApplication(sources).run(args);&#125;</code></pre><h3 id="new-SpringApplication-sources"><a href="#new-SpringApplication-sources" class="headerlink" title="new SpringApplication(sources)"></a>new SpringApplication(sources)</h3><p>首先看看<code>new SpringApplication(sources)</code>方法</p><p>通过调试发现，该方法的核心就是<code>initialize</code>，其源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(Object[] sources)</span> </span>&#123;<span class="hljs-keyword">if</span> (sources != <span class="hljs-keyword">null</span> &amp;&amp; sources.length &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-keyword">this</span>.sources.addAll(Arrays.asList(sources));&#125;    <span class="hljs-comment">//推论当前是否为Web运行环境</span><span class="hljs-keyword">this</span>.webEnvironment = deduceWebEnvironment();setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;    <span class="hljs-comment">//初始化监听器</span>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener<span class="hljs-class">.<span class="hljs-keyword">class</span>))</span>;<span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();&#125;</code></pre><p>其中比较疑惑的是<code>deduceWebEnvironment</code>方法，因为<code>WEB_ENVIRONMENT_CLASSES</code>的值是不变的，所以该方法返回值恒为<code>true</code>。</p><p><code>setListeners</code>方法主要是将<code>getSpringFactoriesInstances</code>返回的实例加入到<code>listeners</code>集合中。</p><p><code>getSpringFactoriesInstances</code>源码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> &lt;T&gt; Collection&lt;? extends T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type,Class&lt;?&gt;[] parameterTypes, Object... args) &#123;ClassLoader classLoader = Thread.currentThread().getContextClassLoader();<span class="hljs-comment">// Use names and ensure unique to protect against duplicates</span>    <span class="hljs-comment">//加载出需要实例化的类</span>Set&lt;String&gt; names = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));    <span class="hljs-comment">//创建相应的实例</span>List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,classLoader, args, names);AnnotationAwareOrderComparator.sort(instances);<span class="hljs-keyword">return</span> instances;&#125;</code></pre><p><code>SpringFactoriesLoader.loadFactoryNames</code>源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;String factoryClassName = factoryClass.getName();<span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//获取jar包中的资源，其中FACTORIES_RESOURCE_LOCATION的值为META-INF/spring.factories</span>Enumeration&lt;URL&gt; urls = (classLoader != <span class="hljs-keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;URL url = urls.nextElement();Properties properties = PropertiesLoaderUtils.loadProperties(<span class="hljs-keyword">new</span> UrlResource(url));String factoryClassNames = properties.getProperty(factoryClassName);result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));&#125;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Unable to load ["</span> + factoryClass.getName() +<span class="hljs-string">"] factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">"]"</span>, ex);&#125;&#125;</code></pre><p>通过上诉代码中的<code>classLoader.getResources(FACTORIES_RESOURCE_LOCATION)</code>代码，我们可以看出SpringBoot去加载了jar包中META-INF/spring.factories文件，那么这个文件又具有怎样的作用呢？</p><p>官方给出的说明是：</p><p>使用给定的类加载器从META-INF / spring.factories加载给定类型的工厂实现的完全限定类名。 </p><p>翻阅了<code>spring-test-4.3.12.RELEASE</code>下的<code>spring.factories</code>文件，其源码如下：</p><pre><code class="hljs xml"># Default TestExecutionListeners for the Spring TestContext Framework#org.springframework.test.context.TestExecutionListener = \org.springframework.test.context.web.ServletTestExecutionListener,\org.springframework.test.context.support.DirtiesContextBeforeModesTestExecutionListener,\org.springframework.test.context.support.DependencyInjectionTestExecutionListener,\org.springframework.test.context.support.DirtiesContextTestExecutionListener,\org.springframework.test.context.transaction.TransactionalTestExecutionListener,\org.springframework.test.context.jdbc.SqlScriptsTestExecutionListener# Default ContextCustomizerFactory implementations for the Spring TestContext Framework#org.springframework.test.context.ContextCustomizerFactory = \org.springframework.test.context.web.socket.MockServerContainerContextCustomizerFactory</code></pre><p>不难发现，<code>spring.factories</code>中配置的这些类，主要作用是告诉Spring Boot这个stareter所需要加载的那些xxxAutoConfiguration类，也就是你真正的要自动注册的那些bean或功能。然后，我们实现一个spring.factories指定的类，标上@Configuration注解，一个starter就定义完了。</p><p>如果想看一下SpringBoot启动过程中都加载了那些spring.factories文件，可以写这样一个测试类：</p><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringTest</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String FACTORIES_RESOURCE_LOCATION = <span class="hljs-string">"META-INF/spring.factories"</span>;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-comment">//EurekaServerApp 应用程序入口</span>            EurekaServerApp app = <span class="hljs-keyword">new</span> EurekaServerApp();            Enumeration&lt;URL&gt; urls =app.getClass().getClassLoader().getResources(FACTORIES_RESOURCE_LOCATION);            <span class="hljs-keyword">while</span>(urls.hasMoreElements())&#123;                URL url = urls.nextElement();                System.out.println(url.toString());            &#125;        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>其打印结果如下：</p><pre><code class="hljs plain">jar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;cloud&#x2F;spring-cloud-starter-eureka-server&#x2F;1.4.0.RELEASE&#x2F;spring-cloud-starter-eureka-server-1.4.0.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;cloud&#x2F;spring-cloud-context&#x2F;1.3.0.RELEASE&#x2F;spring-cloud-context-1.3.0.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;cloud&#x2F;spring-cloud-commons&#x2F;1.3.0.RELEASE&#x2F;spring-cloud-commons-1.3.0.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;cloud&#x2F;spring-cloud-netflix-eureka-server&#x2F;1.4.0.RELEASE&#x2F;spring-cloud-netflix-eureka-server-1.4.0.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;boot&#x2F;spring-boot-actuator&#x2F;1.5.8.RELEASE&#x2F;spring-boot-actuator-1.5.8.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;cloud&#x2F;spring-cloud-netflix-core&#x2F;1.4.0.RELEASE&#x2F;spring-cloud-netflix-core-1.4.0.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;cloud&#x2F;spring-cloud-netflix-eureka-client&#x2F;1.4.0.RELEASE&#x2F;spring-cloud-netflix-eureka-client-1.4.0.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;boot&#x2F;spring-boot-test&#x2F;1.5.8.RELEASE&#x2F;spring-boot-test-1.5.8.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;boot&#x2F;spring-boot&#x2F;1.5.8.RELEASE&#x2F;spring-boot-1.5.8.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;spring-beans&#x2F;4.3.12.RELEASE&#x2F;spring-beans-4.3.12.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;boot&#x2F;spring-boot-test-autoconfigure&#x2F;1.5.8.RELEASE&#x2F;spring-boot-test-autoconfigure-1.5.8.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;boot&#x2F;spring-boot-autoconfigure&#x2F;1.5.8.RELEASE&#x2F;spring-boot-autoconfigure-1.5.8.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factoriesjar:file:&#x2F;D:&#x2F;develop&#x2F;soft&#x2F;maven&#x2F;repo&#x2F;repositories&#x2F;org&#x2F;springframework&#x2F;spring-test&#x2F;4.3.12.RELEASE&#x2F;spring-test-4.3.12.RELEASE.jar!&#x2F;META-INF&#x2F;spring.factories</code></pre><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><p>在run方法中，首先定义了一个<code>StopWatch</code>来标记启动时间。</p><p>源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;    <span class="hljs-comment">//初始化一个计时器</span>StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();stopWatch.start();ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;FailureAnalyzers analyzers = <span class="hljs-keyword">null</span>;    <span class="hljs-comment">//设置java.awt.headless系统属性为true。</span>configureHeadlessProperty();    <span class="hljs-comment">//获取SpringApplicationRunListeners</span>SpringApplicationRunListeners listeners = getRunListeners(args);<span class="hljs-comment">//开始执行监听器</span>    listeners.starting();<span class="hljs-keyword">try</span> &#123;ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);             <span class="hljs-comment">//在上下文创建之前准备环境</span>ConfigurableEnvironment environment = prepareEnvironment(listeners,applicationArguments);             <span class="hljs-comment">//准备Banner打印器</span>Banner printedBanner = printBanner(environment);             <span class="hljs-comment">//创建上下文</span>context = createApplicationContext();analyzers = <span class="hljs-keyword">new</span> FailureAnalyzers(context);<span class="hljs-comment">//上下文前置处理</span>             prepareContext(context, environment, listeners, applicationArguments,printedBanner);             <span class="hljs-comment">//刷新上下文</span>refreshContext(context);             <span class="hljs-comment">//上下文后置处理</span>afterRefresh(context, applicationArguments);             <span class="hljs-comment">//发出结束执行的事件</span>listeners.finished(context, <span class="hljs-keyword">null</span>);             <span class="hljs-comment">//停止计时器</span>stopWatch.stop();<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);&#125;<span class="hljs-keyword">return</span> context;&#125;<span class="hljs-keyword">catch</span> (Throwable ex) &#123;handleRunFailure(context, listeners, analyzers, ex);<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);&#125;&#125;</code></pre><h4 id="configureHeadlessProperty"><a href="#configureHeadlessProperty" class="headerlink" title="configureHeadlessProperty"></a>configureHeadlessProperty</h4><p>查询该方法源码，发现其是将<code>java.awt.headless</code>的值设置为<code>true</code>，查阅资料发现<code>Headless</code>模式是在缺少显示屏、键盘或者鼠标是的系统配置，因为服务器（如提供Web服务的主机）往往可能缺少前述设备，但又需要使用他们提供的功能，生成相应的数据，以提供给客户端（如浏览器所在的配有相关的显示设备)、键盘和鼠标)的主机），所以需要依靠系统的计算能力模拟出这些特性来，即设置其值为<code>true</code>。</p><h4 id="getRunListeners"><a href="#getRunListeners" class="headerlink" title="getRunListeners"></a>getRunListeners</h4><p>获取SpringApplicationRunListeners，这里的实现方式与上文中的<code>SpringFactoriesLoader.loadFactoryNames</code>类似。</p><h4 id="listeners-starting"><a href="#listeners-starting" class="headerlink" title="listeners.starting"></a>listeners.starting</h4><blockquote><p>该方法其实是遍历在最初加入进去的监听器，然后分别执行各监听器对应的<code>staring</code>方法</p></blockquote><p>通过下面这个类图，我们不难发现<code>listeners.starting</code>最后执行的是<code>multicastEvent</code>方法。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/EventPublishingRunListener.png" srcset="/img/loading.gif" alt="EventPublishingRunListener"></p><p> <code>multicastEvent</code>方法源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;Executor executor = getTaskExecutor();<span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;invokeListener(listener, event);&#125;&#125;);&#125;<span class="hljs-keyword">else</span> &#123;invokeListener(listener, event);&#125;&#125;&#125;</code></pre><p>通过上述源码继续我们依次往下跟读，其方法顺序如下<code>invokeListener</code>=&gt;<code>doInvokeListener</code>=&gt;<code>onApplicationEvent</code>，<code>onApplicationEvent</code>方法则是每个监听器真实是生效的方法。</p><h4 id="prepareEnvironment"><a href="#prepareEnvironment" class="headerlink" title="prepareEnvironment"></a>prepareEnvironment</h4><p>该方法会根据上文中获取的<code>SpringApplicationRunListeners</code>以及springboot启动时传入的参数来构建启动环境。</p><p>prepareEnvironment源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ConfigurableEnvironment <span class="hljs-title">prepareEnvironment</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">SpringApplicationRunListeners listeners,</span></span><span class="hljs-function"><span class="hljs-params">ApplicationArguments applicationArguments)</span> </span>&#123;<span class="hljs-comment">// Create and configure the environment</span>ConfigurableEnvironment environment = getOrCreateEnvironment();configureEnvironment(environment, applicationArguments.getSourceArgs());    <span class="hljs-comment">//在上下文创建之前准备环境</span>listeners.environmentPrepared(environment);<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.webEnvironment) &#123;environment = <span class="hljs-keyword">new</span> EnvironmentConverter(getClassLoader()).convertToStandardEnvironmentIfNecessary(environment);&#125;<span class="hljs-keyword">return</span> environment;&#125;</code></pre><p><strong>configureEnvironment</strong></p><p>查看该方法不难发现该方法主要是通过<code>configurePropertySources</code>配置Property Sources，通过<code>configureProfiles</code>配置Profiles。</p><h4 id="createApplicationContext"><a href="#createApplicationContext" class="headerlink" title="createApplicationContext"></a>createApplicationContext</h4><blockquote><p>创建Spring上下文</p></blockquote><p>这个方法有点的源码很简单，就实例化了一个<code>org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext</code>。但是如果想要看懂创建上下的实现逻辑，需要去研究spring的源码，这里就不做描述了。</p><p>我在idea中查看了一下这个<code>AnnotationConfigEmbeddedWebApplicationContext</code>类的继承关系，现将该图放置在下方。后面有时间再去研究吧。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/AnnotationConfigEmbeddedWebApplicationContext.png" srcset="/img/loading.gif" alt="AnnotationConfigEmbeddedWebApplicationContext"></p><h4 id="prepareContext上下文前置处理"><a href="#prepareContext上下文前置处理" class="headerlink" title="prepareContext上下文前置处理"></a>prepareContext上下文前置处理</h4><p>源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareContext</span><span class="hljs-params">(ConfigurableApplicationContext context,</span></span><span class="hljs-function"><span class="hljs-params">ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,</span></span><span class="hljs-function"><span class="hljs-params">ApplicationArguments applicationArguments, Banner printedBanner)</span> </span>&#123;    <span class="hljs-comment">//将上下文与环境关联上</span>context.setEnvironment(environment);<span class="hljs-comment">//申请任何相关的后期处理ApplicationContext</span>    <span class="hljs-comment">//将一些生成器加入到spring上下文中</span>    postProcessApplicationContext(context);    <span class="hljs-comment">//初始化，ApplicationContextInitializer在刷新之前将任何应用于上下文。</span>applyInitializers(context);listeners.contextPrepared(context);<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;             <span class="hljs-comment">//记录启动信息</span>logStartupInfo(context.getParent() == <span class="hljs-keyword">null</span>);             <span class="hljs-comment">//记录活动的配置文件信息</span>logStartupProfileInfo(context);&#125;<span class="hljs-comment">// Add boot specific singleton beans</span>context.getBeanFactory().registerSingleton(<span class="hljs-string">"springApplicationArguments"</span>,applicationArguments);<span class="hljs-keyword">if</span> (printedBanner != <span class="hljs-keyword">null</span>) &#123;context.getBeanFactory().registerSingleton(<span class="hljs-string">"springBootBanner"</span>, printedBanner);&#125;<span class="hljs-comment">// Load the sources</span>Set&lt;Object&gt; sources = getSources();Assert.notEmpty(sources, <span class="hljs-string">"Sources must not be empty"</span>);load(context, sources.toArray(<span class="hljs-keyword">new</span> Object[sources.size()]));listeners.contextLoaded(context);&#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>SpringBoot启动主要分为两个步骤：</p><ol><li>SpringApplication实例的构建过程：其中最为主要的是通过META-INF/spring.factories加载监听器。</li><li>SpringApplication实例run方法的执行过程：其中主要有一个SpringApplicationRunListeners的概念，它作为Spring Boot容器初始化时各阶段事件的中转器，将事件派发给感兴趣的Listeners(在SpringApplication实例的构建过程中得到的)。这些阶段性事件将容器的初始化过程给构造起来，提供了比较强大的可扩展性。 </li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>SpringBoot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringFramework历史版本</title>
    <link href="/2018/10/18/Java/spring/SpringFramework%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/"/>
    <url>/2018/10/18/Java/spring/SpringFramework%E5%8E%86%E5%8F%B2%E7%89%88%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringFramework历史版本"><a href="#SpringFramework历史版本" class="headerlink" title="SpringFramework历史版本"></a>SpringFramework历史版本</h1><blockquote><p>对于Spring而言，迄今已有14年历史了，版本也到达了5.0，作为JavaWEB开发领域的常青树，现在Spirng已不再简单是一个框架了，在Spring的项目中主要有：SpringFramework(也就是我们常说的Spring，主要有IOC、AOP等)、SpringBoot、SpringCloud、SpringData、SpringIO等等。详情请见官网：<a href="spring.io/projects">spring.io/projects</a></p><p>本文主要描述SpringFrameworkd、SpringBoot、SpringCloud版本历史</p><p>SpringFramework，一下简称Spring</p><p>Spring框架是由大量的模块组成，其中主要包括：Core、Beans、Context、AOP、Web、ORM、JDBC等等。在这些组件中，主要以Core、Beans、Context为核心，Spring框架通过该组件实现依赖注入与控制反转，使得设计和测试松散耦合，极大提高了编程效率。</p></blockquote><h2 id="Spring版本情况"><a href="#Spring版本情况" class="headerlink" title="Spring版本情况"></a>Spring版本情况</h2><h3 id="Spring雏形"><a href="#Spring雏形" class="headerlink" title="Spring雏形"></a>Spring雏形</h3><blockquote><p>2002年10月,Rod Johnson发布《Expert One-on-One J2EE设计和开发》一书</p></blockquote><p>在Spring框架面世之前，当时在JavaEE开发中基本都是使用EJB框架进行，但可能是EJB设计太过庞大、繁重，又或是EJB发展的进度追不上时代的潮流，在2002年10月，Rod Johnson撰写了一本名为《Expert One-on-One J2EE设计和开发》的书。本书主要概括了当时Java企业应用程序开发的现状已经指出了JavaEE和EJB框架的缺陷，并且本书基于普通Java类和依赖注入提出了更为简单的解决方案。</p><h3 id="Spring1-0"><a href="#Spring1-0" class="headerlink" title="Spring1.0"></a>Spring1.0</h3><blockquote><p>2004年3月，Spring1.0发布</p></blockquote><p>2003年6月，Spring Framework 第一次以 Apache 2.0 许可证下发布0.9版本，2004年3月，Spring1.0正式发布</p><p>对于Spring1.0，其源码只有一个包，在该包中包含了aop、beans、context、core、jdbc、orm等。对于此时的版本，Spring1.0仅支持XML配置的方式。</p><h3 id="Spring2-0"><a href="#Spring2-0" class="headerlink" title="Spring2.0"></a>Spring2.0</h3><blockquote><p>2006年10 月，Spring2.0发布</p></blockquote><p>对于2.0，Spring主要增加了对注解的支持，实现了基于注解的配置。</p><p>在2007年11月，发布Spring2.5，该版本具备的特性有：</p><ul><li>添加可扩展的XML配置功能，用于简化XML配置</li><li>支持Java5</li><li>添加额外的IOC容器扩展点，支持动态语言（如groovy，aop增强功能和新的bean范围 ）</li></ul><h3 id="Spring3-0"><a href="#Spring3-0" class="headerlink" title="Spring3.0"></a>Spring3.0</h3><blockquote><p>2009年12月，Spring3.0发布</p></blockquote><p>Spring3.0主要具有的特性有：</p><ul><li>模块重组系统</li><li>支持Spring表达式语言（Spring Expression）</li><li>基于Java的Bean配置（JavaConfig）</li><li>支持嵌入式数据库：HSQL、H2等</li><li>支持REST</li><li>支持Java6</li></ul><h3 id="Spring4-0"><a href="#Spring4-0" class="headerlink" title="Spring4.0"></a>Spring4.0</h3><blockquote><p>2013年12月，发布Spring4.0</p></blockquote><p>对于Spring4.0是Spring版本历史上的一重大升级。其特性为：</p><ul><li>全面支持Java8<ul><li>支持Lambda表达式</li><li>支持Java8的时间和日期API</li><li>支持重复注解</li><li>支持Java8的Optional</li></ul></li><li>核心容器增强<ul><li>增加泛型依赖注入</li><li>增加Map依赖注入</li><li>增加List依赖注入</li><li>支持lazy注解配置懒加载</li><li>支持Condition条件注解</li><li>CGLIB动态代理增强</li></ul></li><li>支持基于GroovyDSL定义Bean</li><li>Web增强<ul><li>增强SpringMVC，基于Servlet3.0开发</li><li>提供RestController注解</li><li>提供AsyncRestTemplate支持客户端的异步无阻塞请求</li></ul></li><li>增加对WebSocket的支持</li></ul><h3 id="Spring5-0"><a href="#Spring5-0" class="headerlink" title="Spring5.0"></a>Spring5.0</h3><blockquote><p>2017年9月，Spring5.0发布</p></blockquote><p>Spring5.0特性如下：</p><ul><li>升级到Java8、JavaEE7<ul><li>废弃低版本，将Java8、JavaEE 7作为最低版本要求</li><li>兼容Java9</li><li>兼容JavaEE8</li></ul></li><li>反应式编程模型，增加WebFlux模块</li><li>升级SpringMVC，增加对最新的API（Jackson等）的支持</li><li>增加函数式编程模式</li><li>重构源码，部分功能使用Lambda表达式实现</li></ul><h2 id="Spring框架子项目"><a href="#Spring框架子项目" class="headerlink" title="Spring框架子项目"></a>Spring框架子项目</h2><p>对于Spring而言，Spring框架在其生态环境下极其重要的一环。而在Spring框架中所含的子项目也多不胜数，下面贴一张互联网上的图片对每个子项目做个简单介绍。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/springchild.jpeg" srcset="/img/loading.gif" alt="springchild.jpeg"></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring中的设计模式</title>
    <link href="/2018/10/18/Java/spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/10/18/Java/spring/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring中的设计模式"><a href="#Spring中的设计模式" class="headerlink" title="Spring中的设计模式"></a>Spring中的设计模式</h1><blockquote><p>首先应该明确什么是设计模式，设计模式是由软件的先辈们总结出的一套可以反复使用的经验，它可以提高代码的可重用性，增强系统的可维护性，以及解决一系列的复杂问题。</p><p>设计模式在程序开发中扮演着极其重要的角色，良好、正确的设计模式的使用能够让我们程序员在扩展、维护、理解等方面有着更为优越的性能。</p><p>在Spring的开发中，用到了许多的设计模式，比如工厂模式、单例模式、模板模式、代理模式等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP原理</title>
    <link href="/2018/10/18/Java/spring/SpringAOP%E5%8E%9F%E7%90%86/"/>
    <url>/2018/10/18/Java/spring/SpringAOP%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringAOP原理"><a href="#SpringAOP原理" class="headerlink" title="SpringAOP原理"></a>SpringAOP原理</h1><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>在熟悉AOP之前我们应该了解一个概念：代理。</p><p>代理又分静态代理与动态代理。顾名思义，静态代理的代理关系在编译时就确定了 ，而动态代理的代理关系是在编译期确定的。 </p><p>动态代理是Java语言中非常经典的一种设计模式，也是所有设计模式中最难理解的一种。</p><p>常见的动态代理为JDK原生动态代理和CGLIB动态代理。 </p><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p> 静态代理实现很简单，但此类代理仅适用于代理类较少的情况。</p></blockquote><p>首先定义个接口Hello.</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Hello</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String name)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Hello</span></span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String str)</span> </span>&#123;        System.out.println(<span class="hljs-string">"Hello: "</span> + str);    &#125;&#125;</code></pre><p>静态代理类：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Hello</span></span>&#123;<span class="hljs-keyword">private</span> Hello hello = <span class="hljs-keyword">new</span> HelloImpl();    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String str)</span> </span>&#123;        before();        hello.say(str);        after();    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"before"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"after"</span>);    &#125;&#125;</code></pre><p>使用HelloProxy类实现了Hello接口，并且在勾账方法中new 一个HelloImpl类的实例，然后在HelloProxy的say方法中调用hello对象的say方法，然后在其前后分别加上before与after方法，然后可在这两个方法中去实现自己的逻辑，即可实现对HelloImpl的代理了。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>对于上述静态代理的实例，如果我们使用动态代理，可以这样做：</p><p>在JDK的 java.lang.reflect包下有个Proxy类它正是构造代理类的入口。在Proxy类中有一个创建代理对象的方法：newProxyInstance。</p><p>Proxy.newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler handler) </p><p>该方法的三个参数的意义如下：</p><ul><li>loader：指定代理的类的加载器</li><li>interfaces：代理对象需要实现的接口，可指定多个</li><li>handler：方法调用的实际处理者，代理对象的方法调用都会转发到这里</li></ul><p>对于上面的例子，我们只需要定义一个类去实现InvocationHandler接口即可。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloInvocationHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;    <span class="hljs-comment">/**目标对象*/</span>    <span class="hljs-keyword">private</span> Object target;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HelloInvocationHandler</span><span class="hljs-params">(Object target)</span> </span>&#123;        <span class="hljs-keyword">this</span>.target = target;    &#125;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> (T)Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"before"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"after"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        before();        Object result = method.invoke(target, args);        after();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        HelloInvocationHandler handler = <span class="hljs-keyword">new</span> HelloInvocationHandler(<span class="hljs-keyword">new</span> HelloImpl());        Hello proxy = handler.getProxy();        proxy.say(<span class="hljs-string">"World"</span>);    &#125;&#125;</code></pre><p>其打印结果如下：</p><pre><code class="hljs plain">beforehelloWorldafter</code></pre><p>关于动态代理的总结：</p><ul><li>代理对象是在程序运行时产生的，而不是编译期</li><li>对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法</li><li>JDK动态代理是基于接口实现的</li></ul><p>JDK动态代理虽然为我们提供了较为友好的代理方式，但是JDK动态代理是基于接口实现的，如果对象没有实现接口，那么就不能使用JDK动态代理了。</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>CGLIB(<em>Code Generation Library</em>)是一个基于ASM的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB通过继承方式实现代理，它主要是在运行期间动态生成字节码，从而动态生成代理类。</p><p>由于CGLIB是第三方开源项目，所以在使用之前，我们需要引入JAR，对于Maven项目而言只需要在POM文件中加入依赖即可：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>首先编写一个CGLIB的拦截器</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CGLIBProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span></span>&#123;        <span class="hljs-keyword">return</span> (T) Enhancer.create(clazz,<span class="hljs-keyword">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"before"</span>);    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;        System.out.println(<span class="hljs-string">"after"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object object, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        before();        Object result = methodProxy.invokeSuper(object, args);        after();        <span class="hljs-keyword">return</span> result;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        CGLIBProxy proxy = <span class="hljs-keyword">new</span> CGLIBProxy();        HelloImpl hello = proxy.getProxy(HelloImpl<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        hello.say(<span class="hljs-string">"World BY CGLIB"</span>);    &#125;&#125;</code></pre><p>执行结果如下：</p><pre><code class="hljs plain">beforehelloWorld BY CGLIBafter</code></pre><p>intercept方法参数说明:</p><ul><li>object：代理的对象</li><li>method：代理对象的方法信息</li><li>args：待执行方法的参数</li><li>methodProxy：调用方法代理对象</li></ul><p>其中，intercept方法为我们传入MethodProxy变量，顾名思义，方法代理，也就是说CGLIB提供的代理方法是方法级别的代理，也就是对方法拦截（方法拦截器）。但是CGLIB无法代理final修饰的方法。</p><h2 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 </p><p>AOP一般拥有的功能为：</p><ul><li>前置增强，Before事件</li><li>后置增强，After事件</li><li>环绕增强，Around事件</li></ul><p>所谓的Around事件其实就是在方法前后分别加上Before与After事件。</p><h2 id="AspectJ-框架"><a href="#AspectJ-框架" class="headerlink" title="AspectJ 框架"></a>AspectJ 框架</h2><p>AspectJ 是一个基于 Java 语言的 AOP 框架，提供了强大的 AOP 功能。</p><p>AspectJ 是 Java 语言的一个 AOP 实现，其主要包括两个部分：第一个部分定义了如何表达、定义 AOP 编程中的语法规范，通过这套语言规范，我们可以方便地用 AOP 来解决 Java 语言中存在的交叉关注点问题；另一个部分是工具部分，包括编译器、调试工具等。 </p><p>对于AspectJ需要到官网下载对应的插件，如果想要支持AspectJ，就必须在源代码中加入AspectJ关键字(如下面的代码块)，然后通过AspectJ对源代码进行编译。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> aspect TxAspect &#123; <span class="hljs-comment">// 指定执行 Hello.sayHello() 方法时执行下面代码块</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">()</span>:<span class="hljs-title">call</span><span class="hljs-params">(<span class="hljs-keyword">void</span> Hello.sayHello()</span>)</span>&#123;System.out.println(<span class="hljs-string">"开始事务 ..."</span>);<span class="hljs-comment">//proceed() 代表回调原来指定的方法</span>proceed();System.out.println(<span class="hljs-string">"事务结束 ..."</span>);&#125;&#125;</code></pre><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>Spring AOP与 AspectJ 相同的是，Spring AOP 同样需要对目标类进行增强，也就是生成新的 AOP 代理类；与 AspectJ 不同的是，Spring AOP 无需使用任何特殊命令对 Java 源代码进行编译，它采用运行时动态地、在内存中临时生成“代理类”的方式来生成 AOP 代理。 </p><p>Spring  AOP中使用了与AspectJ相同的注解，但其功能并未依赖AspectJ的功能。</p><h3 id="Spring-AOP实现逻辑"><a href="#Spring-AOP实现逻辑" class="headerlink" title="Spring AOP实现逻辑"></a>Spring AOP实现逻辑</h3><p>在上文中讲到，Spring在初始化Bean的时候会判断BeanPostProcessor接口，然后根据其实现的方法为Bean实现一些前置、后置操作。同样的，Spring AOP 也是基于BeanPostProcessor实现的。在Spring中，有一个抽象类，名叫AbstractAutoProxyCreator，它实现了BeanPostProcessor接口，在postProcessAfterInitialization方法中，调用wrapIfNecessary方法对Bean进行代理包装。</p><p>wrapIfNecessary方法时序图如下：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/springaop.png" srcset="/img/loading.gif" alt="springaop.png"></p><p>在上述时序图中可见，Spring会根据代理类的实际情况去动态选择JDK代理与CGLIB代理，其中createAopProxy源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;Class&lt;?&gt; targetClass = config.getTargetClass();<span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">"TargetSource cannot determine target class: "</span> +<span class="hljs-string">"Either an interface or a target is required for proxy creation."</span>);&#125;<span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);&#125;<span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);&#125;&#125;</code></pre><p>通过源码可以看出，Spring选择JDK代理的条件为：</p><ul><li>代理的Bean实现了接口</li><li>没有为Bean指定直接代理</li></ul><p>反之，Spring则会选择CGLIB代理。</p><p>在Spring为Bean创建好代理对象后，我们在调用Bean时，首先Spring会找到代理对象的invoke方法，然后在该方法中会去查找拦截器，然后执行拦截器方法，最后才执行Bean的方法。</p><p>AOP执行代理Bean时序图（以JDK代理方式为例）：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/aopInterceptors.png" srcset="/img/loading.gif" alt="AOP执行代理Bean时序图"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中阐述了三种实现代理的模式，即静态代理、JDK动态代理、CGLIB动态代理。</p><p>静态代理实现简单，缺点是不能扩展，仅适用于类较少，变化较少的功能。</p><p>JDK动态代理扩展性强，缺点是必须实现接口。</p><p>CGLIB动态代理扩展性强，基于方法拦截实现动态代理，不用实现接口，直接对类进行代理。</p><p>AOP是具有横切性质的系统服务，AOP的出现是对OOP的良好补充，它使得开发者能用更优雅的方式处理具有横切性质的服务。</p><p>AspectJ 是在系统编译时决定代理关系。</p><p>SpringAOP是在Spring容器加载过程中对Bean进行处理生成代理类，因为SpringAOP每次运行时都会产生一个AOP代理类，因此性能较AspectJ 略差一筹。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring核心原理</title>
    <link href="/2018/10/18/Java/spring/Srping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <url>/2018/10/18/Java/spring/Srping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring核心原理"><a href="#Spring核心原理" class="headerlink" title="Spring核心原理"></a>Spring核心原理</h1><blockquote><p>在Spring中拥有许多的组件，但核心部分主要为：Beans、Core、Context、Expression，其中最为主要的为Core、与Beans，它们提供了最为核心的IOC和依赖注入功能。下文主要从这两个着手进行说明。</p></blockquote><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>Spring5架构图：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/spring5.png" srcset="/img/loading.gif" alt="spring5"></p><p>Spring框架设计理念</p><p>在Spring框架中，其最核心组件应属Beans，Spring-Beans模块是所有应用都必须使用的，它包含了访问配置文件、创建和管理Bean以及进行控制反转(<code>IOC</code>，Inversion of Control)、依赖注入(<code>DI</code>,Dependency Injection)操作相关的所有类。</p><p>在IBM developerWorks一文中(<a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/index.html</a>)这样说道：Spring就是面向Bean编程（BOP,Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。</p><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><blockquote><p>在Spring中Bean贯穿整个Spring应用，其生命周期应是从Spring容器创建后开始，直至Spring容器主动或被动销毁Bean。</p></blockquote><p>在Spring中，Bean默认为单例模式，即singleton属性默认为false，从BeanFactory中取得的Bean实例为在其初始化就产生一个新的对象，而不是每次获取的时候都产出一个新的对象。当然我们也可以在初始化Bean的时候设置其singleton属性为true，使这个Bean变成多例模式，在getBean的时候，Spring都会产出一个新的对象，类似于Java的中的new Object操作。但设置其为多例，应避免多线程同时存取共享资源所引发的数据不同步问题。</p><p>然后在Spring中，一个Bean从创建到销毁，大致需要经历一下几个步骤（其具体的实现方式，将在下放继续阐述）：</p><ol><li>实例化Bean，根据Spring配置，执行包扫描操作，并对其进行实例化操作。</li><li>根据Spring上线文对实例化的Bean进行配置，其中包括依赖注入。</li><li>判断是否实现了BeanNameAware接口，如果有会执行setBeanName方法去设置这个Bean的id，即自己设置Bean在BeanFactory中的名字。</li><li>判断是否实现了BeanFactoryAware接口，如果有则执行setBeanFactory方法，使得Bean可以获取自己的工厂，从而可以使用工厂的getBean方法。</li><li>判断是否实现了ApplicationContextAware接口，如果有则执行setApplicationContext方法，使得在Bean中可以获取Spring上下文，从而可以获取通过上下文去getBean，该步骤与上一步作用大致相同，但通过该中方式能实现的功能却更加丰富。</li><li>判断是否实现了BeanPostProcessor接口，如果有则调用postProcessBeforeInitialization方法，这一步属于实例化Bean的前置操作，在经过该步骤后，即Bean实例化后同样也会执行一个操作，详情见第八条。</li><li>判断Bean是否配置了init-method，如果有，在Bean初始化之后会默认执行一次init-method指定的方法。</li><li>判断Bean是否实现了BeanPostProcessor接口，如果有则调用postProcessAfterInitialization方法，该方法属于Bean实例化后的操作。在经过这个步骤后，Bean的初始化操作就完成了。</li><li>当Bean实例化完成后，当Bean不再被需要的时候会执行销毁操作。一般是在ApplicationContext执行close方法时会进行销毁操作。</li><li>在销毁过程中，判断是否实现了DisposableBean接口，如果有则执行destroy方法。</li><li>判断Bean是否配置了destroy-method，如果有，在销毁过程中会默认执行一次destroy-method方法。</li></ol><h2 id="Bean初始化过程"><a href="#Bean初始化过程" class="headerlink" title="Bean初始化过程"></a>Bean初始化过程</h2><p>在上一篇关于‘Spring初始化过程’的文章最后写到Spring初始化过程中最后执行的核心方法是AbstractRefreshableApplicationContext类的refresh方法。这里再次将其源码贴出.</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;               <span class="hljs-comment">// 1.为应用上下文的刷新做准备--设置时间、记录刷新日志、初始化属性源中的占位符(事实上什么都没做)和验证必要的属性等</span><span class="hljs-comment">// Prepare this context for refreshing.</span>prepareRefresh();<span class="hljs-comment">// 2.让子类刷新内部的bean factory</span><span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span>ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();            <span class="hljs-comment">//3.为上下文准备bean factory</span><span class="hljs-comment">// Prepare the bean factory for use in this context.</span>prepareBeanFactory(beanFactory);<span class="hljs-keyword">try</span> &#123;                 <span class="hljs-comment">// 4.bean factory 后置处理</span><span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span>postProcessBeanFactory(beanFactory);<span class="hljs-comment">// 5.调用应用上下文中作为bean注册的工厂处理器</span><span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span>invokeBeanFactoryPostProcessors(beanFactory);<span class="hljs-comment">// 6.注册拦截创建bean的bean处理器</span><span class="hljs-comment">// Register bean processors that intercept bean creation.</span>registerBeanPostProcessors(beanFactory); <span class="hljs-comment">// 7.初始化消息源</span><span class="hljs-comment">// Initialize message source for this context.</span>initMessageSource(); <span class="hljs-comment">// 8.初始化事件广播</span><span class="hljs-comment">// Initialize event multicaster for this context.</span>initApplicationEventMulticaster();<span class="hljs-comment">// 9.初始化特定上下文子类中的其它bean</span><span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span>onRefresh(); <span class="hljs-comment">// 10.注册监听器bean</span><span class="hljs-comment">// Check for listener beans and register them.</span>registerListeners();<span class="hljs-comment">// 11.实例化所有的单例bean</span><span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span>finishBeanFactoryInitialization(beanFactory); <span class="hljs-comment">// 12.发布相应的事件</span><span class="hljs-comment">// Last step: publish corresponding event.</span>finishRefresh();&#125;<span class="hljs-keyword">catch</span> (BeansException ex) &#123;<span class="hljs-keyword">if</span> (logger.isWarnEnabled()) &#123;logger.warn(<span class="hljs-string">"Exception encountered during context initialization - "</span> +<span class="hljs-string">"cancelling refresh attempt: "</span> + ex);&#125; <span class="hljs-comment">//销毁错误的资源</span><span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span>destroyBeans();<span class="hljs-comment">//重置刷新标志</span><span class="hljs-comment">// Reset 'active' flag.</span>cancelRefresh(ex);<span class="hljs-comment">//主动抛出异常</span><span class="hljs-comment">// Propagate exception to caller.</span><span class="hljs-keyword">throw</span> ex;&#125;<span class="hljs-keyword">finally</span> &#123;                <span class="hljs-comment">//重置内存缓存</span><span class="hljs-comment">// Reset common introspection caches in Spring's core, since we</span><span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span>resetCommonCaches();&#125;&#125;&#125;</code></pre><p>通过源码可以看出该方法是构建整个IOC容器的完成过程。其中每一行代码都是创建容器的一个流程。其中主要包括以下几个步骤：</p><ol><li>构建BeanFactory</li><li>添加事件处理</li><li>创建 Bean 实例对象并构建Bean关系</li><li>触发被监听的事件 </li></ol><h3 id="构建BeanFactory"><a href="#构建BeanFactory" class="headerlink" title="构建BeanFactory"></a>构建BeanFactory</h3><p>构建BeanFactory的操作主要包括步骤1、2、3。其中第一步在我看来并未做啥重要的事情，我们只需将焦点定在二三步即可。</p><p>在第二步中，obtainFreshBeanFactory方法主要调用了AbstractRefreshableApplicationContext#refreshBeanFactory方法：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;destroyBeans();closeBeanFactory();&#125;<span class="hljs-keyword">try</span> &#123;DefaultListableBeanFactory beanFactory = createBeanFactory();beanFactory.setSerializationId(getId());customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory);<span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.beanFactoryMonitor) &#123;<span class="hljs-keyword">this</span>.beanFactory = beanFactory;&#125;&#125;<span class="hljs-keyword">catch</span> (IOException ex) &#123;<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);&#125;&#125;</code></pre><p>在上述代码中清晰可见的说明了BeanFactory的创建过程，首先判断当前容器是否存在BeanFactory，如果有则销毁后在进行创建。通过try/catch中代码可见，BeanFactory的是DefaultListableBeanFactory的实例对象。</p><p>通过Idea查看DefaultListableBeanFactory的类图如下：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/DefaultListableBeanFactory.png" srcset="/img/loading.gif" alt="DefaultListableBeanFactory.png"></p><p>从这个图中发现除了 BeanFactory 相关的类外，还发现了与 Bean 的 register 相关。这在 refreshBeanFactory 方法中有一行 loadBeanDefinitions(beanFactory) 将找到答案，这个方法将开始加载、解析 Bean 的定义，也就是把用户定义的数据结构转化为 Ioc 容器中的特定数据结构。 </p><p>对于WEB应用而言，其调用的是XmlWebApplicationContext#loadBeanDefinitions方法。</p><p>在BeanFactory创建成功后，Spring将创建的对象交于第三步，即prepareBeanFactory方法为其添加一些 Spring 本身需要的一些工具类。</p><h3 id="添加事件处理"><a href="#添加事件处理" class="headerlink" title="添加事件处理"></a>添加事件处理</h3><p>在第4、5、6步中，这三行代码对 Spring 的功能扩展性起了至关重要的作用 。其中第4、5步的代码主要是让你可以在Bean已经被创建，但未被初始化之前对已经构建的 BeanFactory 的配置做修改；第6步代码主要是让你可以对以后再创建 Bean 的实例对象时添加一些自定义的操作 。</p><p>第4步，即postProcessBeanFactory方法。主要功能为允许上下文能对BeanFactory做一些处理。比如：AbstractRefreshableWebApplicationContext抽象类实现了该方法，并在方法中对Servlet做了一些处理。</p><p>第5步，即invokeBeanFactoryPostProcessors方法主要是获取实现 BeanFactoryPostProcessor 接口的子类。其中主要包括执行BeanDefinitionRegistryPostProcessor类型的postProcessBeanDefinitionRegistry方法，以及执行非BeanDefinitionRegistryPostProcessor类型的postProcessBeanFactory方法。当然，该方法传入的参数是ConfigurableListableBeanFactory 类型，我们仅能对BeanFactory的一些配置做修改。</p><p>第6步，即registerBeanPostProcessors 方法也是可以获取用户定义的实现了 BeanPostProcessor 接口的子类，并执行把它们注册到 BeanFactory 对象中的 beanPostProcessors 变量中。BeanPostProcessor 中声明了两个方法：postProcessBeforeInitialization、postProcessAfterInitialization 分别用于在 Bean 对象初始化时执行。可以执行用户自定义的操作。 </p><p>第7、8、9、10步的方法主要是初始化监听事件和对系统的其他监听者的注册，监听者必须是 ApplicationListener 的子类。 在容器启动时，Spring会调用ApplicationStartListener的onApplicationEvent方法。</p><h3 id="创建-Bean-实例对象并构建Bean关系"><a href="#创建-Bean-实例对象并构建Bean关系" class="headerlink" title="创建 Bean 实例对象并构建Bean关系"></a>创建 Bean 实例对象并构建Bean关系</h3><p>Bean的实例化过程是第11步开始的，即finishBeanFactoryInitialization方法，而在finishBeanFactoryInitialization方法中核心方法又为preInstantiateSingletons（DefaultListableBeanFactory类）。在该方法中，首先拿到所有beanName，然后在实例化的时候会判断bean是否为FactoryBean，顾名思义，这是一个特殊的工厂Bean，可以产生Bean的Bean。</p><p>这里的产生 Bean 是指 Bean 的实例，如果一个类继承 FactoryBean 用户只要实现他的 getObject 方法，就可以自己定义产生实例对象的方法。然而在 Spring 内部这个 Bean 的实例对象是 FactoryBean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。 </p><p>在Bean的实例化主要分两个步骤：</p><ul><li>Bean不为抽象、单例、非懒加载。<ul><li>判断Bean是否为FactoryBean，是则执行FactoryBean相关的操作，否则直接调用getBean方法产生实例。</li></ul></li><li>在singleton的bean初始化完了之后调用SmartInitializingSingleton的afterSingletonsInstantiated方法。</li></ul><p>通过跟进Bean实例化代码可以发现getBean方法最后指向的是AbstractBeanFactory类的抽象方法createBean，其实现类为AbstractAutowireCapableBeanFactory。在该方法中有一个步骤会去查找Bean的依赖关系，并对其进行依赖注入操作。这里画一个时序图来作说明。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/spring/%E5%AE%9E%E4%BE%8B%E5%8C%96Bean%E6%97%B6%E5%BA%8F%E5%9B%BE.png" srcset="/img/loading.gif" alt="实例化Bean时序图"></p><p>需要注意的是，在resolveValueIfNecessary方法中，不仅有调用resolveReference，同样的还有resolveInnerBean，即解析内部的Bean引用。</p><h3 id="触发被监听的事件"><a href="#触发被监听的事件" class="headerlink" title="触发被监听的事件"></a>触发被监听的事件</h3><p>在经历第11步后，上下文的创建就已经基本完成了，这时Spring会执行finishRefresh方法，完成此上下文的刷新。其中包括LifecycleProcessor的onRefresh方法，并执行ContextRefreshedEvent事件。例如：执行SpringMVC的事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Bean声明周期中曾讲到，Spring在初始化Bean的时候先后对调用BeanPostProcessor接口的postProcessBeforeInitialization、postProcessAfterInitialization方法。利用这一特性我们可以在Bean中实现BeanPostProcessor接口，然后再方法体中加入自己的逻辑。</p><p>对于Spring的IOC容器而言，除了BeanPostProcessor，还有BeanFactoryPostProcessor。顾明思议，BeanFactoryPostProcessor是在构建BeanFactory和构建Bean对象时调用。IOC容器允许BeanFactoryPostProcessor在容器初始化任何Bean之前对BeanFactory配置进行修改。</p><p>在Spring的IOC容器中还有一个特殊的Bean，即FactoryBean，FactoryBean主要用于初始化其他Bean，我们可以自己实现一个FactoryBean，然后添加自定义实例化逻辑。在Spring中，AOP、ORM、事务管理等都是依靠FactoryBean的扩展来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMvc自定义参数解析与返回值处理</title>
    <link href="/2018/10/18/Java/spring/springmvc%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90%E5%99%A8/"/>
    <url>/2018/10/18/Java/spring/springmvc%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%A3%E6%9E%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringMvc自定义参数解析与返回值处理"><a href="#SpringMvc自定义参数解析与返回值处理" class="headerlink" title="SpringMvc自定义参数解析与返回值处理"></a>SpringMvc自定义参数解析与返回值处理</h1><blockquote><p>近日在做项目的时候，需要解析客户端传来的经过<code>AES</code>加密处理的实体信息，同时也需要向客户端返回经过<code>AES</code>加密的实体信息，在项目初期，都是在<code>Controller</code>方法中去调用某个工具类进行decode、encode操作比较繁琐，于是去寻求解决办法，在翻阅了<code>SpringMvc</code>解析参数的源码后，仿照<code>@RequestBody</code>的进行以下实现。本文基于<code>SpringBoot 2.0</code>即<code>SpringMvc 5.0.6</code>。</p></blockquote><h2 id="SpringMvc-参数绑定原理"><a href="#SpringMvc-参数绑定原理" class="headerlink" title="SpringMvc 参数绑定原理"></a>SpringMvc 参数绑定原理</h2><h3 id="ArgumentResolver与ReturnValueHandler"><a href="#ArgumentResolver与ReturnValueHandler" class="headerlink" title="ArgumentResolver与ReturnValueHandler"></a>ArgumentResolver与ReturnValueHandler</h3><p>通过在maven在项目中引入SpringMvc依赖，你可以使用ide的快捷键（比如，idea是ctrl+n)查找类RequestBody，其类注释如下：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Annotation indicating a method parameter should be bound to the body of the web request.</span><span class="hljs-comment"> * The body of the request is passed through an &#123;<span class="hljs-doctag">@link</span> HttpMessageConverter&#125; to resolve the</span><span class="hljs-comment"> * method argument depending on the content type of the request. Optionally, automatic</span><span class="hljs-comment"> * validation can be applied by annotating the argument with &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@Valid</span>&#125;.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * &lt;p&gt;Supported for annotated handler methods in Servlet environments.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Arjen Poutsma</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 3.0</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> RequestHeader</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> ResponseBody</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span><span class="hljs-comment"> */</span></code></pre><p>接着继续查找类注释中的类<code>RequestMappingHandlerAdapter</code>，查看其源码可以发现，其源码的注释中有这样两行代码：</p><pre><code class="hljs java">* <span class="hljs-meta">@see</span> HandlerMethodArgumentResolver* <span class="hljs-meta">@see</span> HandlerMethodReturnValueHandler</code></pre><p>分别查看这两个类:</p><h3 id="HandlerMethodArgumentResolver"><a href="#HandlerMethodArgumentResolver" class="headerlink" title="HandlerMethodArgumentResolver"></a>HandlerMethodArgumentResolver</h3><blockquote><p>在给定请求的上下文中，将方法参数解析为参数值的策略接口。</p></blockquote><p>HandlerMethodArgumentResolver中有两个接口</p><pre><code class="hljs java"><span class="hljs-comment">//判断传入的参数是否被该方法所支持</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span></span>;<span class="hljs-comment">//参数解析方法</span><span class="hljs-function">Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span><span class="hljs-function"><span class="hljs-params">NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre><p>其中resolveArgument方法的返回值，会被作为参数传入到Controller的方法参数中。</p><h3 id="HandlerMethodReturnValueHandler"><a href="#HandlerMethodReturnValueHandler" class="headerlink" title="HandlerMethodReturnValueHandler"></a>HandlerMethodReturnValueHandler</h3><blockquote><p>处理程序方法返回值的策略接口。</p></blockquote><p>同样的，HandlerMethodReturnValueHandler中也有两个接口</p><pre><code class="hljs java"><span class="hljs-comment">//判断传入的参数是否被该方法所支持</span><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span></span>;<span class="hljs-comment">//返回值解析</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(@Nullable Object returnValue, MethodParameter returnType,</span></span><span class="hljs-function"><span class="hljs-params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception</span>;</code></pre><p>在handleReturnValue我们可以直接构造返回给客户端的内容。</p><h3 id="MethodParameter"><a href="#MethodParameter" class="headerlink" title="MethodParameter"></a>MethodParameter</h3><p>按照官方的说明，这个类封装了方法参数的规范，记录了一个方法的类注解、方法注解、方法参数。</p><p>我们在<code>supportsReturnType</code>方法去判断这个类是否拥有指定注解(自定义注解)，从而进行相应的处理逻辑，另外我们还可以通过这个类的对象去获取Controller方法的参数类型，比如：</p><pre><code class="hljs java">parameter.getNestedGenericParameterType()</code></pre><p>如果该注解在方法的参数上，即<code>ElementType.PARAMETER</code>，例子见下方，则getNestedGenericParameterType方法返回的为其制定参数的类型：</p><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestApi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseController</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(TestApi<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    <span class="hljs-meta">@PostMapping</span>(value = <span class="hljs-string">"/encryptTest"</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> UserDo <span class="hljs-title">encryptTest</span><span class="hljs-params">(@EncryptBody UserDo user)</span> </span>&#123;        <span class="hljs-keyword">return</span> user;    &#125;&#125;</code></pre><p>如果将注解打在方法上，即<code>ElementType.METHOD</code>，例子见下方，则getNestedGenericParameterType方法返回的为方法返回值类型：</p><pre><code class="hljs java"><span class="hljs-meta">@EncryptBody</span><span class="hljs-function"><span class="hljs-keyword">public</span> UserDo <span class="hljs-title">encryptTest</span><span class="hljs-params">()</span></span>&#123;&#125;</code></pre><h3 id="NativeWebRequest"><a href="#NativeWebRequest" class="headerlink" title="NativeWebRequest"></a>NativeWebRequest</h3><p>NativeWebRequest是WebRequest接口的扩展 ，是springmvc专门定义用来供框架内部使用，特别是通用参数解析代码。</p><p>在ArgumentResolver与ReturnValueHandler中，我们可以使用其获取<code>HttpServletRequest</code>与<code>HttpServletResponse</code>，从而实现对参数的解析与返回值的构建。</p><pre><code class="hljs java">HttpServletRequest servletRequest = nativeWebRequest.getNativeRequest(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;HttpServletResponse response = nativeWebRequest.getNativeResponse(HttpServletResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;</code></pre><h3 id="RequestMappingHandlerAdapter"><a href="#RequestMappingHandlerAdapter" class="headerlink" title="RequestMappingHandlerAdapter"></a>RequestMappingHandlerAdapter</h3><p>继续查看<code>RequestMappingHandlerAdapter</code>的源码，分别以下四个变量：</p><ul><li>customArgumentResolvers：自定义的参数解析器</li><li>argumentResolvers：默认的参数解析器，通过<code>getDefaultArgumentResolvers</code>方法可查看其具体的初始换方式。</li><li>customReturnValueHandlers：自定义的返回值处理器</li><li>returnValueHandlers：默认的返回值处理器，通过<code>getDefaultReturnValueHandlers</code>方法可查看其具体的初始化方式</li></ul><p>getDefaultArgumentResolvers源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="hljs-title">getDefaultArgumentResolvers</span><span class="hljs-params">()</span> </span>&#123;List&lt;HandlerMethodArgumentResolver&gt; resolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">// Annotation-based argument resolution</span>resolvers.add(<span class="hljs-keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="hljs-keyword">false</span>));resolvers.add(<span class="hljs-keyword">new</span> RequestParamMapMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> PathVariableMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> PathVariableMapMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> MatrixVariableMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> MatrixVariableMapMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> ServletModelAttributeMethodProcessor(<span class="hljs-keyword">false</span>));resolvers.add(<span class="hljs-keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(), <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));resolvers.add(<span class="hljs-keyword">new</span> RequestPartMethodArgumentResolver(getMessageConverters(), <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));resolvers.add(<span class="hljs-keyword">new</span> RequestHeaderMethodArgumentResolver(getBeanFactory()));resolvers.add(<span class="hljs-keyword">new</span> RequestHeaderMapMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> ServletCookieValueMethodArgumentResolver(getBeanFactory()));resolvers.add(<span class="hljs-keyword">new</span> ExpressionValueMethodArgumentResolver(getBeanFactory()));resolvers.add(<span class="hljs-keyword">new</span> SessionAttributeMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> RequestAttributeMethodArgumentResolver());<span class="hljs-comment">// Type-based argument resolution</span>resolvers.add(<span class="hljs-keyword">new</span> ServletRequestMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> ServletResponseMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(), <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));resolvers.add(<span class="hljs-keyword">new</span> RedirectAttributesMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> ModelMethodProcessor());resolvers.add(<span class="hljs-keyword">new</span> MapMethodProcessor());resolvers.add(<span class="hljs-keyword">new</span> ErrorsMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> SessionStatusMethodArgumentResolver());resolvers.add(<span class="hljs-keyword">new</span> UriComponentsBuilderMethodArgumentResolver());<span class="hljs-comment">// Custom arguments</span><span class="hljs-keyword">if</span> (getCustomArgumentResolvers() != <span class="hljs-keyword">null</span>) &#123;resolvers.addAll(getCustomArgumentResolvers());&#125;<span class="hljs-comment">// Catch-all</span>resolvers.add(<span class="hljs-keyword">new</span> RequestParamMethodArgumentResolver(getBeanFactory(), <span class="hljs-keyword">true</span>));resolvers.add(<span class="hljs-keyword">new</span> ServletModelAttributeMethodProcessor(<span class="hljs-keyword">true</span>));<span class="hljs-keyword">return</span> resolvers;&#125;</code></pre><p>getDefaultReturnValueHandlers源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;HandlerMethodReturnValueHandler&gt; <span class="hljs-title">getDefaultReturnValueHandlers</span><span class="hljs-params">()</span> </span>&#123;List&lt;HandlerMethodReturnValueHandler&gt; handlers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<span class="hljs-comment">// Single-purpose return value types</span>handlers.add(<span class="hljs-keyword">new</span> ModelAndViewMethodReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> ModelMethodProcessor());handlers.add(<span class="hljs-keyword">new</span> ViewMethodReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> ResponseBodyEmitterReturnValueHandler(getMessageConverters(),<span class="hljs-keyword">this</span>.reactiveAdapterRegistry, <span class="hljs-keyword">this</span>.taskExecutor, <span class="hljs-keyword">this</span>.contentNegotiationManager));handlers.add(<span class="hljs-keyword">new</span> StreamingResponseBodyReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> HttpEntityMethodProcessor(getMessageConverters(),<span class="hljs-keyword">this</span>.contentNegotiationManager, <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));handlers.add(<span class="hljs-keyword">new</span> HttpHeadersReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> CallableMethodReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> DeferredResultMethodReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> AsyncTaskMethodReturnValueHandler(<span class="hljs-keyword">this</span>.beanFactory));<span class="hljs-comment">// Annotation-based return value types</span>handlers.add(<span class="hljs-keyword">new</span> ModelAttributeMethodProcessor(<span class="hljs-keyword">false</span>));handlers.add(<span class="hljs-keyword">new</span> RequestResponseBodyMethodProcessor(getMessageConverters(),<span class="hljs-keyword">this</span>.contentNegotiationManager, <span class="hljs-keyword">this</span>.requestResponseBodyAdvice));<span class="hljs-comment">// Multi-purpose return value types</span>handlers.add(<span class="hljs-keyword">new</span> ViewNameMethodReturnValueHandler());handlers.add(<span class="hljs-keyword">new</span> MapMethodProcessor());<span class="hljs-comment">// Custom return value types</span><span class="hljs-keyword">if</span> (getCustomReturnValueHandlers() != <span class="hljs-keyword">null</span>) &#123;handlers.addAll(getCustomReturnValueHandlers());&#125;<span class="hljs-comment">// Catch-all</span><span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(getModelAndViewResolvers())) &#123;handlers.add(<span class="hljs-keyword">new</span> ModelAndViewResolverMethodReturnValueHandler(getModelAndViewResolvers()));&#125;<span class="hljs-keyword">else</span> &#123;handlers.add(<span class="hljs-keyword">new</span> ModelAttributeMethodProcessor(<span class="hljs-keyword">true</span>));&#125;<span class="hljs-keyword">return</span> handlers;&#125;</code></pre><h2 id="自定义解析器与构造器"><a href="#自定义解析器与构造器" class="headerlink" title="自定义解析器与构造器"></a>自定义解析器与构造器</h2><blockquote><p>在自定义的过程中依赖了项目中的一些工具类，比如：<code>AbstractEcryptMappingHadler</code>、<code>Encrypt</code>等等，由于项目中预留了多种加密方式的接口，类稍有点过多，此处就不一一贴出，如有需要，请移驾github查看源码<a href="https://github.com/jiangliuhong/RedisWClient-server" target="_blank" rel="noopener">https://github.com/jiangliuhong/RedisWClient-server</a>查看源码(包路径为：pers.jarome.redis.wclient.common.web.encrypt)，当然，你也可以移除这些依赖，然后自定义逻辑。</p></blockquote><h3 id="自定义EncryptArgumentResolver"><a href="#自定义EncryptArgumentResolver" class="headerlink" title="自定义EncryptArgumentResolver"></a>自定义EncryptArgumentResolver</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> pers.jarome.redis.wclient.common.web.encrypt.method.resolver;<span class="hljs-keyword">import</span> org.springframework.core.MethodParameter;<span class="hljs-keyword">import</span> org.springframework.web.bind.support.WebDataBinderFactory;<span class="hljs-keyword">import</span> org.springframework.web.context.request.NativeWebRequest;<span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;<span class="hljs-keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.anno.EncryptBody;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.constants.EncryptMethod;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.entity.Encrypt;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.exception.EncryptException;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.method.AbstractEcryptMappingHadler;<span class="hljs-keyword">import</span> javax.servlet.ServletInputStream;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> java.io.BufferedReader;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStreamReader;<span class="hljs-comment">/**</span><span class="hljs-comment"> * EncryptArgumentResolver</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 加密解析器</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/8/17 9:35</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptArgumentResolver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEcryptMappingHadler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodArgumentResolver</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;        <span class="hljs-keyword">return</span> hasEncryptAnnotaion(parameter);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//请自定义你的处理逻辑。</span>        <span class="hljs-comment">//你可以根据HttpServletRequest去获取你想要的</span>        <span class="hljs-comment">//此处我是通过webRequest获取body中的内容，然后将其进行AES解密，然后转为controller方法中需要的对象</span>        String body = getRequestBody(webRequest);        EncryptBody encryptBody = parameter.getAnnotatedElement().getAnnotation(EncryptBody<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        Encrypt encrypt = getEncrypt(encryptBody.method());        <span class="hljs-keyword">if</span>(encrypt == <span class="hljs-keyword">null</span>)&#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> EncryptException(<span class="hljs-string">"Not Found Encrypt."</span>);        &#125;        <span class="hljs-keyword">return</span> encrypt.decode(body, parameter.getNestedGenericParameterType());    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> Boolean <span class="hljs-title">hasEncryptAnnotaion</span><span class="hljs-params">(MethodParameter parameter)</span> </span>&#123;        <span class="hljs-keyword">return</span> parameter.hasParameterAnnotation(EncryptBody<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getRequestBody</span><span class="hljs-params">(NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        ServletInputStream inputStream = servletRequest.getInputStream();        BufferedReader bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream));        StringBuilder body = <span class="hljs-keyword">new</span> StringBuilder();        String str;        <span class="hljs-keyword">while</span> ((str = bufferedReader.readLine()) != <span class="hljs-keyword">null</span>) &#123;            body.append(str);        &#125;        <span class="hljs-keyword">return</span> body.toString();    &#125;&#125;</code></pre><h3 id="自定义EncryptBodyRturnValueHandler"><a href="#自定义EncryptBodyRturnValueHandler" class="headerlink" title="自定义EncryptBodyRturnValueHandler"></a>自定义EncryptBodyRturnValueHandler</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> pers.jarome.redis.wclient.common.web.encrypt.method.handler;<span class="hljs-keyword">import</span> com.alibaba.fastjson.JSON;<span class="hljs-keyword">import</span> org.springframework.core.MethodParameter;<span class="hljs-keyword">import</span> org.springframework.http.MediaType;<span class="hljs-keyword">import</span> org.springframework.web.context.request.NativeWebRequest;<span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodReturnValueHandler;<span class="hljs-keyword">import</span> org.springframework.web.method.support.ModelAndViewContainer;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.anno.EncryptBody;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.entity.Encrypt;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.method.AbstractEcryptMappingHadler;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.PrintWriter;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * EncryptBodyRturnValueHandler</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> 加密实体返回值组装器</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/8/16 21:53</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EncryptBodyRturnValueHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractEcryptMappingHadler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerMethodReturnValueHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> </span>&#123;        <span class="hljs-keyword">return</span> returnType.hasMethodAnnotation(EncryptBody<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturnValue</span><span class="hljs-params">(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-comment">//请自定义你的处理逻辑。</span>        <span class="hljs-comment">//此处我是将返回值进行AES加密，然后返回给客户端</span>        EncryptBody encryptBody = returnType.getMethodAnnotation(EncryptBody<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        mavContainer.setRequestHandled(<span class="hljs-keyword">true</span>);        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);        PrintWriter outWriter = response.getWriter();        Encrypt encrypt = getEncrypt(encryptBody.method());        Object encode = encrypt.encode(returnValue);        String jsonString = <span class="hljs-string">""</span>;        <span class="hljs-keyword">if</span>(encode!=<span class="hljs-keyword">null</span>) &#123;            jsonString = JSON.toJSONString(encode);        &#125;        outWriter.write(jsonString);        outWriter.flush();        outWriter.close();    &#125;&#125;</code></pre><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>继续调试跟踪代码，发现在<code>WebMvcConfigurationSupport</code>类(只有高版本的SpringBoot才具有该类，低版本的为<code>WebMvcConfigurerAdapter</code>该类的逻辑，由于没有深入查看，此处就不做赘述了)中有这样一个方法：</p><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><span class="hljs-function"><span class="hljs-keyword">public</span> RequestMappingHandlerAdapter <span class="hljs-title">requestMappingHandlerAdapter</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//初始化一个RequestMappingHandlerAdapter</span>RequestMappingHandlerAdapter adapter = createRequestMappingHandlerAdapter();adapter.setContentNegotiationManager(mvcContentNegotiationManager());adapter.setMessageConverters(getMessageConverters());adapter.setWebBindingInitializer(getConfigurableWebBindingInitializer());adapter.setCustomArgumentResolvers(getArgumentResolvers());adapter.setCustomReturnValueHandlers(getReturnValueHandlers());<span class="hljs-keyword">if</span> (jackson2Present) &#123;adapter.setRequestBodyAdvice(Collections.singletonList(<span class="hljs-keyword">new</span> JsonViewRequestBodyAdvice()));adapter.setResponseBodyAdvice(Collections.singletonList(<span class="hljs-keyword">new</span> JsonViewResponseBodyAdvice()));&#125;AsyncSupportConfigurer configurer = <span class="hljs-keyword">new</span> AsyncSupportConfigurer();configureAsyncSupport(configurer);<span class="hljs-keyword">if</span> (configurer.getTaskExecutor() != <span class="hljs-keyword">null</span>) &#123;adapter.setTaskExecutor(configurer.getTaskExecutor());&#125;<span class="hljs-keyword">if</span> (configurer.getTimeout() != <span class="hljs-keyword">null</span>) &#123;adapter.setAsyncRequestTimeout(configurer.getTimeout());&#125;adapter.setCallableInterceptors(configurer.getCallableInterceptors());adapter.setDeferredResultInterceptors(configurer.getDeferredResultInterceptors());<span class="hljs-keyword">return</span> adapter;&#125;</code></pre><p>该方法的作用为在系统初始化的时候，返回系统以及用户自定义的解析器等。</p><p>从上诉代码不难看出，在加载用户自定义的处理器的代码为：</p><pre><code class="hljs java">adapter.setCustomArgumentResolvers(getArgumentResolvers());adapter.setCustomReturnValueHandlers(getReturnValueHandlers());</code></pre><p>刨根究底，发现<code>getArgumentResolvers</code>与<code>getReturnValueHandlers</code>的数据源源为<code>WebMvcConfigurer</code>接口中的<code>addArgumentResolvers</code>与<code>addReturnValueHandlers</code>。此时我们可以通过自定义类，实现这两个接口来实现注册了。</p><h4 id="SpringBoot1-x注册方法"><a href="#SpringBoot1-x注册方法" class="headerlink" title="SpringBoot1.x注册方法"></a>SpringBoot1.x注册方法</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> pers.jarome.redis.wclient.app.config;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;<span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodReturnValueHandler;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistration;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.method.handler.EncryptBodyRturnValueHandler;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.interceptor.AuthenticationInterceptor;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.method.resolver.EncryptArgumentResolver;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Web环境配置</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2017/12/29</span><span class="hljs-comment"> **/</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfigAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurerAdapter</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;        argumentResolvers.add(<span class="hljs-keyword">new</span> EncryptArgumentResolver());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addReturnValueHandlers</span><span class="hljs-params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> </span>&#123;        returnValueHandlers.add(<span class="hljs-keyword">new</span> EncryptBodyRturnValueHandler());    &#125;&#125;</code></pre><h4 id="SpringBoot2-0注册方法"><a href="#SpringBoot2-0注册方法" class="headerlink" title="SpringBoot2.0注册方法"></a>SpringBoot2.0注册方法</h4><p>如果你的SpringBoot版本大于等于2.0，那么WebMvcConfigurerAdapter过期，此时应该使用新的<code>WebMvcConfigurationSupport</code></p><pre><code class="hljs java"><span class="hljs-keyword">package</span> pers.jarome.redis.wclient.app.config;<span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodArgumentResolver;<span class="hljs-keyword">import</span> org.springframework.web.method.support.HandlerMethodReturnValueHandler;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistration;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;<span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.method.handler.EncryptBodyRturnValueHandler;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.encrypt.method.resolver.EncryptArgumentResolver;<span class="hljs-keyword">import</span> pers.jarome.redis.wclient.common.web.interceptor.AuthenticationInterceptor;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-comment">/**</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * WebMvcConfig</span><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> Web环境配置</span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> jiangliuhong</span><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2018/8/19 0:46</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;        InterceptorRegistration ir = registry.addInterceptor(<span class="hljs-keyword">new</span> AuthenticationInterceptor());        ir.addPathPatterns(<span class="hljs-string">"/**"</span>);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addArgumentResolvers</span><span class="hljs-params">(List&lt;HandlerMethodArgumentResolver&gt; argumentResolvers)</span> </span>&#123;        argumentResolvers.add(<span class="hljs-keyword">new</span> EncryptArgumentResolver());    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addReturnValueHandlers</span><span class="hljs-params">(List&lt;HandlerMethodReturnValueHandler&gt; returnValueHandlers)</span> </span>&#123;        returnValueHandlers.add(<span class="hljs-keyword">new</span> EncryptBodyRturnValueHandler());    &#125;&#125;</code></pre><h4 id="非SpringBoot注册方法"><a href="#非SpringBoot注册方法" class="headerlink" title="非SpringBoot注册方法"></a>非SpringBoot注册方法</h4><blockquote><p>对于非SpringBoot项目的注册方式大同小异，也就是xml配置与类配置的区别。</p></blockquote><p>对于非SpringBoot的项目，在其springmvc的配置文件中加入以下代码即可：</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span>        <span class="hljs-comment">&lt;!-- 自定义参数解析器 --&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"customArgumentResolvers"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pers.jarome.redis.wclient.common.web.encrypt.method.resolver.EncryptArgumentResolver"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"customReturnValueHandlers"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span>                <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"pers.jarome.redis.wclient.common.web.encrypt.method.handler.EncryptBodyRturnValueHandler"</span> /&gt;</span>            <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></code></pre><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在自定义解析器时，我是基于<code>RequestMappingHandlerAdapter</code>进行封装实现的，在这个类中通过加入自定义的Resolver与Handler，从而达到我们期望的参数绑定与返回值处理效果，另外，我们还可以定义messageConverters等，当然，也可以自定义一个HandlerAdapter。最后再引入一个类<code>WebMvcAutoConfiguration</code>作为下一次Spring源码学习的主题吧。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringApplicationContext初始化过程</title>
    <link href="/2018/10/18/Java/spring/SpringApplicationContext%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/2018/10/18/Java/spring/SpringApplicationContext%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringApplicationContext初始化过程"><a href="#SpringApplicationContext初始化过程" class="headerlink" title="SpringApplicationContext初始化过程"></a>SpringApplicationContext初始化过程</h1><h2 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h2><p>在SpringBoot面世之前。在一般的WEB项目中，项目的启动都是从web.xml开始的，如果我们想在项目中使用Spring，只需在web.xml文件中指定以下内容即可：</p><pre><code class="hljs plain">&lt;context-param&gt;&lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;&lt;param-value&gt;classpath:applicationContext.xml&lt;&#x2F;param-value&gt;&lt;&#x2F;context-param&gt;&lt;listener&gt;&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt;</code></pre><p>通过以上代码片段不难看出Spring正是通过ContextLoaderListener监听器来进行容器初始化的，查看<code>ContextLoaderListener</code>源码：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextLoaderListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ContextLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContextListener</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContextLoaderListener</span><span class="hljs-params">()</span> </span>&#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ContextLoaderListener</span><span class="hljs-params">(WebApplicationContext context)</span> </span>&#123;<span class="hljs-keyword">super</span>(context);&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextInitialized</span><span class="hljs-params">(ServletContextEvent event)</span> </span>&#123;initWebApplicationContext(event.getServletContext());&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextDestroyed</span><span class="hljs-params">(ServletContextEvent event)</span> </span>&#123;closeWebApplicationContext(event.getServletContext());ContextCleanupListener.cleanupAttributes(event.getServletContext());&#125;&#125;</code></pre><p>根据该类中的注释可以看出initWebApplicationContext方法为核心的初始化方法，从initWebApplicationContext方法源代码可以看出Spring初始化容器主要分为以下几个步骤：</p><ol><li>创建容器WebApplicationContext</li><li>验证当前容器是否为可配置的，是则配置并且刷新当前容器 </li><li>将当前创建的容器设置到servlet上下文中</li></ol><h2 id="SpringBoot中的Spring"><a href="#SpringBoot中的Spring" class="headerlink" title="SpringBoot中的Spring"></a>SpringBoot中的Spring</h2><blockquote><p>上文根据一般WEB项目跟踪了Spring容器初始化过程，但是从上诉过程并不能相对明显地看出Spring容器初始化过程。</p></blockquote><p>在SpringBoot面世后，它简化了许多的配置方式，在SpringBoot中只需引入相应的start即可使用Spring，接下来就去看看SpringBoot中的Spring吧。</p><p>通过SpringBoot入口方法<code>SpringApplication.run</code>可以看到以下代码：</p><pre><code class="hljs java">ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(    args);ConfigurableEnvironment environment = prepareEnvironment(listeners,                                                         applicationArguments);configureIgnoreBeanInfo(environment);Banner printedBanner = printBanner(environment);<span class="hljs-comment">//创建容器</span>context = createApplicationContext();exceptionReporters = getSpringFactoriesInstances(    SpringBootExceptionReporter<span class="hljs-class">.<span class="hljs-keyword">class</span>,</span>    new Class[] &#123; ConfigurableApplicationContext.class &#125;, context);<span class="hljs-comment">//容器准备工作</span>prepareContext(context, environment, listeners, applicationArguments,               printedBanner);<span class="hljs-comment">//刷新容器</span>refreshContext(context);</code></pre><p>其中，创建容器容器的方法是createApplicationContext，createApplicationContext方法会根据当前启动类型去初始化不同的Spring容器，主要类型为以下三种：</p><ul><li>NONE：非WEB，普通应用程序</li><li>REACTIVE：反应堆栈Web容器(5.x新加)</li><li>SERVLET：Web容器</li></ul><p>ps:反应堆栈Web容器，即WebFlux框架，该框架是Spring 5.x新加的框架，详细内容请访问SpringCloud中文网：<a href="https://springcloud.cc/web-reactive.html" target="_blank" rel="noopener">https://springcloud.cc/web-reactive.html</a></p><h3 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext"></a>prepareContext</h3><p>prepareContext方法是做context的准备工作，该方法主要对容器进行一些预设置，源码中，该方法中的postProcessApplicationContext方法向beanFactory中添加了一个beanNameGenerator：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessApplicationContext</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanNameGenerator != <span class="hljs-keyword">null</span>) &#123;context.getBeanFactory().registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,<span class="hljs-keyword">this</span>.beanNameGenerator);&#125;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> GenericApplicationContext) &#123;((GenericApplicationContext) context).setResourceLoader(<span class="hljs-keyword">this</span>.resourceLoader);&#125;<span class="hljs-keyword">if</span> (context <span class="hljs-keyword">instanceof</span> DefaultResourceLoader) &#123;((DefaultResourceLoader) context).setClassLoader(<span class="hljs-keyword">this</span>.resourceLoader.getClassLoader());&#125;&#125;&#125;</code></pre><p>其中，BeanNameGenerator用来生成扫描到的Bean在容器中的名字。</p><p>在prepareContext方法中，applyInitializers也是一个颇为重要的内容，通过查询资料发现该方法主要是对已创建的并且未被刷新的容器进行设置的自定义应用上下文初始化器。</p><h3 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext"></a>refreshContext</h3><p>通过跟踪refreshContext方法不难发现，其最终执行的是AbstractRefreshableApplicationContext类中的refresh方法，其源码如下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException </span>&#123;        Object var1 = <span class="hljs-keyword">this</span>.startupShutdownMonitor;        <span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;         <span class="hljs-comment">// 为应用上下文的刷新做准备--设置时间、记录刷新日志、初始化属性源中的占位符(事实上什么都没做)和验证必 要的属性等</span>            <span class="hljs-keyword">this</span>.prepareRefresh();            <span class="hljs-comment">// 让子类刷新内部的bean factory</span>            ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();            <span class="hljs-comment">//为上下文准备bean factory</span>            <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-comment">// bean factory 后置处理</span>                <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);                <span class="hljs-comment">// 调用应用上下文中作为bean注册的工厂处理器</span>                <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);                <span class="hljs-comment">// 注册拦截创建bean的bean处理器</span>                <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);                <span class="hljs-comment">// 初始化消息源</span>                <span class="hljs-keyword">this</span>.initMessageSource();                <span class="hljs-comment">// 初始化事件广播</span>                <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();                <span class="hljs-comment">// 初始化特定上下文子类中的其它bean</span>                <span class="hljs-keyword">this</span>.onRefresh();                <span class="hljs-comment">// 注册监听器bean</span>                <span class="hljs-keyword">this</span>.registerListeners();                 <span class="hljs-comment">// 实例化所有的单例bean</span>                <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);                 <span class="hljs-comment">// 发布相应的事件</span>                <span class="hljs-keyword">this</span>.finishRefresh();            &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;                    <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">"Exception encountered during context initialization - cancelling refresh attempt: "</span> + var9);                &#125; <span class="hljs-comment">//销毁错误的资源</span>                <span class="hljs-keyword">this</span>.destroyBeans();                <span class="hljs-comment">//重置刷新标志</span>                <span class="hljs-keyword">this</span>.cancelRefresh(var9);                <span class="hljs-keyword">throw</span> var9;            &#125; <span class="hljs-keyword">finally</span> &#123;                <span class="hljs-keyword">this</span>.resetCommonCaches();            &#125;        &#125;    &#125;</code></pre><p>从以上代码的注释，可以看出refresh方法是Spring容器初始化的过程中加载Bean至关重要的一环，其职责主要是获取Bean，并初始化Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL备份与还原</title>
    <link href="/2018/07/16/database/MySQL/MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/"/>
    <url>/2018/07/16/database/MySQL/MySQL%E5%A4%87%E4%BB%BD%E4%B8%8E%E8%BF%98%E5%8E%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL备份与还原"><a href="#MySQL备份与还原" class="headerlink" title="MySQL备份与还原"></a>MySQL备份与还原</h1><h2 id="逻辑备份"><a href="#逻辑备份" class="headerlink" title="逻辑备份"></a>逻辑备份</h2><blockquote><p>逻辑备份为通过对数据库的操作导出数据文件，常用的逻辑备份有两种，一种是将数据转换为全量的INSERT语句，另一种是将数据以特定的分隔符进行隔后记录在文本文件中。</p></blockquote><h3 id="全量INSERT语句备份"><a href="#全量INSERT语句备份" class="headerlink" title="全量INSERT语句备份"></a>全量INSERT语句备份</h3><p>在MySQL数据库中，一般通过MySQL数据库自带的工具mysqldump来生成INSERT语句的逻辑备份文件。</p><p>mysqldump常用的集中方法为：</p><ul><li>导出整个数据库与所有数据</li></ul><pre><code class="hljs sql">mysqldump -u username -p dbname &gt; dbname.sql</code></pre><ul><li>导出数据库结构</li></ul><pre><code class="hljs sql">mysqldump -u username -p -d dbname &gt; dbname.sql</code></pre><ul><li>导出数据库中的某张表的数据</li></ul><pre><code class="hljs sql">mysqldump -u username -p dbname tablename &gt; tablename.sql</code></pre><ul><li>导出数据库中某张表的表结构（不含数据）</li></ul><pre><code class="hljs sql">mysqldump -u username -p -d dbname tablename &gt; tablename.sql</code></pre><ul><li>按照指定条件导出数据</li></ul><pre><code class="hljs sql">mysqldump -u username -p -h主机 数据库  a <span class="hljs-comment">--where "条件语句" --no-建表&gt; tablename.sql</span></code></pre><p>mysqldump参数详解：</p><p>–databases：备份多个数据库，选项后跟多个库名。备份文件中会包含USE db_name</p><p>–no-create-info：不生成建表语句</p><p>–events    :  备份事件</p><p>–routines：备份存储过程和函数</p><p>–ignore-table=TableName :指定不需要备份的表</p><p>–tables：覆盖–databases 或 -B 选项。该选项后的名称参数均被认为是表名。备份指定的表</p><p>–default-character-set：指定备份文件的编码，和数据库编码无关 </p><p>–lock-all-tables：通过在备份期前加read lock锁定所有库的所有表。会自动关闭—single-transaction和—lock-tables。</p><p>–lock-tables：在备份数据库时对当前库添加read lock.</p><p>–master-data：在备份文件中添加二进制日志文件名和位置信息，会自动开始–lock-all-tables</p><p>–single-transaction：在备份前设置事务隔离级别为REPEATABLE READ并向server发送START TRANSACTION语句。</p><p>仅对事务型表如InnoDB有用。与–lock-tables互斥。对于大文件备份–single-transaction与–quick结合使用。</p><p>–flush-logs：刷新日志，生成一个新的二进制日志，主要用户做增量备份</p><p>–max-allowed-packet:可发送或接受的最大包分组长度 </p><p>–no-autocommit：在INSERT前后添加set autocommit=0和commit。</p><p>–order-by-primary:将备份的表中的行按主键排序或者第一个唯一键排序。</p><p>当备份MyISAM表且将被载入到InnoDB表时很有用，打包备份本身的时间会较长。</p><p>–quick:强制mysqldump将查询得到的结果直接输出到文件，不缓存到内存中</p><h3 id="生成纯文本备份文件"><a href="#生成纯文本备份文件" class="headerlink" title="生成纯文本备份文件"></a>生成纯文本备份文件</h3><blockquote><p>除了上述的使用mysqldump命令生成INSERT语句之外，还可以以另一种方式备份数据库，即将数据库中的数据以特定的分隔字符的形式分隔记录在文本文件中，以达到逻辑备份的效果。这样的备份数据与INSERT语句相比，须要使用的存储空间更小，数据格式更加清晰明确，编辑方便。但是缺点是在同一备份文件中不能存在多个表的备份数据，没有数据结构的重建命令。以至于导致备份文件过多，维护和恢复成本会有所增加。</p></blockquote><p>在MySQL中，它为我们提供了一种SELECT语法(select …into outfile from …)，让用户可以通过Query查询语句将某些特定数据以指定格式输出到文本文件中，同时也提供了使用的工具和相关的命令，比如source命令，可以方便地将这写备份文件导入到数据中。</p><p>语法结构如下：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">outfile</span> filename <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span></code></pre><p>在执行备份语句时需要注意以下几个参数：</p><ul><li>FIELDS ESCAPEDBY[‘name’]：实现字符转义功能，将Query语句要转义的字符进行转义操作。</li><li>FIELDS[OPTIONALLY] ENCLOSED BY ‘name’：将字段的内容包装起来。</li><li>FIELDS TERMINATED BY：设置两个字段之间的分隔符。</li><li>LINES TERMINATED BY：设置MySQL输出文件在每条字符结束时要添加的分隔符。</li></ul><p>示例：</p><p>现有一张学生数据表，其中num代表学号，class_id代表班级id</p><pre><code class="hljs plain">idname num     class_idad4cca53d9c111e8a0df000c2928fdc8学生320130032ad4cca5ed9c111e8a0df000c2928fdc8学生420130042ad4cca69d9c111e8a0df000c2928fdc8学生520130052ad4cca71d9c111e8a0df000c2928fdc8学生620130062ad4cca78d9c111e8a0df000c2928fdc8学生720130072ad4cca80d9c111e8a0df000c2928fdc8学生820130082ad4cca88d9c111e8a0df000c2928fdc8学生920130092ad4cca90d9c111e8a0df000c2928fdc8学生1020130102ad4cca98d9c111e8a0df000c2928fdc8学生1120130113ad4ccaa0d9c111e8a0df000c2928fdc8学生1220130123ad4ccaa8d9c111e8a0df000c2928fdc8学生1320130133ad4ccaafd9c111e8a0df000c2928fdc8学生1420130143ad4ccab6d9c111e8a0df000c2928fdc8学生1520130153ad4ccabed9c111e8a0df000c2928fdc8学生1620130164ad4ccac4d9c111e8a0df000c2928fdc8学生1720130174ad4ccacbd9c111e8a0df000c2928fdc8学生1820130184ad4ccad1d9c111e8a0df000c2928fdc8学生1920130194ad4ccad8d9c111e8a0df000c2928fdc8学生2020130204</code></pre><p>现在需要备份所有班级id为2的学生数据</p><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">into</span> <span class="hljs-keyword">outfile</span> <span class="hljs-string">'/home/temp/test.txt'</span> <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">','</span> <span class="hljs-keyword">optionally</span> <span class="hljs-keyword">enclosed</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'"'</span> <span class="hljs-keyword">lines</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">';'</span> <span class="hljs-keyword">from</span> student <span class="hljs-keyword">where</span> class_id = <span class="hljs-number">2</span>;</code></pre><p>备份结果如下：</p><pre><code class="hljs plain">&quot;2&quot;,&quot;test&quot;,0,&quot;2&quot;;&quot;ad4cca53d9c111e8a0df000c2928fdc8&quot;,&quot;学生3&quot;,2013003,&quot;2&quot;;&quot;ad4cca5ed9c111e8a0df000c2928fdc8&quot;,&quot;学生4&quot;,2013004,&quot;2&quot;;&quot;ad4cca69d9c111e8a0df000c2928fdc8&quot;,&quot;学生5&quot;,2013005,&quot;2&quot;;&quot;ad4cca71d9c111e8a0df000c2928fdc8&quot;,&quot;学生6&quot;,2013006,&quot;2&quot;;&quot;ad4cca78d9c111e8a0df000c2928fdc8&quot;,&quot;学生7&quot;,2013007,&quot;2&quot;;&quot;ad4cca80d9c111e8a0df000c2928fdc8&quot;,&quot;学生8&quot;,2013008,&quot;2&quot;;&quot;ad4cca88d9c111e8a0df000c2928fdc8&quot;,&quot;学生9&quot;,2013009,&quot;2&quot;;&quot;ad4cca90d9c111e8a0df000c2928fdc8&quot;,&quot;学生10&quot;,2013010,&quot;2&quot;;</code></pre><h4 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h4><p>在执行SELECT…INTO OUTFILE FROM…备份命令时，第一次使用可能会提下一面的字符：</p><pre><code class="hljs plain">The MySQL server is running with the --secure-file-priv option so it cannot execute this statement</code></pre><p>这是因为MySQL中的secure-file-priv参数默认为NULL，该函数的含义为：</p><ul><li>为NULL时：表示不允许mysql进行导入导出操作。</li><li>为一个具体路径时，如/home/temp：表示mysql只能在指定目录中进行导入导出操作。</li><li>为空字符串时：表示mysql可以在任意目录执行导入导出操作。</li></ul><p>当然我们可以在mysql中查询secure-file-priv的值，查询命令为：</p><pre><code class="hljs plain">show global variables like &#39;%secure_file_priv%&#39;;</code></pre><p>另外，修改secure-file-priv值得方法为，在mysql的配置文件中[mysqld]下添加一行：</p><pre><code class="hljs plain">[mysql]secure_file_priv&#x3D;&#39;&#39;</code></pre><h3 id="逻辑备份恢复"><a href="#逻辑备份恢复" class="headerlink" title="逻辑备份恢复"></a>逻辑备份恢复</h3><p>对于INSERT语句形式的备份文件的恢复最简单，直接使用source命令：</p><pre><code class="hljs plain">source .&#x2F;home&#x2F;temp.sql</code></pre><p>对于纯文本的备份文件，需要使用LOAD DATA INFILE命令来进行，由于纯文本备份是针对单个表进行的，所以恢复同样的也只能针对单个表进行恢复。</p><p>LOAD DATA INFILE命令可以较快地将一个文本文件中的数据读取到数据表中的命令。它是SELECT … INTO OUTFILE FROM…的补充，主要将其备份的文件导入到数据库中。</p><pre><code class="hljs plain">LOAD DATA [LOW_PRIORITY | CONCURRENT] [LOCAL] INFILE &#39;FILENAME&#39;    [REPLACE | IGNORE]    INTO TABLE tbl_name    [PARTITION (partition_name,...)]    [CHARACTER SET charset_name]    [&#123;FIELDS | COLUMNS&#125;        [TERMINATED BY &#39;string&#39;]        [[OPTIONALLY] ENCLOSED BY &#39;char&#39;]        [ESCAPED BY &#39;char&#39;]    ]    [LINES        [STARTING BY &#39;string&#39;]        [TERMINATED BY &#39;string&#39;]    ]    [IGNORE number &#123;LINES | ROWS&#125;]    [(col_name_or_user_var,...)]    [SET col_name &#x3D; expr,...]</code></pre><p>参数解释：</p><ul><li>FILENAME：备份文件地址。</li><li>LOW_PRIORITY：锁表，如果有客户端执行查询操作，则会被阻塞。</li><li>CONCURRENT：取消锁表，允许在客户端在恢复过程查询数据。</li><li>LOCAL：客服端服务器均配置后可以查找客户端上的备份文件。</li><li>REPLACE 与 IGNORE：控制输入的行与唯一主键的重复。</li><li>REPLACE：输入数据替换已经存在的数据。</li><li>IGNORE：输入数据与已经存在的数据的主键或唯一索引重复，则丢弃。</li><li>LINES STARTING BY ‘prefix_string’：跳过指定的前缀prefix_string（以及前缀前面所有的字符），如果该行不包括指定的前缀，则整个行都被跳过。</li><li>CHARACTER SET：指定编码格式。</li><li>FIELDS ESCAPEDBY[‘name’]：实现字符转义功能，将Query语句要转义的字符进行转义操作。</li><li>FIELDS[OPTIONALLY] ENCLOSED BY ‘name’：安装字段的包装进行解析。</li><li>FIELDS TERMINATED BY：根据字段分隔符进行解析。</li><li>LINES TERMINATED BY：根据行分隔符进行解析。</li></ul><p>示例，针对上面的备份进行恢复:</p><pre><code class="hljs sql"><span class="hljs-keyword">load</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">infile</span> <span class="hljs-string">'/home/temp/test2.txt'</span> <span class="hljs-keyword">ignore</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> student <span class="hljs-keyword">fields</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">','</span> <span class="hljs-keyword">enclosed</span> <span class="hljs-keyword">by</span> <span class="hljs-string">'"'</span> <span class="hljs-keyword">lines</span> <span class="hljs-keyword">terminated</span> <span class="hljs-keyword">by</span> <span class="hljs-string">';'</span>;</code></pre><h3 id="逻辑备份总结"><a href="#逻辑备份总结" class="headerlink" title="逻辑备份总结"></a>逻辑备份总结</h3><p>逻辑备份需要手动进行操作，或者书写相应的服务器脚本进行操作，并且逻辑备份不能备份数据的每一个时刻的数据，同样的逻辑备份不能快速恢复，或者说当数据量过大时，使用命令进行恢复的速度会十分缓慢。</p><p>当然逻辑备份也不是一无是处，其优点如下：</p><ul><li>通过逻辑备份，可以执行相关的Query命令把数据库中的数据完全恢复到备份时的状态，而不影响其他的数据。</li><li>通过全库的逻辑备份，可以在一个全新的MySQL环境下完全重建一个与备份时候完全一样的数据库，并不受MySQL所处的平台差异（Linux、Windows）的影响。</li><li>听过特定的条件的逻辑备份，可以将某写特定的数据轻松迁移（同步）其他数据库环境（如果目标环境不是MySQL环境，需要按照目标数据库设置其备份的格式）。</li><li>通过逻辑备份，可以仅仅恢复备份集中的部分数据而不需要全部恢复。</li></ul><h2 id="日志备份"><a href="#日志备份" class="headerlink" title="日志备份"></a>日志备份</h2><blockquote><p>对于MySQL而言，除了全量备份，还有一个根据二进制日志进行增量备份的方式，这也是MySQL常用的一种备份方式。</p></blockquote><h3 id="binlog日志"><a href="#binlog日志" class="headerlink" title="binlog日志"></a>binlog日志</h3><p>首先需要在配置文件中开启binlog，开启方式为在MySQL配置文件中设置log文件地址：</p><pre><code class="hljs plain">log-bin&#x3D;文件路径</code></pre><p>还有一些其他与binlog相关的配置为：</p><pre><code class="hljs plain">binlog_format   &#x3D; ROW #binlog日志格式，默认为STATEMENTlog-bin &#x3D; 文件路径  # binlog日志文件expire_logs_days&#x3D; 7   #binlog过期清理时间max_binlog_size &#x3D; 100m   #binlog每个日志文件大小binlog_cache_size   &#x3D; 4m #binlog缓存大小max_binlog_cache_size   &#x3D; 512m #最大binlog缓存大小</code></pre><p>你也可以使用命令查询binlog状态，查询结果为ON则代表binlog已开启。</p><pre><code class="hljs plain">mysql&gt; show variables like &#39;log_bin&#39;;+---------------+-------+| Variable_name | Value |+---------------+-------+| log_bin       | ON    |+---------------+-------+1 row in set (0.00 sec)</code></pre><p>对于binlog而言，主要有以下几个命名可以对日志文件进行操作。</p><ul><li>reset master：清空日志文件，重新记录日志</li><li>reset salve：删除master.info、relay-log.info文件，开始一个全新的日志文件</li><li>flush logs：重新开始计算日志，产生一个新的日志文件</li><li>show binary logs：展示日志文件</li><li>show binlog events：查看日志文件中的事件信息，默认显示第一个二进制文件中的事件</li></ul><p>显示指定文件的事件信息</p><pre><code class="hljs plain">show binlog events in &#39;文件名&#39;</code></pre><p>使用from可指定从某一行开始</p><p>使用limit可设置查询的事件数量</p><pre><code class="hljs plain">show binlog events in &#39;文件名&#39; from 2 limit 2,5</code></pre><ul><li>purge binary logs：删除二进制文件</li></ul><pre><code class="hljs plain">purge binary logs to &#39;文件名&#39; #删除指定文件之前的所有文件purge binary logs before &#39;事件&#39; #删除指定事件之前的所有文件</code></pre><p>MySQL的二进制日志文件格式包含行模式、语句模式、混合模式。</p><ul><li>行模式：基于行的日志中事件信息记录每行的变化信息。</li><li>语句模式：基于语句的日志中事件信息包含执行的语句。</li><li>混合模式：混合模式包含上两个模式的事件信息。</li></ul><p>在MySQL中，系统提供了一个工具：mysqlbinlog，利用该工具，可以查看详细的日志。常用的命令有：</p><ul><li>-v(–verbose)：将事件重构为被注释掉的伪sql语句，-vv，展示更详细的信息。</li><li>–start-position，–stop-position：按照指定位置精确解析binlog日志（精确），如不接–stop-positiion则一直到binlog日志结尾</li><li>–start-datetime，–stop-datetime：按照指定时间解析binlog日志（模糊，不准确），如不接–stop-datetime则一直到binlog日志结尾</li><li>-d：指定库的binlog</li><li>-r：重定向到指定文件</li><li>–read-from-remote-server：从远程服务器读取binlog日志文件，此时需要一些参数，-h、-p、-u等。</li></ul><pre><code class="hljs plain">[root@localhost binlog]# mysqlbinlog -v logs.000001...省略部分输出内容# at 350#181027  9:45:37 server id 1  end_log_pos 399 CRC32 0x53e0e255  Delete_rows: table id 109 flags: STMT_END_FBINLOG &#39;AWzUWxMBAAAAOwAAAF4BAAAAAG0AAAAAAAEABHRlc3QAB3N0dWRlbnQABA8PAw8GYACHAGAAAN6ETRU&#x3D;AWzUWyABAAAAMQAAAI8BAAAAAG0AAAAAAAEAAgAE&#x2F;&#x2F;ABMgR0ZXN0AAAAAAEyVeLgUw&#x3D;&#x3D;&#39;&#x2F;*!*&#x2F;;### DELETE FROM &#96;test&#96;.&#96;student&#96;### WHERE###   @1&#x3D;&#39;2&#39;###   @2&#x3D;&#39;test&#39;###   @3&#x3D;0###   @4&#x3D;&#39;2&#39;# at 399#181027  9:45:37 server id 1  end_log_pos 430 CRC32 0xd9e0d019  Xid &#x3D; 30COMMIT&#x2F;*!*&#x2F;;SET @@SESSION.GTID_NEXT&#x3D; &#39;AUTOMATIC&#39; &#x2F;* added by mysqlbinlog *&#x2F; &#x2F;*!*&#x2F;;DELIMITER ;# End of log file&#x2F;*!50003 SET COMPLETION_TYPE&#x3D;@OLD_COMPLETION_TYPE*&#x2F;;&#x2F;*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE&#x3D;0*&#x2F;;</code></pre><h3 id="基于日志恢复"><a href="#基于日志恢复" class="headerlink" title="基于日志恢复"></a>基于日志恢复</h3><p>首先查看binlog日志文件，从中找出被删除的记录。在上面一个示例中，清晰可见该日志记录一个数据库的删除记录。在日志文件中有一句<code>at 350</code>，该标记的意思为该日志的事件开始位置，另外在末尾有一个<code>at 399</code>，该标记表示该条日志的事件结束位置。如果我们想恢复这条记录，需要先将数据库恢复到位置350之前，如果这是最后一个日志，那么恢复操作就完成了。但是大多数情况下，该条日志后肯定是存在日志的。所以此时需要在恢复到位置350之前后，跳过该日志，继续恢复后面的日志信息。当然，由于日志文件中，清晰的存储了该行数据的所以信息，所以你也可以根据这条日志，手动在数据库中插入。另外也可以根据事件发生的时间来进行恢复，使用时间恢复的话可以免除寻找时间位置的过程，但前提是你的清晰记得操作时间。</p><p>恢复数据库到指定位置命令：</p><pre><code class="hljs plain">mysqlbinlog --stop-position&#x3D;350 logs.000001 |mysql -uroot -pmysqlbinlog --start-position&#x3D;399 logs.000001 |mysql -uroot -p</code></pre><p>恢复数据库到指定日期命令：</p><pre><code class="hljs plain">[root@localhost &#x2F;]# mysqlbinlog --stop-datetime&#x3D;&quot;2017-09-28 04:00:00&quot; logs.000001 | mysql -u root -p[root@localhost &#x2F;]# mysqlbinlog --start-datetime&#x3D;&quot;2017-09-28 40:00:00&quot; logs.000001 | mysql -u root -p</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SQL CRUD语句</title>
    <link href="/2018/07/16/database/SQL%20CRUD%E8%AF%AD%E5%8F%A5/"/>
    <url>/2018/07/16/database/SQL%20CRUD%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-CRUD语句"><a href="#SQL-CRUD语句" class="headerlink" title="SQL CRUD语句"></a>SQL CRUD语句</h1><blockquote><p>下文以MySQL为例进行说明。<br><code>CRUD</code>即增加(Create)、查询(Retrieve)、更新(Update)、删除(Delete)四个单词的首字母缩写。</p></blockquote><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先准备在MySQL数据库中创建两张表：学生表（student）、班级表(class)，建表语句如下：</p><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">class</span>(<span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span>,<span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">'班级名称'</span>, PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>))<span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student (  <span class="hljs-keyword">id</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span>,  <span class="hljs-keyword">name</span> <span class="hljs-built_in">varchar</span>(<span class="hljs-number">45</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">'学生姓名'</span>,  <span class="hljs-keyword">num</span> <span class="hljs-built_in">int</span> <span class="hljs-keyword">NOT</span> <span class="hljs-literal">NULL</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">'学生学号'</span>,class_id <span class="hljs-built_in">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">not</span> <span class="hljs-literal">null</span> <span class="hljs-keyword">comment</span> <span class="hljs-string">'班级id'</span>,  PRIMARY <span class="hljs-keyword">KEY</span> (<span class="hljs-keyword">id</span>)) <span class="hljs-keyword">ENGINE</span>=<span class="hljs-keyword">InnoDB</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">CHARSET</span>=utf8;</code></pre><p>像表中插入一些测试数据，插入四个班级，往每个班级分别插入五名学生：</p><pre><code class="hljs plain">INSERT INTO class VALUES (&#39;1&#39;,&#39;1班&#39;),(&#39;2&#39;,&#39;2班&#39;),(&#39;3&#39;,&#39;3班&#39;),(&#39;4&#39;,&#39;4班&#39;);INSERT INTO student VALUE(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生1&#39;,2013001,&#39;1&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生2&#39;,2013002,&#39;1&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生3&#39;,2013003,&#39;1&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生4&#39;,2013004,&#39;1&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生5&#39;,2013005,&#39;1&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生6&#39;,2013006,&#39;2&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生7&#39;,2013007,&#39;2&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生8&#39;,2013008,&#39;2&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生9&#39;,2013009,&#39;2&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生10&#39;,2013010,&#39;2&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生11&#39;,2013011,&#39;3&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生12&#39;,2013012,&#39;3&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生13&#39;,2013013,&#39;3&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生14&#39;,2013014,&#39;3&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生15&#39;,2013015,&#39;3&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生16&#39;,2013016,&#39;4&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生17&#39;,2013017,&#39;4&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生18&#39;,2013018,&#39;4&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生19&#39;,2013019,&#39;4&#39;),(replace(UUID(),&#39;-&#39;,&#39;&#39;),&#39;学生20&#39;,2013020,&#39;4&#39;)</code></pre><p>其中：</p><p>UUID()为MySQL中的函数，作用为生成一个随机字符串</p><p>replace为MySQL中的函数，作用为替换字符串中的’-‘字符</p><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>在使用SQL的过程中，我们可以为列名称和表名称指定别名（Alias）。</p><p>别名在执行CRUD操作时有着很大的作用。</p><p>指定别名的语法为在原名称后添加 AS XXX（别名），其中AS可以省略。</p><p>对于上面的两张表，我们可以为class、student分别指定别名cla,stu。</p><pre><code class="hljs plain">SELECT cla.id,lca.name FROM class as claSELECT stu.id,stu,name,stu.num,stu.class_id FROM student stu</code></pre><h2 id="增加-Create"><a href="#增加-Create" class="headerlink" title="增加(Create)"></a>增加(Create)</h2><p>增加数据只用INSERT INTO语句：</p><pre><code class="hljs plain">INSERT INTO TABLE VALUE (value1,value2)</code></pre><p>上面的语句是默认给表的所有字段插入值，VALUE后面的值的顺序与表字段顺序一直，其个数也必须与表字段个数一直。</p><p>当然，我们也可指定要插入数据的列：</p><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> (column1,column2) <span class="hljs-keyword">VALUE</span> (value1,value2)</code></pre><p>如果要一次插入多条数据（批量插入），可以在VALUE后添加多个代码块：</p><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">VALUE</span> (value1,value2),(value1,value2)</code></pre><p>在执行批量插入时，应注意SQL的长度限制，批量插入的脚本不能超过数据库设置的SQL最大长度。</p><p>在执行插入语句时还可以增加子查询语句，但语法要求是，子查询返回的字段要与INSERT的插入字段一致</p><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> table1;<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table1 (column1,column2) <span class="hljs-keyword">SELECT</span> column1,column2 <span class="hljs-keyword">FROM</span> table2</code></pre><h2 id="查询-Retrieve"><a href="#查询-Retrieve" class="headerlink" title="查询(Retrieve)"></a>查询(Retrieve)</h2><p>查询语句使用SELECT命令即可：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column1,column2 <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span></code></pre><p>查询所有字段可使用*，不过一般不推荐这样操作</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span></code></pre><h3 id="子查询："><a href="#子查询：" class="headerlink" title="子查询："></a>子查询：</h3><p>SQL子查询也叫嵌套SELECT语句，一个SELECT语句的查询结果能够作为另一个语句的输入值。子查询能够出现的地方有：</p><ul><li>WHERE子句：左右外层SQL的条件</li></ul><p>查询1班、2班的所有学生：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> stu.name,stu.num <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">as</span> stu <span class="hljs-keyword">where</span> stu.class_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">as</span> cla <span class="hljs-keyword">where</span> cla.name <span class="hljs-keyword">in</span> (<span class="hljs-string">'1班'</span>,<span class="hljs-string">'2班'</span>));</code></pre><p>查询结果为:</p><pre><code class="hljs tex">学生12013001学生22013002学生32013003学生42013004学生52013005学生62013006学生72013007学生82013008学生92013009学生10 2013010</code></pre><ul><li>FROM后：作为一个临时表</li></ul><p>从1班、2班所有学生中查询出学号在2013004到2014006之间的学生：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">num</span><span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> stu.name,stu.num <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">as</span> stu <span class="hljs-keyword">where</span> stu.class_id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">as</span> cla <span class="hljs-keyword">where</span> cla.name <span class="hljs-keyword">in</span> (<span class="hljs-string">'1班'</span>,<span class="hljs-string">'2班'</span>))) temp_talbe<span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2013004</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2013006</span></code></pre><p>查询结果为:</p><pre><code class="hljs tex">学生42013004学生52013005学生62013006</code></pre><ul><li>COLUMN：COLUMN，即SELECT后面，作为一个字段值来返回，这里内层SQL只能返回一个字段</li></ul><p>根据学号查询学生的姓名、班级信息</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> stu.name,stu.num,(<span class="hljs-keyword">SELECT</span> cla.name <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">as</span> cla <span class="hljs-keyword">where</span> cla.id = stu.class_id) <span class="hljs-keyword">as</span> class_name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">as</span> stu <span class="hljs-keyword">where</span> stu.num = <span class="hljs-number">2013004</span></code></pre><p>查询结果为：</p><pre><code class="hljs tex">学生420130041班</code></pre><ul><li>JOIN子句：作为一个临时表</li></ul><p>从1班、2班所有学生中查询出学号在201304到201406之间的学生：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> stu.name,stu.num<span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">as</span> stu <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">id</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">as</span> cla <span class="hljs-keyword">where</span> cla.name <span class="hljs-keyword">in</span> (<span class="hljs-string">'1班'</span>,<span class="hljs-string">'2班'</span>)) <span class="hljs-keyword">as</span> cla<span class="hljs-keyword">ON</span> cla.id = stu.class_id<span class="hljs-keyword">WHERE</span> stu.num <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2013004</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2013006</span></code></pre><p>查询结果为：</p><pre><code class="hljs plain">学生42013004学生52013005学生62013006</code></pre><h2 id="更新-Update"><a href="#更新-Update" class="headerlink" title="更新(Update)"></a>更新(Update)</h2><p>更新表使用UPDATE语法，将已有的老数据更新为新数据。</p><pre><code class="hljs plain">UPDATE table SET column1 &#x3D; value1 WHERE 条件</code></pre><p>注意，如果不加WHERE条件，UPDATE语句会默认更新所有表，慎用。</p><p>一次更新多个字段，在SET后面添加多个column：</p><pre><code class="hljs plain">UPDATE table SET column1 &#x3D; value1,column1 &#x3D; value1 WHERE 条件</code></pre><h3 id="联表更新"><a href="#联表更新" class="headerlink" title="联表更新"></a>联表更新</h3><p>联表更新，根据表一字段的值去设置表二字段的值。其实现方法由于数据库不同可能会有一定差异，下面以MySQL为例。</p><p>例如：将学号在2013003到2013005之间的学生的class_id设置为二班的id。</p><p>对于MySQL而言，联表更新主要的方式有二种：</p><ul><li>UPDATE table1,table2 set column1 = xxx where ….</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> student stu,<span class="hljs-keyword">class</span> cla<span class="hljs-keyword">set</span> stu.class_id = cla.id<span class="hljs-keyword">where</span> stu.num <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2013003</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2013005</span><span class="hljs-keyword">AND</span> cla.name = <span class="hljs-string">'2班'</span>;</code></pre><ul><li>使用INNER JOIN（LEFT JOIN）进行更新：</li></ul><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> student stu<span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">class</span> cla <span class="hljs-keyword">ON</span> cla.name = <span class="hljs-string">'2班'</span><span class="hljs-keyword">SET</span> stu.class_id = cla.id<span class="hljs-keyword">where</span> stu.num <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2013003</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2013005</span></code></pre><p>执行下面SQL验证结果：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">name</span>,<span class="hljs-keyword">num</span>,class_id <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">where</span> <span class="hljs-keyword">num</span> <span class="hljs-keyword">BETWEEN</span> <span class="hljs-number">2013003</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">2013005</span>学生<span class="hljs-number">3</span><span class="hljs-number">2013003</span><span class="hljs-number">2</span>学生<span class="hljs-number">4</span><span class="hljs-number">2013004</span><span class="hljs-number">2</span>学生<span class="hljs-number">5</span><span class="hljs-number">2013005</span><span class="hljs-number">2</span></code></pre><p>在进行UPDATE语句是也可以在其中加入子查询语句。</p><h2 id="删除-Delete"><a href="#删除-Delete" class="headerlink" title="删除(Delete)"></a>删除(Delete)</h2><p>删除使用DELETE语法</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">WHERE</span> column1 = value1</code></pre><p>DELETE语法与UPDATE语法一直，如果没有WHERE条件则会删除指定表的所有数据。</p><h4 id="联表删除"><a href="#联表删除" class="headerlink" title="联表删除"></a>联表删除</h4><ul><li>根据table2的条件删除table1的数据</li></ul><p>删除所有一班的学生：</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> student <span class="hljs-keyword">FROM</span> student,<span class="hljs-keyword">class</span> <span class="hljs-keyword">WHERE</span> class.id = student.class_id <span class="hljs-keyword">and</span> class.name = <span class="hljs-string">'1班'</span></code></pre><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> student <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">ON</span> class.id = student.class_id <span class="hljs-keyword">where</span> class.name = <span class="hljs-string">'1班'</span></code></pre><p>注意，此处的student,即表名，不能使用别名。</p><ul><li>同时删除两个表的记录</li></ul><p>删除一班，并删除一班下面的所有学生：</p><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">class</span>,student <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">class</span> <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> student <span class="hljs-keyword">ON</span>  class.id = student.class_id <span class="hljs-keyword">WHERE</span> class.name = <span class="hljs-string">'1班'</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库基础</title>
    <link href="/2018/07/16/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <url>/2018/07/16/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><p>ACID，NULL，MVCC，约束、概念模型、第三范式、连接</p><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><p>ACID即数据库的四大特性：</p><ul><li>原子性（Atomicity）：指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。</li><li>一致性（Consistency）：指在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</li><li>隔离性（Isolation）：指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</li><li>持久性（Durability）：意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</li></ul><h2 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h2><p>在SQL中，NULL用于表示缺失的值，数据表中的 NULL 值表示该值所处的字段为空。</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC是一种多版本并发控制机制。它使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销,就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p><ul><li>大多数的MySQL事务型存储引擎，如InnoDB都不止使用简单的行加锁机制，都和MVCC-多版本并发控制一起使用。</li><li>锁机制可以控制并发操作,但是其系统开销较大,而MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。</li></ul><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>数据的完整性是指数据的正确性和一致性，可以通过定义表时定义完整性约束，也可以通过规则，索引，触发器等。约束分为两类：行级和表级，处理机制是一样的。行级约束放在列后，表级约束放在表后，多个列共用的约束放在表后。</p><p>完整性约束是一种规则，不占用任何数据库空间。完整性约束存在数据字典中，在执行SQL或PL/SQL期间使用。用户可以指明约束是启用的还是禁用的，当约束启用时，他增强了数据的完整性，否则，则反之，但约束始终存在于数据字典中。</p><p>约束类型：</p><ul><li>唯一性 UNIQUE</li><li>主键约束 Primary Key</li><li>外键约束 Foreign Key</li><li>检查约束 CHECK</li><li>空值约束 NOT NULL</li><li>默认值约束 DEFAULT</li></ul><h2 id="三大模型"><a href="#三大模型" class="headerlink" title="三大模型"></a>三大模型</h2><p>概念模型：对一个具体业务的抽象，确定领域实体属性关系，使用E-R图进行表示。</p><p>E-R图：由实体、属性和联系三个要素构成。</p><p>逻辑模型：将概念模型转化为具体的数据模型的过程，即按照概念结构设计阶段建立的基本E-R图，按选定的管理系统软件支持的数据模型（层次、网状、关系、面向对象），转换成相应的逻辑模型。这种转换要符合关系数据模型的原则。目前最流行就是关系模型（也就是对应的关系数据库）</p><p>物理模型：根据逻辑模型对应到具体的数据模型的机器实现。</p><h2 id="第一范式-1NF"><a href="#第一范式-1NF" class="headerlink" title="第一范式 1NF"></a>第一范式 1NF</h2><p>强调的是<strong>列的原子性</strong>，即列不能够再分成其他几列</p><p>在任何一个关系数据库中，第一范式（1NF）是对关系模式的设计基本要求，一般设计中都必须满足第一范式（1NF）。不过有些关系模型中突破了1NF的限制，这种称为非1NF的关系模型。换句话说，是否必须满足1NF的最低要求，主要依赖于所使用的关系模型。</p><h2 id="第二范式-2NF"><a href="#第二范式-2NF" class="headerlink" title="第二范式 2NF"></a>第二范式 2NF</h2><p>数据库表中的每个实例或行必须可以被惟一地区分，并且有一个唯一的属性去标记该行（实体），这个属性一般被称为<code>主键</code>实体的属性<strong>完全依赖</strong>于其。</p><ul><li>表必须有一个主键</li><li>没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分</li></ul><h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p><strong>3NF在2NF的基础之上，消除了非主属性对于主键的传递函数依赖</strong>。也就是说， 如果存在非主属性对于主键的传递函数依赖，则不符合3NF的要求。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL安装</title>
    <link href="/2018/07/16/database/MySQL/MySQL%E5%AE%89%E8%A3%85/"/>
    <url>/2018/07/16/database/MySQL/MySQL%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL安装"><a href="#MySQL安装" class="headerlink" title="MySQL安装"></a>MySQL安装</h1><h2 id="Linux下安装MySQL"><a href="#Linux下安装MySQL" class="headerlink" title="Linux下安装MySQL"></a>Linux下安装MySQL</h2><h3 id="使用yum方式安装"><a href="#使用yum方式安装" class="headerlink" title="使用yum方式安装"></a>使用yum方式安装</h3><blockquote><p>yum方式安装方式摘自菜鸟教程(<a href="http://www.runoob.com/mysql/mysql-install.html" target="_blank" rel="noopener">http://www.runoob.com/mysql/mysql-install.html</a>)</p></blockquote><p>Linux平台上推荐使用RPM包来安装Mysql,MySQL AB提供了以下RPM包的下载地址： </p><ul><li><strong>MySQL</strong> - MySQL服务器。你需要该选项，除非你只想连接运行在另一台机器上的MySQL服务器。</li><li><strong>MySQL-client</strong> - MySQL 客户端程序，用于连接并操作Mysql服务器。</li><li><strong>MySQL-devel</strong> - 库和包含文件，如果你想要编译其它MySQL客户端，例如Perl模块，则需要安装该RPM包。</li><li><strong>MySQL-shared</strong> - 该软件包包含某些语言和应用程序需要动态装载的共享库(libmysqlclient.so*)，使用MySQL。</li><li><strong>MySQL-bench</strong> - MySQL数据库服务器的基准和性能测试工具。</li></ul><h4 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h4><p>安装前，我们可以检测系统是否自带安装 MySQL: </p><pre><code class="hljs tex">rpm -qa | grep mysql</code></pre><p>如果你系统有安装，那可以选择进行卸载: </p><pre><code class="hljs tex">rpm -e mysql　　// 普通删除模式rpm -e --nodeps mysql　　// 强力删除模式，如果使用上面命令删除时，提示有依赖的其它文件，则用该命令可以对其进行强力删除</code></pre><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><p>接下来我们在 Centos7 系统下使用 yum 命令安装 MySQL，需要注意的是 CentOS 7 版本中 MySQL数据库已从默认的程序列表中移除，所以在安装前我们需要先去官网下载 Yum 资源包，下载地址为：<a href="https://dev.mysql.com/downloads/repo/yum/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/repo/yum/</a> </p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/database/MySQLyum%E4%B8%8B%E8%BD%BD%E6%88%AA%E5%9B%BE.png" srcset="/img/loading.gif" alt="MySQLyum下载截图"></p><pre><code class="hljs plain">wget https:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql57-community-release-el7-9.noarch.rpmrpm -ivh mysql57-community-release-el7-9.noarch.rpmyum install mysql-server</code></pre><p>初始化 MySQL： </p><pre><code class="hljs plain">mysqld --initialize</code></pre><p>启动 MySQL： </p><pre><code class="hljs plain">systemctl start mysqld</code></pre><p>查看 MySQL 运行状态： </p><pre><code class="hljs plain">systemctl status mysqld</code></pre><p><strong>注意：</strong>如果我们是第一次启动 mysql 服务，mysql 服务器首先会进行初始化的配置。 </p><h4 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h4><p>Mysql安装成功后，默认的root用户密码为空，你可以使用以下命令来创建root用户的密码： </p><pre><code class="hljs plain">[root@host]# mysqladmin -u root password &quot;new_password&quot;</code></pre><p>现在你可以通过以下命令来连接到Mysql服务器： </p><pre><code class="hljs plain">[root@host]# mysql -u root -pEnter password:*******</code></pre><h3 id="使用tar包解压安装"><a href="#使用tar包解压安装" class="headerlink" title="使用tar包解压安装"></a>使用tar包解压安装</h3><h4 id="安装准备-1"><a href="#安装准备-1" class="headerlink" title="安装准备"></a>安装准备</h4><p>首先在官网<a href="https://dev.mysql.com/downloads/mysql/5.7.html#downloads" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/5.7.html#downloads</a>中下载<code>MySQL Community Server</code></p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/database/%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E6%88%AA%E5%9B%BE.png" srcset="/img/loading.gif" alt="MySQL.tar官方下载截图"></p><pre><code class="hljs plain">weget https:&#x2F;&#x2F;cdn.mysql.com&#x2F;&#x2F;Downloads&#x2F;MySQL-5.7&#x2F;mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz</code></pre><h4 id="开始安装-1"><a href="#开始安装-1" class="headerlink" title="开始安装"></a>开始安装</h4><pre><code class="hljs plain">[root@localhost home]# tar -zvxf mysql-5.7.22-linux-glibc2.12-x86_64.tar.gz [root@localhost home]# mv mysql-5.7.22-linux-glibc2.12-x86_64 &#x2F;usr&#x2F;local&#x2F;mysqlcd &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;</code></pre><p>在安装过程中，我是将mysql安装在/usr/local/mysql目录下，当然你也可以自定义你的安装位置</p><p>此时在mysql/support-files里一般会有一个my-default.cnf。如果你的版本高于5.7.18的话，那么是没有my-default.cnf文件的，此时就需要自己创建一个。</p><p>官网说明如下：</p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html</a></p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/database/%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E6%88%AA%E5%9B%BE.png" srcset="/img/loading.gif" alt="Mysql官方说明"></p><p>my-default.cnf内容如下：</p><pre><code class="hljs plain"># For advice on how to change settings please see# http:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It&#39;s a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL. [mysqld]sql_mode&#x3D;NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES  # 一般配置选项basedir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysqldatadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;dataport &#x3D; 3306socket &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysqld.sockcharacter-set-server&#x3D;utf8 back_log &#x3D; 300max_connections &#x3D; 3000max_connect_errors &#x3D; 50table_open_cache &#x3D; 4096max_allowed_packet &#x3D; 32M#binlog_cache_size &#x3D; 4M max_heap_table_size &#x3D; 128Mread_rnd_buffer_size &#x3D; 16Msort_buffer_size &#x3D; 16Mjoin_buffer_size &#x3D; 16Mthread_cache_size &#x3D; 16query_cache_size &#x3D; 128Mquery_cache_limit &#x3D; 4Mft_min_word_len &#x3D; 8 thread_stack &#x3D; 512Ktransaction_isolation &#x3D; REPEATABLE-READtmp_table_size &#x3D; 128M#log-bin&#x3D;mysql-binlong_query_time &#x3D; 6server_id&#x3D;1 innodb_buffer_pool_size &#x3D; 1Ginnodb_thread_concurrency &#x3D; 16innodb_log_buffer_size &#x3D; 16M innodb_log_file_size &#x3D; 512Minnodb_log_files_in_group &#x3D; 3innodb_max_dirty_pages_pct &#x3D; 90innodb_lock_wait_timeout &#x3D; 120innodb_file_per_table &#x3D; on [mysqldump]quick max_allowed_packet &#x3D; 32M [mysql]no-auto-rehashdefault-character-set&#x3D;utf8safe-updates [myisamchk]key_buffer &#x3D; 16Msort_buffer_size &#x3D; 16Mread_buffer &#x3D; 8Mwrite_buffer &#x3D; 8M [mysqlhotcopy]interactive-timeout [mysqld_safe]open-files-limit &#x3D; 8192[client]socket &#x3D; &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysqld.sock</code></pre><p>复制my-default.cnf到etc目录下</p><pre><code class="hljs plain">[root@localhost mysql]# cp support-files&#x2F;my-default.cnf &#x2F;etc&#x2F;my.cnf</code></pre><p>在my.cnf中，我们需要需要修改一些东西，修改内容如下：</p><ul><li>指定数据库地址</li><li>设置字符</li></ul><pre><code class="hljs plain"># 一般配置选项basedir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysqldatadir &#x3D; &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;dataport &#x3D; 3306socket &#x3D; &#x2F;var&#x2F;run&#x2F;mysqld&#x2F;mysqld.sockcharacter-set-server&#x3D;utf8</code></pre><p>其中需要注意的是，如果你修改了mysql下的socket，对应的还应修改client下得socket</p><p><strong>初始化数据库：</strong></p><p>在进行该步骤的时候，你可以新建一个用户，当然也可以使用root。</p><pre><code class="hljs plain">[root@localhost mysql]# useradd mysql[root@localhost mysql]# chown -R mysql . [root@localhost mysql]# pwd&#x2F;usr&#x2F;local&#x2F;mysql[root@localhost mysql]# .&#x2F;bin&#x2F;mysqld --user&#x3D;mysql --initialize</code></pre><p>在初始化之后，控制台会打印这样一句话：</p><pre><code class="hljs plain">2018-07-22T09:47:53.807466Z 1 [Note] A temporary password is generated for root@localhost: !qfyPBhX.2%l</code></pre><p>这就是MySQL root 账户的默认密码，当然如果你忘记了也没关系，我们可以修改root账户密码，具体见下文(补充说明)。</p><h4 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h4><p>启动mysql</p><pre><code class="hljs plain">[root@localhost mysql]# sudo .&#x2F;bin&#x2F;mysqld --user&#x3D;root</code></pre><p>第一次启动可能会报如下错误：</p><pre><code class="hljs plain">2018-07-22T10:01:40.700536Z 0 [ERROR] Could not create unix socket lock file &#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysqld.sock.lock.2018-07-22T10:01:40.700538Z 0 [ERROR] Unable to setup unix socket lock file.2018-07-22T10:01:40.700540Z 0 [ERROR] Aborting</code></pre><p>这种错误一般都是目录不存在或者权限不足，所以我们手动创建目录：</p><pre><code class="hljs plain">[root@localhost mysql]# mkdir &#x2F;var&#x2F;lib&#x2F;mysql</code></pre><p>连接mysql</p><pre><code class="hljs plain">[root@localhost mysql]# .&#x2F;bin&#x2F;mysql -uroot -pEnter password: mysql&gt;</code></pre><p><strong>另外值得一提的是，如果你是首次登陆，那么mysql会提示使用alter修改密码：</strong></p><pre><code class="hljs plain">mysql&gt; use mysql;ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.</code></pre><p>解决办法：</p><pre><code class="hljs plain">mysql&gt; set password &#x3D; password(&#39;123456&#39;);Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; alter user root@localhost password expire never;Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)</code></pre><p>完成之后再推出重新登陆就可以了。</p><p><strong>另外的启动方式</strong></p><p>在support-files目录下有个mysql.server文件，我们也可通过这个文件启动mysql</p><pre><code class="hljs plain">[root@localhost mysql]# .&#x2F;support-files&#x2F;mysql.server start --user&#x3D;root</code></pre><h2 id="Windows下安装"><a href="#Windows下安装" class="headerlink" title="Windows下安装"></a>Windows下安装</h2><p>关于Windows下得安装方法，主要分为两种，一种为使用官方安装包，另一种为安装绿色版。</p><p>官方安装包下载地址：<a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a></p><p>绿色版安装方式与linux下的tar安装方式大致相同，此处不做多余赘述。</p><h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><h3 id="将MySQL加入到开机自启"><a href="#将MySQL加入到开机自启" class="headerlink" title="将MySQL加入到开机自启"></a>将MySQL加入到开机自启</h3><p>1、将服务文件拷贝到init.d下，并重命名为mysql </p><pre><code class="hljs plain">[root@localhost mysql]# cp &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server &#x2F;etc&#x2F;init.d&#x2F;mysqld</code></pre><p>2、赋予可执行权限 </p><pre><code class="hljs plain">[root@localhost mysql]# chmod +x &#x2F;etc&#x2F;init.d&#x2F;mysqld</code></pre><p>3、添加服务 </p><pre><code class="hljs plain">[root@localhost mysql]# chkconfig --add mysqld</code></pre><p>4、显示服务列表 </p><pre><code class="hljs plain">[root@localhost mysql]# chkconfig --listmysqld          0:off   1:off   2:on    3:on    4:on    5:on    6:off</code></pre><p>此时已经将MySQL服务加入到自启了。</p><p>当然你也可以自己写脚本来实现</p><p>编写脚本如下：</p><pre><code class="hljs plain">#!&#x2F;bin&#x2F;sh## This script will be executed *after* all the other init scripts.# You can put your own initialization stuff in here if you don&#39;t# want to do the full Sys V style init stuff&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server start --user&#x3D;root</code></pre><p>然后在/etc/rc.local脚本的末尾添加一行以绝对路径启动脚本的行;</p><h3 id="MySQL配置文件读取顺序"><a href="#MySQL配置文件读取顺序" class="headerlink" title="MySQL配置文件读取顺序"></a>MySQL配置文件读取顺序</h3><p>在Unix和类Unix系统上，MySQL程序按照指定的顺序从下表中显示的文件中读取启动选项（首先列出的文件首先读取，后面读取的文件优先）。 </p><table><thead><tr><th>文件路径</th><th>说明</th></tr></thead><tbody><tr><td>/etc/my.cnf</td><td>全局选择</td></tr><tr><td>/etc/mysql/my.cnf</td><td>全局选择</td></tr><tr><td><em>SYSCONFDIR</em>/my.cnf</td><td>全局选择</td></tr><tr><td>$MYSQL_HOME/my.cnf</td><td>特定服务器选择</td></tr><tr><td>defaults-extra-file</td><td>特别指定的文件</td></tr><tr><td>~/.my.cnf</td><td>用户特定选项</td></tr><tr><td>~/.mylogin.cnf</td><td>用户特定的登录路径选项（仅限客户端）</td></tr></tbody></table><p>其中，~表示当前用户的主目录（即$HOME）</p><p>SYSCONFDIR表示在构建MySQL时SYSCONFDIR使用CMake选项指定的目录。默认情况下，这是etc位于已编译安装目录下的目录。</p><p>MYSQL_HOME是一个环境变量，包含服务器特定my.cnf文件所在目录的路径 。如果 MYSQL_HOME未设置并使用mysqld_safe程序启动服务器，则 mysqld_safe将其设置 BASEDIR为MySQL基本安装目录。</p><h3 id="MySQL密码修改方式"><a href="#MySQL密码修改方式" class="headerlink" title="MySQL密码修改方式"></a>MySQL密码修改方式</h3><h4 id="使用UPDATE直接编辑user表"><a href="#使用UPDATE直接编辑user表" class="headerlink" title="使用UPDATE直接编辑user表"></a>使用UPDATE直接编辑user表</h4><p>首先登录MySQL</p><pre><code class="hljs plain">mysql&gt; use mysql; mysql&gt; update user set password&#x3D;password(&#39;123&#39;) where user&#x3D;&#39;root&#39; and host&#x3D;&#39;localhost&#39;; mysql&gt; flush privileges;</code></pre><p>上文是针对5.6及其以下的修改方式，如果你是5.7的版本，则会报这样一个错误</p><pre><code class="hljs plain">ERROR 1054 (42S22): Unknown column &#39;passsword&#39; in &#39;field list&#39;</code></pre><p>这是因为，MySQL5.7 password字段已从mysql.user表中删除，新的字段名是“authenticalion_string”。</p><pre><code class="hljs plain">update user set authentication_string&#x3D;password(&#39;123456&#39;) where user&#x3D;&quot;root&quot;;</code></pre><h4 id="使用SET-PASSWORD命令"><a href="#使用SET-PASSWORD命令" class="headerlink" title="使用SET PASSWORD命令"></a>使用SET PASSWORD命令</h4><pre><code class="hljs plain">mysql&gt; set password for 用户名@localhost &#x3D; password(&#39;新密码&#39;); mysql&gt; alter user root@localhost password expire never;mysql&gt; flush privileges;</code></pre><h4 id="使用mysqladmin命令"><a href="#使用mysqladmin命令" class="headerlink" title="使用mysqladmin命令"></a>使用mysqladmin命令</h4><pre><code class="hljs plain">mysql&gt; mysqladmin -u用户名 -p旧密码 password 新密码  mysql&gt; flush privileges;</code></pre><h4 id="忘记MySQL登陆密码时"><a href="#忘记MySQL登陆密码时" class="headerlink" title="忘记MySQL登陆密码时"></a>忘记MySQL登陆密码时</h4><p>先关闭MySQL服务</p><p>执行命令：</p><pre><code class="hljs plain">[root@localhost mysql]#.&#x2F;mysqld_safe --skip-grant-tables &amp;</code></pre><p>执行该命令后mysql会自动重启 ，如果没有重启，请手动启动一下</p><pre><code class="hljs plain">[root@localhost mysql]#.&#x2F;mysqlmysql&gt; flush privileges; mysql&gt; SET PASSWORD FOR &#39;root&#39;@&#39;localhost&#39; &#x3D; PASSWORD(&#39;你的新密码&#39;);</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL性能优化</title>
    <link href="/2018/07/16/database/MySQL/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2018/07/16/database/MySQL/MySQL%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><h2 id="日志优化"><a href="#日志优化" class="headerlink" title="日志优化"></a>日志优化</h2><p>不论是MySQL数据库还是其它数据库，特别是支持事务的数据库而言，其日志需要记录数据服务器中的CURD操作，从而会消耗IO资源，从而影响到数据库性能，特别是操作频繁且数据量大的数据表。对于MySQL而言，其日志主要为二进制日志（BinLog）、错误日志（Error Log）、慢查询日志（Slow Query Log），下面将分别对MySQL的日志优化作出说明。</p><h3 id="BinLog优化"><a href="#BinLog优化" class="headerlink" title="BinLog优化"></a>BinLog优化</h3><p>在实际生产环境中，为保护数据库数据的安全性，我们一般都将会打开BinLog日志进行增量备份。对于MySQL的BinLog日志备份，有三种模式，分别为：行模式、语句模式、混合模式。下面对三种模式分别进行说明：</p><ul><li>行模式：基于行的日志中事件信息记录每行的变化信息。记录没一行数据的修改细节，使用该模式，系统会产生大量的日志内容。</li><li>语句模式：基于语句的日志中事件信息包含执行的语句。每一条修改数据的Query语句都会记录在日志文件中。该模式不需要记录每一行数据的变化，减少了日志内容，降低了IO开销，提高了数据库性能。但由于该模式只记录Query语句，如果Query语句中包含了一些特定的函数等功能，则会使得MySQL复制出现问题。</li><li>混合模式：包含上两个模式的事件信息。在该模式下，MySQL会根据执行的每一条Query语句去动态决定该日志需要的日志模式。</li></ul><p>在使用MySQL的BinLog日志时，我们应按照事迹情况选择日志模式，比如减少对于特定函数、存储过程的使用，从而提高语句模式的使用率，尽量减少行模式的使用。</p><p><strong>BinLog参数:</strong></p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'%binlog%'</span>;</code></pre><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>binlog_cache_size</td><td>表示事务过程中容纳二进制日志SQL语句的缓存大小。默认值为32K，如果事务过多需要增加该配置大小。</td></tr><tr><td>innodb_locks_unsafe_for_binlog</td><td>innodb引擎特有的配置，设置是否启用间隙锁，默认为off，即开启间隙锁。</td></tr><tr><td>max_binlog_cache_size</td><td>日志最大缓存大小。使用形式文件存储来自事务的变化。该参数不宜太小。</td></tr><tr><td>max_binlog_size</td><td>binlog的最大值，一边设置为523m或1G，但一般不超过1G。</td></tr><tr><td>sync_binlog</td><td>事务同步设置，在binlog中该参数尤为重要，该配置如果为0，则MySQL会让文件系统自行决定什么时候同步到磁盘中，如果为n，则代表经过n此事务后，将事务同步到磁盘中，如果为1，则代表每次提交事务后头同步到磁盘中。该参数默认值为0，如果要修改该参数，需要注意两点，一是设置为1能保证最大限度保证数据安全，但性能开销大；二是设置为其他值，可以减少性能消耗，但数据安全性较低。</td></tr></tbody></table><h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>在MySQL中可以做通过慢查询日志查看系统中效率较低的Query语句。</p><p>查询慢日志相关的参数有：</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>slow_query_log</td><td>是否开启慢查询日志，1表示开启，0表示关闭</td></tr><tr><td>slow-query-log-file</td><td>MySQL数据库慢查询日志存储路径</td></tr><tr><td>long_query_time</td><td>慢查询时间，超过设置的时间，系统将该查询记录</td></tr><tr><td>log_queries_not_using_indexes</td><td>未使用索引的查询也被记录到慢查询日志中</td></tr><tr><td>log_output</td><td>日志存储方式</td></tr></tbody></table><p>对于慢查询日志，我们可以设置一个时间，从而统计出系统中超过预期的SQL，从而对其进行优化。</p><h2 id="Query-Cache优化"><a href="#Query-Cache优化" class="headerlink" title="Query Cache优化"></a>Query Cache优化</h2><p>Query Cache即对客户端请求的Query语句（Select语句）的结果进行一个缓存操作，将Query语句通过Hash计算得到hash值，将该值作为KEY，查询结果（Result Set）作为VALUE存储在内存中，对于下一个Query语句，MySQL会先进行Hash运行，然后从内存中寻找对应的Query Cache，如果有直接返回，没有则执行语句，并将其加入到Query Cache中，对于频繁执行的Query语句，MySQL直接从Query Cache中获取结果集，从而较少IO开销。</p><p>虽然Query Cache能将查询结果缓存以减少下次查询的等待时间，但查询语句不是一成不变，查询的表中的数据同样也会产生变化。下面就细数一下Query Cache的几个缺点：</p><ul><li>Query Cache缓存失效：对于Query Cache缓存的原理是将Query语句查询结果集缓存，如果表的数据变化，MySQL则会清除该Query语句对应的Query Cache缓存。对于变更和查询较为频繁的表，Query Cache 每次进行的Hash运算，每次进行的结果集缓存操作都是对服务器的一大消耗（数据量过大的情况下）。</li><li>Query Cache缓存内存浪费：Query Cache缓存的是一个Query语句的结果集（Result Set），注意此处不是数据表而是结果集，也就是一张表对应有100个不同Query语句，则就会产生100个Query Cache，即同一条记录被多次缓存。从而使得服务器资源消耗大。当然也可限制Query Cache缓存的大小，不过这样的话缓存效率可能较低。</li></ul><p>虽然Query Cache具有一些负面影响，但因为其优点，在某些情景下，这些负面影响并不影响我们使用它。当然在使用Query Cache时应注意不要过度依赖Query Cache，我们理应做到扬长避短，充分发挥其优势。</p><p>对于上述两个缺点，主要为表数据的变化，Query语句的不同而导致的缓存数据较多。所以我们可以将Query Cache适用的场景做以下归纳：</p><ul><li>适用于数据变化不频繁的表。</li><li>结果集不是太大的表，如果太大，可限制缓存大小。</li></ul><p>SQL启动与关闭Query Cache缓存：</p><ul><li>SQL_NO_CACHE：强制不使用Query Cache，示例，SELECT SQL_NO_CACHE * from…</li><li>SQL_CACHE：强制使用Query Cache，示例，SELECT SQL_CACHE * from…</li></ul><p><strong>Query Cachede系统变量</strong></p><p>查询SQL为：</p><pre><code class="hljs plain">show variables like &#39;%query_cache%&#39;;</code></pre><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>query_cache_limit</td><td>存放单条Query Cahe的最大结果集内存大小，默认为1M</td></tr><tr><td>query_cache_min_res_unit</td><td>每个Query Cache的最小结果集内存大小，默认为4k</td></tr><tr><td>query_cache_size</td><td>系统中用于Query Cache的内存大小</td></tr><tr><td>query_cache_type</td><td>Query Cache开启状态</td></tr><tr><td>query_cache_wlock_invalidate</td><td>针对MyISAM存储引擎，设置当有WRITE LOCK在某个Table上时，读请求是要等WRITE LOCK释放资源后再查询还是允许直接从Query Cache中读取结果，默认为FALSE（可以直接从Query Cache中取得结果）</td></tr></tbody></table><p>对于Query Cache不仅限于上述的五点配置，还有一些状态变量，使用下面的查询语句可查看其它变量：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">status</span> <span class="hljs-keyword">like</span> <span class="hljs-string">'Qcache'</span>;</code></pre><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>Qcache_free_blocks</td><td>Query Cache中目前还有多少剩余的blocks。如果该值显示较大，则说明Query Cache中的内存碎片过多了，可能须要寻找合适的机会进行整理</td></tr><tr><td>Qcache_free_memory</td><td>Query Cache中目前剩余的内存大小。通过这个参数可以较为准确地观察出当前系统中的Query Cache内存大小是否足够，是须要增加还是过多了</td></tr><tr><td>Qcache_hits</td><td>多少次命中。通过这个参数可以查看到Query Cache的基本效果</td></tr><tr><td>Qcache_inserts</td><td>多少次未命中然后插入。通过“Qcache_hits”和“Qcache_inserts”两个参数可以算出Query Cache的命中率</td></tr><tr><td>Qcache_lowmem_prunes</td><td>该数值表示有多少query因内存不足而被清楚的Query Cache</td></tr><tr><td>Qcache_not_cached</td><td>表示query_cache_type的设置或者不能被cache的query的数量</td></tr><tr><td>Qcache_queries_in_cache</td><td>当前Query Cache中的数量</td></tr><tr><td>Qcache_total_blocks</td><td>当前Query Cache中被block的数量</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>postgresql使用</title>
    <link href="/2018/07/16/database/postgresql/postgresql%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/07/16/database/postgresql/postgresql%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="postgresql使用"><a href="#postgresql使用" class="headerlink" title="postgresql使用"></a>postgresql使用</h1><p>数据类型、常用系统函数、database、模式、序列、分页、</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><table><thead><tr><th>关键字</th><th>存储空间</th><th>描述</th><th>范围</th></tr></thead><tbody><tr><td>smallint</td><td>2 字节</td><td>小范围整数</td><td>-32768 到 +32767</td></tr><tr><td>integer</td><td>4字节</td><td>常用的整数</td><td>-2147483648 到 +2147483647</td></tr><tr><td>bigint</td><td>8 字节</td><td>大范围的整数</td><td>-9223372036854775808 到 9223372036854775807</td></tr><tr><td>decimal</td><td>变长</td><td>用户声明精度，精确</td><td>无限制</td></tr><tr><td>numeric</td><td>变长</td><td>用户声明精度，精确</td><td>无限制</td></tr><tr><td>real</td><td>4字节</td><td>变精度，不精确</td><td>6 位十进制数字精度</td></tr><tr><td>double</td><td>8 字节</td><td>变精度，不精确</td><td>15 位十进制数字精度</td></tr><tr><td>serial</td><td>4 字节</td><td>自增整数</td><td>1 到 +2147483647</td></tr><tr><td>bigserial</td><td>8 字节</td><td>大范围的自增整数</td><td>1 到 9223372036854775807</td></tr></tbody></table><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>varchar</td><td>变长，有长度限制</td></tr><tr><td>char</td><td>定长，不足补空白</td></tr><tr><td>text</td><td>边长，无长度限制</td></tr></tbody></table><h3 id="日期时间类型"><a href="#日期时间类型" class="headerlink" title="日期时间类型"></a>日期时间类型</h3><table><thead><tr><th>关键字</th><th>存储空间</th><th>描述</th><th>最低值</th><th>最高值</th><th>分辨率</th></tr></thead><tbody><tr><td>timestamp[无时区]</td><td>8字节</td><td>包括日期和时间</td><td>4713 BC</td><td>5874897AD</td><td>1毫秒/14位</td></tr><tr><td>timestamp[含时区]</td><td>8字节</td><td>日期和时间，带时区</td><td>4713 BC</td><td>5874897AD</td><td>1毫秒/14位</td></tr><tr><td>interval</td><td>12字节</td><td>时间间隔</td><td>-178000000年</td><td>178000000年</td><td>1毫秒/14位</td></tr><tr><td>date</td><td>4字节</td><td>只用于日期</td><td>4713 BC</td><td>32767AD</td><td>1天</td></tr><tr><td>time[无时区]</td><td>8字节</td><td>只用于一日内时间</td><td>00:00:00</td><td>24:00:00</td><td>1毫秒/14位</td></tr></tbody></table><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>声明数组字段（三种）：</p><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> <span class="hljs-keyword">test</span> (  test_arr1 <span class="hljs-built_in">integer</span>[],  test_arr2 <span class="hljs-built_in">integer</span>[<span class="hljs-number">4</span>],  test_arr3 <span class="hljs-built_in">integer</span> <span class="hljs-built_in">ARRAY</span>[<span class="hljs-number">4</span>]);</code></pre><p>对数组进行操作：</p><pre><code class="hljs sql">//查询数组<span class="hljs-keyword">SELECT</span> test_arr[<span class="hljs-number">3</span>] <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">test</span>;//全部更改<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">SET</span> test_arr = <span class="hljs-string">'&#123;31000,32000,33000,34000&#125;'</span>;//只更改某一项<span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">test</span> <span class="hljs-keyword">SET</span> test_arr[<span class="hljs-number">4</span>] = <span class="hljs-number">15000</span>；</code></pre><h3 id="json类型"><a href="#json类型" class="headerlink" title="json类型"></a>json类型</h3><p>json类型分为两种：</p><ul><li>json 存储格式为文本</li><li>jsonb 存储格式为二进制</li></ul><p>两者的比较：</p><ul><li><code>jsonb</code>通常比<code>json</code>占用更多的磁盘空间</li><li><code>jsonb</code>比<code>json</code>的写入更耗时间</li><li><code>json</code>的操作比<code>jsonb</code>的操作明显更耗时间（在操作一个<code>json</code>类型值时需要每次都去解析）</li></ul><p>如何选择：</p><ul><li>如果你的应用只用json表示，PostgreSQL只用于保存与获取时，你应该使用<code>json</code></li><li>如果你需要在PostgreSQL中做比较多的json值的操作，或者在一些json字段上使用索引时，你应该使用<code>jsonb</code></li></ul><h4 id="json与jsonb之间的操作符"><a href="#json与jsonb之间的操作符" class="headerlink" title="json与jsonb之间的操作符"></a>json与jsonb之间的操作符</h4><table><thead><tr><th>操作符</th><th>右操作数的类型</th><th>描述</th><th>示例</th><th>示例结果</th></tr></thead><tbody><tr><td>-&gt;</td><td>int</td><td>获取JSON数组元素（索引从0开始）</td><td>‘[{“a”:”foo”},{“b”:”bar”},{“c”:”baz”}]’::json-&gt;2</td><td>{“c”:”baz”}</td></tr><tr><td>-&gt;</td><td>text</td><td>通过秘钥获取JSON对象字段</td><td>‘{“a”: {“b”:”foo”}}’::json-&gt;’a’</td><td>{“b”:”foo”}</td></tr><tr><td>-&gt;&gt;</td><td>int</td><td>获取JSON数组元素为text</td><td>‘[1,2,3]’::json-&gt;&gt;2</td><td>3</td></tr><tr><td>-&gt;&gt;</td><td>text</td><td>获取JSON对象字段为text</td><td>‘{“a”:1,”b”:2}’::json-&gt;&gt;’b’</td><td>2</td></tr><tr><td>#&gt;</td><td>text[]</td><td>在指定的路径获取JSON对象</td><td>‘{“a”: {“b”:{“c”: “foo”}}}’::json#&gt;’{a,b}’</td><td>{“c”: “foo”}</td></tr><tr><td>#&gt;&gt;</td><td>text[]</td><td>在指定的路径获取JSON对象为text</td><td>‘{“a”:[1,2,3],”b”:[4,5,6]}’::json#&gt;&gt;’{a,2}’</td><td>3</td></tr></tbody></table><h4 id="额外的jsonb操作符"><a href="#额外的jsonb操作符" class="headerlink" title="额外的jsonb操作符"></a>额外的jsonb操作符</h4><table><thead><tr><th>操作符</th><th>右操作数的类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>@&gt;</td><td>jsonb</td><td>左侧的JSON值包含右侧的值吗？</td><td>‘{“a”:1, “b”:2}’::jsonb @&gt; ‘{“b”:2}’::jsonb</td></tr><tr><td>&lt;@</td><td>jsonb</td><td>左侧的JSON值包含在右侧的值中吗？</td><td>‘{“b”:2}’::jsonb &lt;@ ‘{“a”:1, “b”:2}’::jsonb</td></tr><tr><td>?</td><td>text</td><td>键/元素字符串包含JSON值吗？</td><td>‘{“a”:1, “b”:2}’::jsonb ? ‘b’</td></tr><tr><td>?|</td><td>text[]</td><td>是否存在任一键/元素字符串？</td><td>‘{“a”:1, “b”:2, “c”:3}’::jsonb ?|array[‘b’, ‘c’]</td></tr><tr><td>?&amp;</td><td>text[]</td><td>是否所有键/元素字符串都存在？</td><td>‘[“a”, “b”]’::jsonb ?&amp; array[‘a’, ‘b’]</td></tr></tbody></table><h2 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h2><table><thead><tr><th>关键字</th><th>描述</th></tr></thead><tbody><tr><td>abs</td><td>取绝对值</td></tr><tr><td>cbrt</td><td>立方根</td></tr><tr><td>replace</td><td>文本替换</td></tr><tr><td>btrim</td><td>从string开头和结尾删除只包含在characters里(缺省是空白)的字符的最长字串</td></tr><tr><td>ltrim</td><td>从字串string的开头删除只包含characters(缺省是一个空白)的最长的字串。</td></tr><tr><td>to_char</td><td>转为字符串类型</td></tr><tr><td>to_number</td><td>转为数值类型</td></tr></tbody></table><h2 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h2><p>对于postgresql分页使用limit offset方法进行，使用示例如下：</p><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">column</span> <span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">LIMIT</span> <span class="hljs-number">2</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">1</span></code></pre><p>具体语法为：</p><p>limit 返回行数 offset 查询起点位置</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>PostgreSQL提供了多种索引类型：B-Tree、Hash、GiST和GIN，由于它们使用了不同的算法，因此每种索引类型都有其适合的查询类型，缺省时，CREATE INDEX命令将创建B-Tree索引。</p><h4 id="b-tree"><a href="#b-tree" class="headerlink" title="b-tree"></a>b-tree</h4><blockquote><p><strong>CREATE INDEX</strong> test1_id_index <strong>ON</strong> test1 (id);    </p></blockquote><p> B-Tree索引主要用于等于和范围查询，特别是当索引列包含操作符” &lt;、&lt;=、=、&gt;=和&gt;”作为查询条件时，PostgreSQL的查询规划器都会考虑使用B-Tree索引。在使用BETWEEN、IN、IS NULL和IS NOT NULL的查询中，PostgreSQL也可以使用B-Tree索引。然而对于基于模式匹配操作符的查询，如LIKE、ILIKE、~和 ~*，仅当模式存在一个常量，且该常量位于模式字符串的开头时，如col LIKE ‘foo%’或col ~ ‘^foo’，索引才会生效，否则将会执行全表扫描，如：col LIKE ‘%bar’。 </p><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><blockquote><p><strong>CREATE INDEX</strong> name <strong>ON</strong> table <strong>USING hash</strong> (column);</p></blockquote><p>散列(Hash)索引只能处理简单的等于比较。当索引列使用等于操作符进行比较时，查询规划器会考虑使用散列索引。</p><p> 这里需要额外说明的是，PostgreSQL散列索引的性能不比B-Tree索引强，但是散列索引的尺寸和构造时间则更差。另外，由于散列索引操作目前没有记录WAL日志，因此一旦发生了数据库崩溃，我们将不得不用REINDEX重建散列索引。</p><h4 id="GiST"><a href="#GiST" class="headerlink" title="GiST"></a>GiST</h4><p>GiST索引不是一种单独的索引类型，而是一种架构，可以在该架构上实现很多不同的索引策略。从而可以使GiST索引根据不同的索引策略，而使用特定的操作符类型。 </p><h4 id="GIN"><a href="#GIN" class="headerlink" title="GIN"></a>GIN</h4><p> GIN索引是反转索引，它可以处理包含多个键的值(比如数组)。与GiST类似，GIN同样支持用户定义的索引策略，从而可以使GIN索引根据不同的索引策略，而使用特定的操作符类型。作为示例，PostgreSQL的标准发布中包含了用于一维数组的GIN操作符类型，如：&lt;@、@&gt;、=、&amp;&amp;等。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a><strong>唯一索引</strong></h4><blockquote><p>CREATE UNIQUE INDEX  name ON table (column [, …]);</p></blockquote><p>目前，只有B-Tree索引可以被声明为唯一索引。如果索引声明为唯一索引，那么就不允许出现多个索引值相同的行。我们认为NULL值相互间不相等。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>postgresql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis安装</title>
    <link href="/2018/07/16/database/redis/redis%E5%AE%89%E8%A3%85/"/>
    <url>/2018/07/16/database/redis/redis%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><h2 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h2><pre><code class="hljs plain">[root@localhost home]# wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-4.0.10.tar.gz[root@localhost home]# mv redis-4.0.10 &#x2F;usr&#x2F;local&#x2F;[root@localhost home]# cd &#x2F;usr&#x2F;local&#x2F;redis-4.0.10&#x2F;\[root@localhost redis-4.0.10]# make</code></pre><p>此时可能会提示如下错误</p><pre><code class="hljs plain">make[1]: Entering directory &#96;&#x2F;usr&#x2F;local&#x2F;redis-4.0.10&#x2F;src&#39;    CC Makefile.depmake[1]: Leaving directory &#96;&#x2F;usr&#x2F;local&#x2F;redis-4.0.10&#x2F;src&#39;make[1]: Entering directory &#96;&#x2F;usr&#x2F;local&#x2F;redis-4.0.10&#x2F;src&#39;    CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:31: fatal error: jemalloc&#x2F;jemalloc.h: No such file or directory</code></pre><p>遇见这样的情况使用一下命令就好</p><pre><code class="hljs plain">[root@localhost redis-4.0.10]# make MALLOC&#x3D;libc</code></pre><p>启动redis</p><pre><code class="hljs plain">[root@localhost redis-4.0.10]# src&#x2F;redis-server</code></pre><p>客户端连接</p><pre><code class="hljs plain">[root@localhost redis-4.0.10]# src&#x2F;redis-cliredis&gt; set foo barOKredis&gt; get foo&quot;bar&quot;</code></pre><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>关于redis配置文件此处着重说明以下几个地方：</p><table><thead><tr><th>字段</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>requirepass</td><td>foobared</td><td>设置认证密码</td></tr><tr><td>daemonize</td><td>no</td><td>设置为yes时，会将redis作为守护进程运行</td></tr><tr><td>protected-mode</td><td>yes</td><td>是否开启保护模式，远程连接时设置为no</td></tr><tr><td>pidfile</td><td>/var/run/redis_6379.pid</td><td>定义pid文件路径</td></tr><tr><td>port</td><td>6379</td><td>服务监听端口，默认6379</td></tr><tr><td>tcp-backlog</td><td>511</td><td>TCP 监听的最大容纳数量</td></tr><tr><td>timeout</td><td>0</td><td>指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）</td></tr><tr><td>databases</td><td>16</td><td>设置数据库的数目</td></tr><tr><td>dbfilename</td><td>dump.rdb</td><td>设置 dump 的文件位置</td></tr><tr><td>bind</td><td>127.0.0.1</td><td>运行连接的ip，你如果只想让它在一个网络接口上监听，那你就绑定一个IP或者多个IP，同时也可以设置0.0.0.0</td></tr></tbody></table><p>更多的你可以查询官方文档 <a href="https://redis.io/documentation" target="_blank" rel="noopener">https://redis.io/documentation</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计与设计原则</title>
    <link href="/2018/07/16/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2018/07/16/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象设计与设计原则"><a href="#面向对象设计与设计原则" class="headerlink" title="面向对象设计与设计原则"></a>面向对象设计与设计原则</h1><h2 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h2><blockquote><p>面向对象程序设计(<code>Object-oriented programming</code>即<code>OOP</code>)是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。</p></blockquote><p>面向对象编程的两个重要概念是类和对象。</p><p>类：类是变量与作用这些变量的方法集合，事物都具有其自身的属性和方法，通过这些属性和方法可以将不同的物质区分开来。</p><p>对象：对象是类进行实例化后的产物，是一个实体。</p><h2 id="面向对象基本特征"><a href="#面向对象基本特征" class="headerlink" title="面向对象基本特征"></a>面向对象基本特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是面向对象的特征之一，是对象和类概念的主要特性。</p><p>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类进行信息隐藏。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 </p><ul><li>通过继承创建的新类称为“子类”或“派生类”。</li><li>被继承的类称为“基类”、“父类”或“超类”。</li><li>继承的过程，就是从一般到特殊的过程。</li></ul><p>继承概念的实现方式有三类：实现继承、接口继承和可视继承。</p><ul><li>实现继承：使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力；</li><li>可视继承：子窗体（类）使用基窗体（类）的外观和实现代码的能力。</li></ul><p>OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p><p>实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名(<code>方法签名：方法名+形参列表</code>)必须不同于原先方法的，但对于覆盖签名必须相同。 </p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则(<code>Open Close Principle</code>即<code>OCP</code>)是Java中最基础的设计原则，它可以帮助我们建立一个稳定、灵活的系统。</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。</p><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>我们假设当前有一个书籍销售的功能模块，程序原本的类图如下：</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%991.png" srcset="/img/loading.gif" alt="面向对象开闭原则1"></p><p>此时，因为书店打折活动，书籍价格会产生变化，我们需要修改程序的getPrice()方法，我们可以修改接口<code>IBook</code>，也可以修改其实现类<code>NovelBook</code>，但是这样的话都会在类中产生两个读取价格的方法，顾这两种方法都不是最优的解决办法。如下图所示，我们新建一个<code>OffNovelBook</code>，让其继承<code>NovelBook</code>并重写<code>getPrice</code>方法，新建高层类，通过复写来改变业务逻辑，减少底层代码的修改，减少代码风险。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%992.png" srcset="/img/loading.gif" alt="面向对象开闭原则2"></p><p>我们可以把变化归类为两种类型：</p><ul><li>逻辑变化：只变化了一个逻辑，而不涉及到其他模块的变化，可以直接修改原有类中的方法来实现，但这有一个前提条件是所有依赖或关联都按照相同的逻辑处理。</li><li>子模块变化：一个模块的变化，会对其他模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，因此诸如此类的变化应通过扩展来完成。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>抽象约束 ：通过接口或抽象类约束扩展，对扩展进行边界限定 ；参数类型、引用对象尽量使用接口或抽象类，而不是具体的实现类 ；抽象层尽量保持稳定，一旦确定就不要修改 。</li><li>元数据（metadata）控制模块行为 ：元数据就是用来描述环境和数据的数据。尽量使用元数据来控制程序的行为，减少重复开发 。</li><li>封装变化：将相同的变化封装到一个接口或抽象类中，不同的变化应封装在不同的接口或抽象类中，否则即违背了单一职责原则。</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>单一职责原则(<code>Single Responsibility Principle</code>即<code>SRP</code>)，其核心的思想是： 一个类，最好只做一件事，只有一个引起它变化的原因。</p></blockquote><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>单一职责，强调的是职责的分离，在某种程度上对职责的理解，构成了不同类之间耦合关系的设计关键，因此单一职责原则或多或少成为设计过程中一个必须考虑的基础性原则。 </p><h4 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProduct</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!getCuurentUserPermission.contains(<span class="hljs-string">"product.add"</span>)) &#123;    <span class="hljs-comment">//当前用户不具有add权限</span>        <span class="hljs-keyword">return</span>;    &#125;     <span class="hljs-comment">//业务逻辑</span>&#125;</code></pre><p>从以上代码，我们不难看出，如果该功能对应的权限规则发生了变化 ，那么我们需要对系统中所有诸如此类的类进行修改。这将大大降低程序的稳定性，同时也会大大的提高我们得工作量。</p><p>对于这种情况我们可以新建一个类(权限控制类，比如<code>shiro</code>框架)来做处理。在<code>shrio</code>框架中，可以通过注解的方式去配置权限代码来实现权限控制，同理我们也可自己写一个方法，例如：<code>PermisssionUtils.haveRight(String permissionCode)</code>，在调用<code>addProduct</code>之前去判断是否拥有权限，从而使业务逻辑与权限控制两个职责分离。</p><pre><code class="hljs java">PermisssionUtils.haveRight(<span class="hljs-string">"product.add"</span>);addProduct();</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 </p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p>里氏替换原则(<code>Liskov Substitution Principle</code>,即<code>LSP</code>)：所有引用父类的地方必须能使用其子类的对象。</p></blockquote><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>所有引用父类的地方必须能使用其子类的对象</strong>：</p><p>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用父类对象。 </p><h4 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h4><p>在下文关于<code>依赖倒置原则</code>的实例中：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        People jim = <span class="hljs-keyword">new</span> Jim();        Fruit apple = <span class="hljs-keyword">new</span> Apple();        Fruit banana = <span class="hljs-keyword">new</span> Banana();        jim.eat(apple);        jim.eat(banana);    &#125;&#125;</code></pre><p>我们将<code>Banana</code>赋值给其父类<code>Banana</code>，并且在执行<code>jim.eat(Banana)</code>方法时得到了我们期望的结果。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>里氏替换原则是实现开闭原则的重要方式之一，由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。通常我们会使用接口或者抽象方法定义基类，然后子类中实现父类的方法，并在运行时通过各种手段进行类型选择调用（比如反射）。 </p><p>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 </p><p>我们在运用里氏替换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏替换原则是开闭原则的具体实现手段之一。这也就是我们应该更多的依赖抽象，尽量少的依赖实现细节， 也就是依赖倒置原则。 </p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><blockquote><p>依赖倒置原则(<code>Dependency Inversion Principle</code>即<code>DIP</code>)</p></blockquote><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p><strong>抽象</strong>：抽象类或接口，两者是不能被实例化的</p><p><strong>细节</strong>：抽象具体的实现类，实现接口或继承抽象类所产生的类（可以被实例化的类）</p><h4 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="hljs java"><span class="hljs-comment">//具体Jim人类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jim</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(Apple apple)</span></span>&#123;        System.out.println(<span class="hljs-string">"Jim eat "</span> + apple.getName());    &#125;&#125;<span class="hljs-comment">//具体苹果类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"apple"</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        Jim jim = <span class="hljs-keyword">new</span> Jim();        Apple apple = <span class="hljs-keyword">new</span> Apple();        jim.eat(apple);    &#125;&#125;</code></pre><p>从上述代码，我们不难看出，该程序所表示的人吃苹果。此时我们如果要加一条人吃香蕉，只能先定义一个<code>Banana</code>类，然后在修改<code>Jim</code>类，在其中加一个吃香蕉的方法。加一种尚且如此，那么加n种呢？并且修改<code>Jim</code>类的操作会大大减少系统的稳健性，顾应根据依赖倒置原则对源码进行修改，修改如下：</p><pre><code class="hljs java"><span class="hljs-comment">//人接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">People</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(Fruit fruit)</span></span>;<span class="hljs-comment">//人都有吃的方法，不然都饿死了</span>&#125;<span class="hljs-comment">//水果接口</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fruit</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//水果都是有名字的</span>&#125;<span class="hljs-comment">//具体Jim人类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Jim</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">People</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">(Fruit fruit)</span></span>&#123;        System.out.println(<span class="hljs-string">"Jim eat "</span> + fruit.getName());    &#125;&#125;<span class="hljs-comment">//具体苹果类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Apple</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"apple"</span>;    &#125;&#125;<span class="hljs-comment">//具体香蕉类</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Banana</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Fruit</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">"banana"</span>;    &#125;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        People jim = <span class="hljs-keyword">new</span> Jim();        Fruit apple = <span class="hljs-keyword">new</span> Apple();        Fruit banana = <span class="hljs-keyword">new</span> Banana();        jim.eat(apple);        jim.eat(banana);    &#125;&#125;</code></pre><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>总而言之，依赖倒置原则的核心就是面向接口编程，对于一些底层类都提取抽象类和公共接口，顶层类依赖抽象类或接口而不直接依赖具体实现。</p><p>依赖倒置原则的本质是通过抽象类或接口使各个类或模块的实现彼此独立，不相互影响，实现模块之间的松耦合。</p><p>在多人协作时，我们还可以遵循依赖倒置原则去设计程序，提取抽象，使得各模块相对独立，提升并行开发效率，提高开发速度。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><blockquote><p>接口隔离原则(<code>Interface  Segregation Principle</code>, 即<code>ISP</code>)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><ul><li><p>客户端不应该依赖它不需要的接口。</p></li><li><p>类间的依赖关系应该建立在最小的接口上。</p></li><li><p>接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只知道他们感兴趣的方法。</p></li></ul><h4 id="实例分析-4"><a href="#实例分析-4" class="headerlink" title="实例分析"></a>实例分析</h4><p>例如：客户端的用户需要登录、登出、修改密码等操作，而后台的管理员则可以修改用户资料、删除用户等操作。</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logout</span><span class="hljs-params">()</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changePassword</span><span class="hljs-params">()</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AdminUserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">UserService</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteUser</span><span class="hljs-params">(User user)</span></span>;&#125;</code></pre><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</p><p>接口隔离原则与前面的单一职责原则相辅相成。但单一职责原则并不保证客户程序只知道必要的信息，甚至在有些情况下接口隔离原则与单一职责原则会出现一定的冲突，设计时我们要根据用户界面,性能等因素决策.。</p><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><blockquote><p>迪米特法则(<code>Law of  Demeter</code>, 即<code>LOD</code>)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p>迪米特法则又称为最少知识原则(<code>LeastKnowledge Principle</code>,即<code>LKP</code>) </p></blockquote><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p><strong>不要和“陌生人”说话、只与你的直接朋友通信</strong></p><p>在迪米特法则中，对于一个对象，其朋友包括以下几类： </p><ul><li>当前对象本身(this) </li><li>以参数形式传入到当前对象方法中的对象 </li><li>当前对象的成员对象 </li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象 </li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响 。</p><h4 id="实例分析-5"><a href="#实例分析-5" class="headerlink" title="实例分析"></a>实例分析</h4><p>例如：现在用户像好友发送消息，用户可以对单个好友发送消息，也可以发送群消息。</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%81%A9%E6%B3%95%E5%88%99.png" srcset="/img/loading.gif" alt="迪米特恩法则"></p><p>从上图不难看出，我们专门引入了一个<code>MessageService</code>用与控制消息转发，同时降低<code>UserService</code>与各系统之间的耦合度。当需要新增功能时，只需修改<code>MessageSerice</code>即可。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用</strong>。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。 </p><p>在运用迪米特恩法则时应注意以下几点：</p><ul><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul><h3 id="组合-聚合复用原则"><a href="#组合-聚合复用原则" class="headerlink" title="组合/聚合复用原则"></a>组合/聚合复用原则</h3><blockquote><p>组合/聚合复用原则（<code>Composite/Aggregate Reuse Principle</code> 即<code>CARP</code>）</p></blockquote><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>组合和聚合都是对象建模中关联（<code>Association</code>）关系的一种.聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。在合成关系中，部分和整体的生命周期一样，组合的新的对象完全支配其组成部分，包括他们的创建和销毁。一个合成关系中成分对象是不能与另外一个合成关系共享。 </p><h4 id="实例分析-6"><a href="#实例分析-6" class="headerlink" title="实例分析"></a>实例分析</h4><p>组合/聚合和继承是实现复用的两个基本途径。合成复用原则是指尽量使用合成/聚合，而不是使用继承。 只有当以下的条件全部被满足时，才应当使用继承关系。</p><ul><li>继承复用破坏包装，它把父类的实现细节直接暴露给了子类，这违背了信息隐藏的原则。</li><li>如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合，不利于类的扩展、复用、维护等，也带来了系统僵硬和脆弱的设计。 </li><li>合成和聚合的时候新对象和已有对象的交互往往是通过接口或者抽象类进行的，就可以很好的避免上面的不足，而且这也可以让每一个新的类专注于实现自己的任务，符合单一职责原则。 </li></ul><p><strong>判断方法：</strong></p><p>1.<strong>使用“Has-A”和“Is-A”来判断：</strong></p><p>“Has-A”：代表的是 对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一个人可以是医生、警察、教师等。<strong>此时可使用继承关系</strong>。</p><p>“Is-A”：代表的是类之间的继承关系，比如一个人可以是男人、女人。<strong>此时应使用组合/聚合</strong>。</p><p>2.<strong>使用里氏替换原则来判断</strong></p><p> 里氏代换原则是继承复用的基础。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>继承的缺点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>组合/聚合优点：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合/聚合缺点：组合复用建造的系统会有较多的对象需要管理。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL安装</title>
    <link href="/2018/07/16/database/postgresql/postgresql%E5%AE%89%E8%A3%85/"/>
    <url>/2018/07/16/database/postgresql/postgresql%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL安装"><a href="#PostgreSQL安装" class="headerlink" title="PostgreSQL安装"></a>PostgreSQL安装</h1><h2 id="Linux-CentOs-安装方法"><a href="#Linux-CentOs-安装方法" class="headerlink" title="Linux(CentOs)安装方法"></a>Linux(CentOs)安装方法</h2><h3 id="使用yum安装"><a href="#使用yum安装" class="headerlink" title="使用yum安装"></a>使用yum安装</h3><p>安装存储库RPM： </p><pre><code class="hljs plain">yum install https:&#x2F;&#x2F;download.postgresql.org&#x2F;pub&#x2F;repos&#x2F;yum&#x2F;10&#x2F;redhat&#x2F;rhel-7-x86_64&#x2F;pgdg-centos10-10-2.noarch.rpm</code></pre><p>安装客户端软件包： </p><pre><code class="hljs plain">yum install postgresql10</code></pre><p>安装服务器包： </p><pre><code class="hljs plain">yum install postgresql10-server</code></pre><p>初始化数据库并启用自动启动： </p><pre><code class="hljs plain">&#x2F; usr &#x2F; pgsql-10 &#x2F; bin &#x2F; postgresql-10-setup initdb systemctl enable postgresql-10 systemctl start postgresql-10</code></pre><h3 id="使用tar包安装"><a href="#使用tar包安装" class="headerlink" title="使用tar包安装"></a>使用tar包安装</h3><h4 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h4><p>在进行安装之前，需要创建一个用户与组，否则在初始化数据库的时候会报如下错误：</p><pre><code class="hljs plain">Running in debug mode.initdb: cannot be run as rootPlease log in (using, e.g., &quot;su&quot;) as the (unprivileged) user that will</code></pre><p>新建组与用户</p><pre><code class="hljs plain">groupadd postgresuseradd -g postgres postgres</code></pre><p>在安装之前需要安装以下：</p><p>make、gcc、gcc-c++、zlib-devel、readline-devel </p><pre><code class="hljs plain">[root@linhp local]# yum -y install gcc[root@linhp local]# yum -y install gcc-c++[root@linhp local]# yum -y install readline-devel[root@linhp local]# yum -y install zlib-devel[root@linhp postgresql-9.3.1]# yum -y install make</code></pre><p>如果有，请勿重复安装</p><h4 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h4><p>首先前往官网下载安装包，下载地址：<a href="https://www.postgresql.org/ftp/source/" target="_blank" rel="noopener">https://www.postgresql.org/ftp/source/</a></p><p>你可以选择任意版本，不过不推荐选择<code>beta</code>版</p><pre><code class="hljs plain">[root@localhost local]# wget https:&#x2F;&#x2F;ftp.postgresql.org&#x2F;pub&#x2F;source&#x2F;v10.4&#x2F;postgresql-10.4.tar.gz[root@localhost local]# tar -zvxf postgresql-10.4.tar.gz[root@localhost local]# mv postgresql-10.4&#x2F; postgresql</code></pre><p>编译安装</p><pre><code class="hljs plain">[root@localhost postgresql]#  .&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;postgresql --without-readline[root@localhost postgresql]# make &amp;&amp; make install#安装contrib目录下的一些工具，是第三方组织的一些工具代码，建议安装[root@localhost postgresql]# cd contrib&#x2F;[root@localhost postgresql]# make &amp;&amp; make install</code></pre><p>将postgrepsql加入到环境变量</p><pre><code class="hljs plain">[root@localhost contrib]# vim &#x2F;etc&#x2F;profile</code></pre><pre><code class="hljs plain">export PGHOME&#x3D;&#x2F;usr&#x2F;local&#x2F;postgresqlexport PGDATA&#x3D;&#x2F;var&#x2F;postgresql&#x2F;dataexport PATH&#x3D;$PGHOME&#x2F;bin:$PATHexport MANPATH&#x3D;$PGHOME&#x2F;share&#x2F;man:$MANPATH</code></pre><pre><code class="hljs plain">[root@localhost contrib]# source &#x2F;etc&#x2F;profile</code></pre><p>初始化数据库</p><pre><code class="hljs plain">[root@localhost postgresql]# su - postgres[root@localhost postgresql]# initdb -d &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;data&#x2F;</code></pre><p>启动数据库服务</p><pre><code class="hljs plain">[postgres@localhost postgresql]$ pg_ctl -D &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;data -l &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;logfile start</code></pre><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>使用<code>psql</code>进入控制台</p><pre><code class="hljs plain">[postgres@localhost postgresql]$ psqlpsql (10.4)Type &quot;help&quot; for help.postgres&#x3D;#</code></pre><p>在控制台中进行一下操作</p><pre><code class="hljs plain">postgres&#x3D;# create database test;CREATE DATABASEpostgres&#x3D;# \c testYou are now connected to database &quot;test&quot; as user &quot;postgres&quot;.test&#x3D;# create table test (id integer, name text);CREATE TABLEtest&#x3D;# insert into test values (1,&#39;david&#39;);INSERT 0 1test&#x3D;# select * from test ; id | name  ----+-------  1 | david(1 row)test&#x3D;#</code></pre><p>顺便一提，在postgre控制台，退出需要使用<code>\q</code>命令</p><h3 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h3><p>修改PostgreSql配置文件</p><pre><code class="hljs plain">[postgres@localhost postgresql]$ vim data&#x2F;postgresql.conf</code></pre><p>在其最下方添加一行</p><pre><code class="hljs plain">host    all         all         0.0.0.0&#x2F;0             trust</code></pre><p>不过出安全，不推荐这样做</p><p>创建超级用户</p><pre><code class="hljs plain">[postgres@localhost postgresql]$ createuser -P -s -U postgres -p 5432 psql</code></pre><h3 id="辅助脚本"><a href="#辅助脚本" class="headerlink" title="辅助脚本"></a>辅助脚本</h3><p>为了方便操作，这里写三个命令，你可以把这个三个命令写到脚本文件里，这样可以方便执行</p><p><strong>启动命令</strong></p><pre><code class="hljs plain">pg_ctl -D &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;data -l &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;logfile start</code></pre><p><strong>重启命令</strong></p><pre><code class="hljs plain">pg_ctl -D &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;data -l &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;logfile restart</code></pre><p><strong>停止命令</strong></p><pre><code class="hljs plain">pg_ctl -D &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;data -l &#x2F;usr&#x2F;local&#x2F;postgresql&#x2F;logfile stop</code></pre>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>postgresql</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-总览</title>
    <link href="/2018/07/14/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/"/>
    <url>/2018/07/14/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-总览"><a href="#设计模式-总览" class="headerlink" title="设计模式-总览"></a>设计模式-总览</h1><blockquote><p>设计模式（Design pattern）是一种被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。即：在某些场景下，针对某类问题的某种通用的解决办法</p></blockquote><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul><li><p><strong>创建型模式</strong>：对象实例化的模式，创建型模式用于解耦对象的实例化过程</p></li><li><p><strong>结构型模式</strong>： 把类或对象结合在一起形成一个更大的结构</p></li><li><p><strong>行为型模式</strong> ：类和对象如何交互，及划分责任和算法</p><p><img src="https://jlhblog.oss-cn-beijing.aliyuncs.com/blogimg/java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%86%E7%B1%BB.png" srcset="/img/loading.gif" alt="设计模式"></p></li></ul><h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><blockquote><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则 。</p><p>创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p></blockquote><table><thead><tr><th>名称</th><th>重要程度</th><th>说明</th><th>链接</th></tr></thead><tbody><tr><td>工厂模式(Factory)</td><td>★★★★★</td><td>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 。</td><td><a href="/2020/04/19/Java/设计模式/设计模式-工厂模式/">工厂模式</a></td></tr><tr><td>抽象工厂模式(Abstract Factory)</td><td>★★</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</td><td><a href="/2020/04/19/Java/设计模式/设计模式-工厂模式/">工厂模式</a></td></tr><tr><td>建造者模式(Builder)</td><td>★★★</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td><a href="/2020/04/21/Java/设计模式/设计模式-建造者模式/">建造者模式</a></td></tr><tr><td>原型模式(Prototype)</td><td>★★★</td><td>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</td><td><a href="/2020/04/21/Java/设计模式/设计模式-原型模式/">原型模式</a></td></tr><tr><td>单例模式(Singleton)</td><td>★★★★</td><td>在整个应用中保证只有一个类的实例存在。</td><td><a href="/2020/04/21/Java/设计模式/设计模式-单例模式/">单例模式</a></td></tr></tbody></table><h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><table><thead><tr><th>名称</th><th>重要程度</th><th>说明</th><th>链接</th></tr></thead><tbody><tr><td>适配器模式( Adapter )</td><td>★★★★</td><td>定义一个包装类，用于包装不兼容接口的对象</td><td></td></tr><tr><td>桥接模式( Bridge )</td><td>★★★</td><td>将抽象部分与它的实现部分分离，使它们都可以独立地变化</td><td></td></tr><tr><td>组合模式( Composite )</td><td>★★★★</td><td>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性</td><td></td></tr><tr><td>装饰模式( Decorator )</td><td>★★★</td><td>动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活</td><td></td></tr><tr><td>外观模式( Facade )</td><td>★★★★★</td><td>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81054502" target="_blank" rel="noopener">外观模式</a></td></tr><tr><td>亨元模式( Flyweight )</td><td>★</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td></td></tr><tr><td>代理模式( Proxy )</td><td>★★★★</td><td>给某一个对象提供一个代 理，并由代理对象控制对原对象的引用</td><td></td></tr></tbody></table><h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><blockquote><p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化 。</p><p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 </p><p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 </p></blockquote><p>行为型模式主要分为以下两种：</p><ul><li>类行为型模式 ：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责</li><li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式</li></ul><table><thead><tr><th>名称</th><th>重要程度</th><th>说明</th><th>链接</th></tr></thead><tbody><tr><td>责任链模式( Chain of Responsibility )</td><td>★★★</td><td>为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦</td><td></td></tr><tr><td>命令模式( Command )</td><td>★★★★</td><td>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作</td><td></td></tr><tr><td>解释器模式( Interpreter )</td><td>★</td><td></td><td></td></tr><tr><td>迭代器模式( Iterator )</td><td>★★★★★</td><td>提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节</td><td></td></tr><tr><td>中介者模式( Mediator )</td><td>★★</td><td>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td></td></tr><tr><td>备忘录模式( Memento )</td><td>★★</td><td>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态</td><td></td></tr><tr><td>观察者模式( Observer )</td><td>★★★★★</td><td>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81054547" target="_blank" rel="noopener">观察者模式</a></td></tr><tr><td>状态模式( State )</td><td>★★★</td><td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</td><td></td></tr><tr><td>策略模式( Strategy )</td><td>★★★★</td><td>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换</td><td></td></tr><tr><td>模板方法模式( Template Method) )</td><td>★★★</td><td>使得子类可以在不改变算法结构的情况下，重新定义算法中的某一些步骤</td><td></td></tr><tr><td>访问者模式( Visitor )</td><td>★</td><td>提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</td><td></td></tr></tbody></table><hr><p><strong>参考资料</strong></p><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
