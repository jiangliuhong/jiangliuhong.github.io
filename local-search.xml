<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>hexo中markdown文档自动编号</title>
    <link href="/2020/03/26/normal/md%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/"/>
    <url>/2020/03/26/normal/md%E6%A0%87%E9%A2%98%E8%87%AA%E5%8A%A8%E7%BC%96%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="hexo中markdown文档自动编号"><a href="#hexo中markdown文档自动编号" class="headerlink" title="hexo中markdown文档自动编号"></a>hexo中markdown文档自动编号</h1><h2 id="css实现原理"><a href="#css实现原理" class="headerlink" title="css实现原理"></a>css实现原理</h2><p>有时候我们需要对文章进行编号，例如：</p><pre><code>1 标题11.1 标题1.11.1.1 标题1.1.11.2 标题1.2</code></pre><p>但是这在<code>hexo</code>是不支持的，需要自己开发，查阅了资料，发现可以利用css的计数器(counter)来实现此功能。</p><p>在css里，我们可以声明一个计数器，假设其名称为counter_xxx，那么我们可以使用counter()函数获得它当前的值。</p><pre><code>counter(counter_xxx);</code></pre><p>与此同时，我们可以使用counter-reset属性指定需要重置的计数器，使用counter-increment属性指定计数加一的计数器。</p><pre><code>h1 {    counter-increment: counter_h1;    counter-reset: counter_h2;}</code></pre><p>如上代码所示，每有一个h1出现时，计数器counter_h1的值就会加一，而counter_h2的值就会重置为0。我们刚好可以利用这个，配合伪类选择器:before来实现标题的自动编号。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p><strong>代码详情：</strong></p><pre><code class="css">h2 {    counter-increment: counter_h2;    counter-reset: counter_h3;}h2 .headerlink:before {    content: counter(counter_h2)&quot;　&quot;;}h3 {    counter-increment: counter_h3;    counter-reset: counter_h4;}h3 .headerlink:before {    content: counter(counter_h2)&quot;.&quot;counter(counter_h3)&quot;　&quot;;}h4 {    counter-increment: counter_h4;    counter-reset: counter_h5;}h4 .headerlink:before {    content: counter(counter_h2)&quot;.&quot;counter(counter_h3)&quot;.&quot;counter(counter_h4)&quot;　&quot;;}</code></pre><p><strong>注意：</strong></p><ul><li><p><code>h4 .headerlink:before</code>这个是具体展现的<code>css</code>，你可根据自生情况来说。</p></li><li><p>这里我是从<code>h2</code>开始编号的，如果需要，你也可以从<code>h1</code>开始编号。</p></li></ul><p><strong>展现效果：</strong></p><h2 id="h2标题"><a href="#h2标题" class="headerlink" title="h2标题"></a>h2标题</h2><h3 id="h3标题"><a href="#h3标题" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题"><a href="#h4标题" class="headerlink" title="h4标题"></a>h4标题</h4><h4 id="h4标题-1"><a href="#h4标题-1" class="headerlink" title="h4标题"></a>h4标题</h4><h4 id="h4标题-2"><a href="#h4标题-2" class="headerlink" title="h4标题"></a>h4标题</h4><h3 id="h3标题-1"><a href="#h3标题-1" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题-3"><a href="#h4标题-3" class="headerlink" title="h4标题"></a>h4标题</h4><h4 id="h4标题-4"><a href="#h4标题-4" class="headerlink" title="h4标题"></a>h4标题</h4><h2 id="h2标题-1"><a href="#h2标题-1" class="headerlink" title="h2标题"></a>h2标题</h2><h3 id="h3标题-2"><a href="#h3标题-2" class="headerlink" title="h3标题"></a>h3标题</h3><h4 id="h4标题-5"><a href="#h4标题-5" class="headerlink" title="h4标题"></a>h4标题</h4>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java合并图片</title>
    <link href="/2020/03/25/Java/tools/java%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87/"/>
    <url>/2020/03/25/Java/tools/java%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="使用java合并图片"><a href="#使用java合并图片" class="headerlink" title="使用java合并图片"></a>使用java合并图片</h1><h2 id="编写Bimg类"><a href="#编写Bimg类" class="headerlink" title="编写Bimg类"></a>编写<code>Bimg</code>类</h2><blockquote><p>省略<code>get</code>、<code>set</code>方法</p></blockquote><pre><code class="java">import java.awt.image.BufferedImage;public class Bimg {    private BufferedImage image;    private int w;    private int y;}</code></pre><h2 id="编写测试类"><a href="#编写测试类" class="headerlink" title="编写测试类"></a>编写测试类</h2><pre><code class="java">import java.awt.*;import java.awt.image.BufferedImage;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.util.ArrayList;import java.util.List;import javax.imageio.ImageIO;public class Test {    private static List&lt;String&gt; getImgs() {        List&lt;String&gt; array = new ArrayList&lt;&gt;();        array.add(&quot;D:\\temp\\signimgs\\img\\1.png&quot;);        array.add(&quot;D:\\temp\\signimgs\\img\\2.png&quot;);        array.add(&quot;D:\\temp\\signimgs\\img\\3.png&quot;);        array.add(&quot;D:\\temp\\signimgs\\img\\4.png&quot;);        return array;    }    public static void main(String[] args) throws Exception {        // 横向图片数量        int wsize = 3;        List&lt;String&gt; imgs = getImgs();        int allWidth = 0;        int allHeight = 0;        List&lt;Bimg&gt; bimgs = new ArrayList&lt;&gt;();        // 目前横坐标        int w = 0;        // 目前竖坐标        int y = 0;        // 当前行宽度        int currentRowWidth = 0;        // 当前行高度        int currentRowHeight = 0;        for (int i = 1; i &lt;= imgs.size(); i++) {            String imgPath = imgs.get(i - 1);            File imgFile = new File(imgPath);            InputStream in = new FileInputStream(imgFile);            BufferedImage imageBuffer = ImageIO.read(in);            Bimg bimg = new Bimg();            bimgs.add(bimg);            bimg.setImage(imageBuffer);            // 判断是否需要换行            if (i % (wsize + 1) == 0) {                // 需要换行                w = 0;                y = currentRowHeight;                allWidth = Math.max(allWidth, currentRowWidth);                allHeight = allHeight + currentRowHeight;                currentRowWidth = 0;                currentRowHeight = 0;            }            bimg.setW(w);            bimg.setY(y);            w = w + imageBuffer.getWidth();            currentRowHeight = Math.max(currentRowHeight, imageBuffer.getHeight());            // 维护当前行宽度            currentRowWidth = currentRowWidth + imageBuffer.getWidth();        }        // 如果最终的高宽都是0，就进行一次设置，主要为仅一行的情况做处理        if (currentRowWidth != 0 || currentRowHeight != 0) {            allWidth = Math.max(allWidth, currentRowWidth);            allHeight = allHeight + currentRowHeight;        }        // 解决透明区域变黑的问题        BufferedImage combined = new BufferedImage(allWidth, allHeight, BufferedImage.TYPE_INT_RGB);        Graphics2D g = combined.createGraphics();        combined = g.getDeviceConfiguration().createCompatibleImage(combined.getWidth(), combined.getHeight(),            Transparency.TRANSLUCENT);        // 解决透明区域变黑的问题        Graphics graphics = combined.getGraphics();        for (Bimg bimg : bimgs) {            graphics.drawImage(bimg.getImage(), bimg.getW(), bimg.getY(), null);        }        ImageIO.write(combined, &quot;png&quot;, new File(&quot;D:\\temp\\signimgs\\img\\res.png&quot;));    }}</code></pre><p>其中需要注意的是，如果源图片存在透明区域，直接合并的话，透明区域会变为黑色，该情况使用下面的代码就能解决：</p><pre><code class="java">BufferedImage combined = new BufferedImage(allWidth, allHeight, BufferedImage.TYPE_INT_RGB);        Graphics2D g = combined.createGraphics();        combined = g.getDeviceConfiguration().createCompatibleImage(combined.getWidth(), combined.getHeight(),            Transparency.TRANSLUCENT);</code></pre>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows添加vscode右键菜单</title>
    <link href="/2020/03/24/normal/windows%E6%B7%BB%E5%8A%A0vscode%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/"/>
    <url>/2020/03/24/normal/windows%E6%B7%BB%E5%8A%A0vscode%E5%8F%B3%E9%94%AE%E8%8F%9C%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<h1 id="windows添加vscode右键菜单"><a href="#windows添加vscode右键菜单" class="headerlink" title="windows添加vscode右键菜单"></a>windows添加vscode右键菜单</h1><blockquote><p>最近对<code>vscode</code>编辑器几乎入魔了，凡事静态代码，都改用<code>vscode</code>来编写了，不过在windows上，如果需要打开一个文件或者一个文件夹，这个操作比较繁琐，所以就期望能够直接在windows的资源管理器里加上一个菜单。经过<code>google</code>之后，发现了如下方法</p></blockquote><p>创建一个<code>vscode.reg</code>，名字可以随便写，但是后缀名用<code>.reg</code>，文件内容如下：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;C:\\app\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\*\shell\VSCode\command]@=&quot;\&quot;C:\\app\\Microsoft VS Code\\Code.exe\&quot; \&quot;%1\&quot;&quot;Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\shell\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;C:\\app\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\Directory\shell\VSCode\command]@=&quot;\&quot;C:\\app\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot;Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode]@=&quot;Open with Code&quot;&quot;Icon&quot;=&quot;C:\\app\\Microsoft VS Code\\Code.exe&quot;[HKEY_CLASSES_ROOT\Directory\Background\shell\VSCode\command]@=&quot;\&quot;C:\\app\\Microsoft VS Code\\Code.exe\&quot; \&quot;%V\&quot;&quot; </code></pre><p>其中 <code>C:\\app\\Microsoft VS Code\\Code.exe</code> 这个是我本机的安装地址，你可能需要修改一下。</p><p>最后双击执行即可，如果失败，你可能需要使用管理员权限使用。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java8新特性</title>
    <link href="/2019/08/25/Java/tools/java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2019/08/25/Java/tools/java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="Java8新特性"><a href="#Java8新特性" class="headerlink" title="Java8新特性"></a>Java8新特性</h1><h2 id="接口默认方法与静态方法"><a href="#接口默认方法与静态方法" class="headerlink" title="接口默认方法与静态方法"></a>接口默认方法与静态方法</h2><h3 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h3><p>实现方式：</p><pre><code class="java">public interface UserInterface {    default void addUser(){        System.out.println(&quot;add user&quot;);    }}</code></pre><p>在接口定义中使用<code>default</code>关键字即可定义一个自带方法内容的接口方法，子类可以不实现该方法。</p><h4 id="接口冲突"><a href="#接口冲突" class="headerlink" title="接口冲突"></a>接口冲突</h4><p>接口是允许实现多个接口的，试想如果有两个接口，分别为<code>UserInterface1</code>、<code>UserInterface2</code>，他们均定义了一名名为<code>addUser</code>的默认方法，此时，如果有一个子类同时实现了这两个接口，实现方调用<code>addUser</code>则产生冲突。</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>可以在不破坏代码的前提下扩展原有库的功能。它通过一个很优雅的方式使得接口变得更智能，同时还避免了代码冗余，并且扩展类库。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>使得口作为协议，类作为具体实现的界限开始变得有点模糊。如果继承关系较多，可能增加一些开发成本。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><pre><code class="java">public interface UserInterface {    static String getUser(){        System.out.println(&quot;this user&quot;);        return &quot;user&quot;;    }}</code></pre><h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><code>Lambda</code>表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（即：<strong>行为参数化</strong>，函数作为参数传递进方法中）。</p><p>一个<code>Lambda</code>可以由用逗号分隔的参数列表、<code>–&gt;</code>符号与函数体三部分表示。</p><p>遍历List的两种方式：</p><pre><code class="java">@Testpublic void t1(){  List&lt;String&gt; list = new ArrayList&lt;&gt;();  list.add(&quot;A&quot;);  list.add(&quot;B&quot;);  list.add(&quot;C&quot;);  System.out.println(&quot;普通遍历：&quot;);  for(String str : list){    System.out.println(str);  }  System.out.println(&quot;java8遍历：&quot;);  list.forEach(str-&gt;{    System.out.println(str);  });}</code></pre><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口是指一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。</p><p>一个<code>Lambda</code>表达式就是一个抽象方法的实现。</p><p><code>@FunctionalInterface</code>定义的接口都可以使用在<code>Lambda</code>表达式上。</p><h3 id="Java8自带的函数式接口"><a href="#Java8自带的函数式接口" class="headerlink" title="Java8自带的函数式接口"></a>Java8自带的函数式接口</h3><p><strong>Comparator (比较器接口)</strong></p><pre><code class="java">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</code></pre><p><strong>Consumer (消费型接口)</strong></p><p><code>Consumer</code>接口表示执行在单个参数上的操作。 </p><p>扩展：</p><ul><li>BiConsumer</li><li>DoubleConsumer</li><li>IntConsumer</li><li>LongConsumer</li><li>ObjDoubleConsumer</li><li>ObjIntConsumer</li><li>ObjLongConsumer</li></ul><p><strong>Supplier（供应型接口）</strong></p><p><code>Supplier</code>接口是不需要参数并返回一个任意范型的值</p><p>扩展：</p><ul><li>BooleanSupplier</li><li>DoubleSupplier</li><li>IntSupplier</li><li>LongSupplier</li></ul><p><strong>Predicate（断言型接口）</strong></p><p><code>Predicate</code>接口只有一个参数，返回<code>boolean</code>类型。</p><p>扩展：</p><ul><li>BiPredicate</li><li>DoublePredicate</li><li>IntPredicate</li><li>LongPredicate</li></ul><p><strong>Function (功能型接口)</strong></p><p><code>Function</code>接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（<code>compose</code>, <code>andThen</code>）</p><p>扩展：</p><ul><li>BiFunction</li><li>DoubleFunction</li><li>IntFunction</li><li>LongFunction</li><li>ToDoubleFunction</li><li>ToDoubleBiFunction</li></ul><p><strong>Operator</strong></p><p><code>Operator</code>其实就是<code>Function</code>，函数有时候也叫作算子。算子在Java8中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。</p><ul><li>UnaryOperator</li><li>BinaryOperator</li></ul><p><strong>示例代码</strong></p><pre><code class="java">public class User {    private Work work;    public Work getWork() {        return work;    }    public void setWork(Work work) {        this.work = work;    }    public void eat(String food, Consumer&lt;String&gt; consumer) {        consumer.accept(food);    }    public void eat(String food, Supplier&lt;String&gt; supplier) {        String s = supplier.get();        System.out.println(&quot;Supplier -&gt;&gt; &quot; + food + &quot;:&quot; + s);    }    public void eat(String food, Predicate&lt;String&gt; predicate) {        if (predicate.test(&quot;admin&quot;)) {            System.out.println(&quot;Predicate -&gt;&gt; admin eat &quot; + food);        }    }    public void work(Integer month,Function&lt;Work, Integer&gt; function) {        Integer amount1 = function.compose(w-&gt; {            Work ww = new Work();            ww.setSalary(((Work)w).getSalary()*month);            return ww;        }).apply(this.getWork());        System.out.println(&quot;Function compose -&gt;&gt; amount:&quot;+ amount1);        Integer amount2 = function.andThen(salary -&gt; salary * month).apply(this.getWork());        System.out.println(&quot;Function andThen -&gt;&gt; amount:&quot;+ amount2);    }    public static void main(String[] args) {        User user = new User();        user.eat(&quot;banana&quot;, (Consumer&lt;String&gt;)s -&gt; System.out.println(&quot;Consumer -&gt;&gt; food is : &quot; + s));        user.eat(&quot;banana&quot;, (Predicate&lt;String&gt;)s -&gt; s.equals(&quot;admin&quot;));        user.eat(&quot;apple&quot;, () -&gt; &quot;sdf&quot;);        Work work = new Work();        work.setSalary(100);        user.setWork(work);        user.work(8, s -&gt; {            Integer salary = s.getSalary();            //奖金            Integer bons = 100000;            return salary + bons;        });        UnaryOperator&lt;Integer&gt; increment = x -&gt; x + 1;        System.out.println(&quot;UnaryOperator -&gt;&gt; &quot; + increment.apply(2));        BinaryOperator&lt;Integer&gt; add = (x, y) -&gt; x + y;        System.out.println(&quot;BinaryOperator -&gt;&gt; &quot; + add.apply(2, 3));        BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy((o1, o2) -&gt; o1 - o2);        System.out.println(&quot;BinaryOperator -&gt;&gt; &quot; + min.apply(2, 3));    }}public class Work {    private Integer salary;    public Integer getSalary() {        return salary;    }    public void setSalary(Integer salary) {        this.salary = salary;    }}</code></pre><p><strong>示例输出</strong></p><pre><code class="text">Consumer -&gt;&gt; food is : bananaPredicate -&gt;&gt; admin eat bananaSupplier -&gt;&gt; apple:sdfFunction compose -&gt;&gt; amount:100800Function andThen -&gt;&gt; amount:800800UnaryOperator -&gt;&gt; 3BinaryOperator -&gt;&gt; 5BinaryOperator -&gt;&gt; 2</code></pre><h3 id="自定义函数式接口"><a href="#自定义函数式接口" class="headerlink" title="自定义函数式接口"></a>自定义函数式接口</h3><p>自定义函数式接口只需要在接口中添加<code>@FunctionalInterface</code>注解，并为这个接口提供至少一个公共方法即可。下面示例代码将自定义个将map转为list的函数式接口：</p><pre><code class="java">import java.util.List;import java.util.Map;@FunctionalInterfacepublic interface ListToMapFunction&lt;K,V&gt; {    public Map&lt;K,V&gt; apply(List&lt;V&gt; list);}</code></pre><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>首先列举一下java8中使用stream将list转为map的代码：</p><pre><code class="java">public static void main(String[] args) {        List&lt;User&gt; users = new ArrayList&lt;&gt;();        users.add(new User(1));        users.add(new User(2));        users.add(new User(3));        users.add(new User(4));        users.add(new User(5));        users.stream().collect(Collectors.toMap(u-&gt;u.getId(),u-&gt;u));    }</code></pre><p>在java8中我们可以直接通过方法应用来简写<code>Lambda</code>表达式中已经存在的方法，修改为：</p><pre><code class="java">users.stream().collect(Collectors.toMap(User::getId,u-&gt;u));</code></pre><p>其中<code>User::getId</code>就是方法引用，方法引用的操作符是双冒号<code>::</code>。</p><p><strong>方法引用</strong>是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。</p><p>方法引用有四种写法：</p><ul><li>引用静态方法: ContainingClass::staticMethodName</li><li>引用某个对象的实例方法: containingObject::instanceMethodName</li><li>引用某个类型的任意对象的实例方法:ContainingType::methodName</li><li>引用构造方法: ClassName::new</li></ul><h2 id="Stream流"><a href="#Stream流" class="headerlink" title="Stream流"></a>Stream流</h2><p><code>Stream</code>是java8新增的类，主要是用来补充集合类。它代表数据流，流中的数据元素的数量可能是有限的，也可能是无限的。</p><p><code>Stream</code>与集合类的区别：集合类关注有限数量的数据访问和有效管理，而<code>Stream</code>是在数据源上执行可计算的操作。在一个流中，可以执行一个或者多个中间操作，再执行一个最终操作来返回结果。</p><p>中间操作有：</p><ul><li><code>filter</code></li><li><code>map</code>：归类为一组数据</li><li><code>flatMap</code>：将map生成的流合并成单个流</li><li><code>peek</code>:与<code>map</code>类型，区别是它接受一个没有返回值的表达式</li><li><code>distinct</code>:去重</li><li><code>sorted</code>:对流中的元素进行排序</li><li><code>limit</code>:减少流的大小</li><li><code>substream</code></li></ul><p>终止操作有：</p><ul><li><code>forEach</code>：遍历该流中的每个元素</li><li><code>toArray</code></li><li><code>reduce</code>:用于对两个顺序流的计算</li><li><code>collect</code>:方法是终端操作，这是通常出现在管道传输操作结束标记流的结束</li><li><code>min</code></li><li><code>max</code></li><li><code>count</code></li><li><code>anyMatch</code>:是否存在任意一个元素满足条件（返回布尔值）</li><li><code>allMatch</code>:是否所有元素都满足条件（返回布尔值）</li><li><code>noneMatch</code>:是否所有条件都不满足（返回布尔值）</li><li><code>findFirst</code>:查找到第一个就返回Optional</li><li><code>findAny</code>:查找到任意一个就返回Optional</li><li><code>java.util.stream.Collectors</code></li></ul><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p><code>Optional</code>实际上是个容器：它可以保存类型T的值，或者仅仅保存null。<code>Optional</code>提供很多有用的方法，这样我们就不用显式进行空值检测。</p><p>方法说明：</p><ul><li><code>isPresent</code>:为空返回true,否返回false</li><li><code>orElse</code>:为空，则返回默认值</li><li><code>orElseGet</code>:为空，调动get回调函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot2.0整合Activiti6.0问题梳理</title>
    <link href="/2019/05/23/Java/tools/SpringBoot2.0%E6%95%B4%E5%90%88Activiti6.0%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/"/>
    <url>/2019/05/23/Java/tools/SpringBoot2.0%E6%95%B4%E5%90%88Activiti6.0%E9%97%AE%E9%A2%98%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot2-0整合Activiti6-0问题梳理"><a href="#SpringBoot2-0整合Activiti6-0问题梳理" class="headerlink" title="SpringBoot2.0整合Activiti6.0问题梳理"></a>SpringBoot2.0整合Activiti6.0问题梳理</h1><p>SpringBoot整合Activiti很简单，我们可以通过springboot的starter来快速整合，只需要在pom文件中引入一下内容即可：</p><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;version&gt;6.0.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>详细源码请见:<a href="https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act" target="_blank" rel="noopener">https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act</a></p><p>在Activiti6.0发布的时候，SpringBoot2.0还未发布，所以直接启动，会出现如下错误:</p><pre><code>org.springframework.beans.factory.BeanCreationException: Error creating bean with name &#39;requestMappingHandlerMapping&#39; defined in class path resource [org/springframework/boot/autoconfigure/web/servlet/WebMvcAutoConfiguration$EnableWebMvcConfiguration.class]: Invocation of init method failed; nested exception is java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1706) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:579) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:501) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:317) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:228) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:315) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:199) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:760) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:869) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:550) ~[spring-context-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:140) ~[spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:759) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:395) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1255) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1243) [spring-boot-2.0.2.RELEASE.jar:2.0.2.RELEASE]    at pers.jarome.scs.act.ActApplication.main(ActApplication.java:17) [classes/:na]Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy    at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_181]    at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_181]    at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_181]    at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_181]    at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_181]    at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_181]    at java.lang.Class.createAnnotationData(Class.java:3521) ~[na:1.8.0_181]    at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_181]    at java.lang.Class.createAnnotationData(Class.java:3526) ~[na:1.8.0_181]    at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_181]    at java.lang.Class.getAnnotation(Class.java:3415) ~[na:1.8.0_181]    at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258) ~[na:1.8.0_181]    at java.lang.Class.isAnnotationPresent(Class.java:3425) ~[na:1.8.0_181]    at org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation(AnnotatedElementUtils.java:573) ~[spring-core-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.isHandler(RequestMappingHandlerMapping.java:177) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:217) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:188) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:129) ~[spring-webmvc-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1765) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.6.RELEASE.jar:5.0.6.RELEASE]    ... 16 common frames omitted</code></pre><p>查阅网上资料得知是因为，Activiti6.0发布时，SpringBoot2.0 并没有发布，所以Activiti6.0仅支持1.2.6以上，2.0.0以下版本的SpringBoot。</p><p>通过调试（调试方式可以参照这一篇博客：<a href="http://hengyunabc.github.io/spring-boot-ArrayStoreException/" target="_blank" rel="noopener">深入Spring Boot：怎样排查 java.lang.ArrayStoreException</a>）查看源码很容易发现<code>SecurityAutoConfiguration</code>源码因为SpringBoot内部结构的变化，从而引起该类出现编译错误。</p><p>针对这一类情况有三种解决办法，分别如下：</p><ul><li>将springboot2.0换成1.X版本</li><li>在springboot启动类上排除<code>SecurityAutoConfiguration</code>类</li><li>修改SecurityAutoConfiguration源码，使其支持SpringBoot2.0</li></ul><p>对于上诉的三种方法，第一种最为简单，直接切换版本即可，但这样就不能使用SpringBoot2.0的特性，所以并不推荐；对于第三种方法，我认为难度较大，且具备极大的风险，并且Activiti的更高版本肯定也会修复，所以也不推荐该方法。</p><p>所以，最优的方法当属第二种，其具体操作如下：</p><pre><code>@SpringBootApplication(exclude = org.activiti.spring.boot.SecurityAutoConfiguration.class)public class ActApplication {    public static void main(String[] args) {        SpringApplication.run(ActApplication.class);    }}public class ActApplication {    public static void main(String[] args) {        SpringApplication.run(ActApplication.class);    }}</code></pre><p>但是，如果你的启动类中加入了<code>@EnableAutoConfiguration</code>注解，上面的方法就失效了，此时应该使用下面的方式：</p><pre><code>@SpringBootApplication@EnableAutoConfiguration(exclude =   org.activiti.spring.boot.SecurityAutoConfiguration.class)public class ActApplication {    public static void main(String[] args) {        SpringApplication.run(ActApplication.class);    }}</code></pre><p>详细源码请见:<a href="https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act" target="_blank" rel="noopener">https://github.com/jiangliuhong/springcloud-stu/tree/master/scs-act</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础学习</title>
    <link href="/2019/05/23/normal/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/05/23/normal/JavaScript%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript基础学习"><a href="#JavaScript基础学习" class="headerlink" title="JavaScript基础学习"></a>JavaScript基础学习</h1><blockquote><p>JavaScript，简称JS，是一种高级的、解释执行的编程语言。JavaScript是一门基于原型、函数先行的语言，是一门多范式语言，它支持面向对象编程，以及函数式编程。它被世界上的绝大多数网站使用，也被世界主流浏览器支持。</p></blockquote><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>在JavaScript中，对象和函数同样也是变量。</p><p>在JavaScript中，作用域可访问变量，对象，函数的集合。</p><p>对于变量而言，在JavaScript中有两个范围：全局和局部。在函数定义之外的声明的变量属全局变量，它在整个应用程序（也就是整个页面的js）都可以访问；反之，函数定义之内的声明的变量属局部变量，每当函数执行时，会创建变量，当函数执行完成后，都会销毁变量，并且该函数之外的内容无法访问该变量。</p><p>在JavaScript中同样也支持块作用域。</p><p>块作用域主要有for,if,with,tyr/catch,let,const。</p><pre><code class="javascript">for(var i=o;i&lt;10;i++){    console.log(i);}</code></pre><p>因为在for循环内部定义了i变量，顾i变量只能在for循环体内使用。</p><pre><code class="javascript">var foo = true;if (foo) { var bar = foo * 2; bar = something( bar );  console.log( bar );}</code></pre><p>bar变量仅声明在if的上下文中，因此在使用bar变量的时候，只能在if的方法体内使用。</p><p>with语句的作用是将代码的作用域设置到一个特定的作用域中，with 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。</p><p>比如：</p><pre><code class="javascript">var obj = { a: 1, b: 2, c: 3};// 单调乏味的重复 &quot;obj&quot;obj.a = 2;obj.b = 3;obj.c = 4;// 简单的快捷方式with (obj) { a = 3; b = 4; c = 5;}</code></pre><p>try/catch相对比较容易理解，就是try与catch创建的{}代码块属于一个块作用域。</p><p>let是ES6提出的一个新的声明变量的关键字，let关键字可以将变量绑定在其所在的任意作用域中，通常是{}中，但这是一种隐式行为。</p><p>const，与let相似的，const也是ES6引入的一个新的声明变量的关键字，但其值是固定的，即常量。</p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>在JavaScript中共有6中基本数据类型：</p><ul><li>Undefined：表示一个对象未定义</li><li>Null：对象已经定义，但这个对象是空的，即空指针对象</li><li>Boolean：布尔类型，该类型只有两个值true、false</li><li>Number：数字类型，包括整数、浮点数，当然也支持十进制、八进制、十六进制表示。另外Number还有一个特殊的值，NaN，该值用于表示一个本来要返回数值的对象，但未返回数值的情况</li><li>String：字符串类型</li><li>Symbol：ES6新引入的数据类型，它表示一个独一无二的值，其作用是放置属性名冲突</li></ul><p>基础类型比较：</p><p>在JavaScript中，比较两个基础类型，JS会自动读数据进行隐式转换，比如:</p><pre><code class="javascript">var a = 1;var b = true;console.log(a == b);    // trueconsole.log(a === b);   // false</code></pre><p>在JavaScript中， ==，双等号只进行值比较，如果两者数据不同意，则会自动转成同意的数据格式进行比较，当然如果转换格式失败，则会抛出异常。===，三等又称强等号，三等不仅会验证值是否一致，同时也是验证数据格式是否一致。</p><p>基础类型的变量存在在栈内存(Stack)中。</p><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>JavaScript中的引用类型，即Object类型，对象类型，对象可以是一个类型的实例化对象，也可以是一组数据源，也可以是一个功能函数。在JavaScript中，Object又有许多子类型，如：Array，Date，RegExp，Function等。</p><p>RegExp类型，即正则表达式，在JavaScript中，它是用于描述字符模式的对象，正则表达式用于对字符模式匹配、检索替换，是操作字符串执行模式匹配的强大工具。其使用方式如下：</p><pre><code class="javascript">//验证字符串是否全数字var re = new RegExp(&quot;^[0-9]*$&quot;);var str = &#39;123213123&#39;re.test(str)//true</code></pre><p>对于RegExp支持的字符串方法有：search、match、replace、split。</p><p>Function，函数类型，每个函数都是Function类型的实例。</p><p>对于函数，其返回值比较特殊，如果其方法体内没有返回值，则返回一个undefined。</p><pre><code class="javascript">function test1(){        }function test2(){    return 1;}function test3(){    return ;}var t1 = test1();var t2 = test2();var t3 = test3();console.log(t1);//undefinedconsole.log(t2);//1console.log(t3);//undefined</code></pre><p>对于引用类型的值是按照引用访问的。所以在比较引用类型的时候，双等号与三等号作用相同，比较的是两个对象的引用地址，引用地址相同，才会返回true。例如：</p><pre><code class="javascript">var obj1 = {};    // 新建一个空对象 obj1var obj2 = {};    // 新建一个空对象 obj2console.log(obj1 == obj2);    // falseconsole.log(obj1 === obj2);   // false</code></pre><p>引用类型的值存在堆内存(Heap)中。</p><p>虽然引用类型保存在堆内存中，但是JavaScript不能直接操作堆内存，所以在JavaScript中，栈内存中保存了变量标识符和指向堆内存中该对象的指针，堆内存中保存了对象的内容。</p><h2 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h2><p>在JavaScript中，有两个较特殊的关键字，分别为typeof、instanceof。</p><p>typeof主要用来检测一个变量是否为基本的数据类型。</p><pre><code class="javascript">var a;typeof a;    // undefineda = null;typeof a;    // objecta = true;typeof a;    // booleana = 666;typeof a;    // number a = &quot;hello&quot;;typeof a;    // stringa = Symbol();typeof a;    // symbola = function(){}typeof a;    // functiona = [];typeof a;    // objecta = {};typeof a;    // objecta = /aaa/g;typeof a;    // object   </code></pre><p>instanceof主要用来检测构造函数的prototype属性所指向的对象是否存在于另一个检测对象的原型链（关于原型链见下文）上。</p><pre><code class="javascript">({}) instanceof Object              // true([]) instanceof Array               // true(/aa/g) instanceof RegExp           // true(function(){}) instanceof Function  // true</code></pre>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud快速构建</title>
    <link href="/2019/05/22/Java/spring/SpringCloud%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA/"/>
    <url>/2019/05/22/Java/spring/SpringCloud%E5%BF%AB%E9%80%9F%E6%9E%84%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud快速构建"><a href="#SpringCloud快速构建" class="headerlink" title="SpringCloud快速构建"></a>SpringCloud快速构建</h1><blockquote><p>SpringCloud是2014年底Spring团队基于SpringBoot开发的，推出的Java领域微服务架构完整解决方案。主要包括服务注册于发现、配置中心、全链路监控、API网关、熔断器等选型中立的开源组件。</p></blockquote><p>基础组件列表如下：</p><table><thead><tr><th>名称</th><th>功能</th><th>简介</th></tr></thead><tbody><tr><td>Eureka</td><td>注册中心</td><td>保证一致性与高可用</td></tr><tr><td>Consul</td><td>注册中心</td><td>保证强一致性</td></tr><tr><td>Zuul</td><td>网关</td><td>第一代网关</td></tr><tr><td>Gateway</td><td>网关</td><td>第二代网关</td></tr><tr><td>Ribbon</td><td>负载均衡</td><td>进程内负载均衡</td></tr><tr><td>Hystrix</td><td>熔断器</td><td>延迟、容错</td></tr><tr><td>Fegin</td><td>声明式HTTP客户端</td><td></td></tr><tr><td>Sleuth</td><td>链路追踪</td><td></td></tr><tr><td>Config</td><td>配置中心</td><td></td></tr><tr><td>Bus</td><td>总线</td><td></td></tr></tbody></table><h2 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h2><p>Eureka是Netflix开源的一款提供服务注册和发现的产品，它提供了完整的Service Registry和Service Discovery实现。也是springcloud体系中最重要最核心的组件之一。</p><p>添加依赖：</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>在启动类中添加<code>@EnableEurekaServer</code>注解：</p><pre><code class="java">@SpringBootApplication@EnableEurekaServerpublic class SpringCloudEurekaApplication {    public static void main(String[] args) {        SpringApplication.run(SpringCloudEurekaApplication.class, args);    }}</code></pre><p>编写对应的配置文件：</p><pre><code class="yaml">spring:    application:        name: spring-cloud-eurekaserver:    port: 8000eureka:    client:        register-with-eureka: false        fetch-registry: false    serviceUrl:        defaultZone: http://localhost:${server.port}/eureka/</code></pre><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p><p>引入依赖：</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>在启动类中添加<code>@EnableFeignClients</code>注解</p><pre><code class="java">@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application {    public static void main(String[] args) {        new SpringApplicationBuilder(Application.class).web(true).run(args);    }}</code></pre><p>创建一个Feign的客户端接口定义。使用<code>@FeignClient</code>注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定<code>eureka-client</code>服务的<code>/dc</code>接口的例子：</p><pre><code class="java">@FeignClient(&quot;eureka-client&quot;)public interface DcClient {    @GetMapping(&quot;/dc&quot;)    String consumer();}</code></pre><p><code>@FeignClient</code>注解：</p><ul><li><p>name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现</p></li><li><p>url: url一般用于调试，可以手动指定@FeignClient调用的地址</p></li><li><p>decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException</p></li><li><p>configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract</p></li><li><p>fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口</p></li><li><p>fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码</p></li><li><p>path: 定义当前FeignClient的统一前缀</p></li></ul><h2 id="Hystix"><a href="#Hystix" class="headerlink" title="Hystix"></a>Hystix</h2><p><code>Hystix</code>是一个供分布式系统使用，提供延迟和容错功能，保证复杂的分布系统在面临不可避免的失败时，仍能有其弹性。</p><p>添加依赖：</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;  &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>启动类上增加Hystrix的注解：</p><pre><code class="java">@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic class HystrixRibbonApp {    public static void main(String[] args) {        SpringApplication.run(HystrixRibbonApp.class, args);    }    @Bean    @LoadBalanced    RestTemplate restTemplate() {        return new RestTemplate();    }}</code></pre><p>修改代码逻辑，在需要熔断的方法上增加@HystrixCommand注解，当调用有问题的时候就会使用fallbackMethod参数指定的方法进行服务降级：</p><pre><code class="java">@RestControllerpublic class HelloController {    @Autowired    HystrixRibbonService helloService;    @RequestMapping(&quot;/hi&quot;)    public String hello(){        return helloService.helloService(&quot;姓名&quot;);    }}@Servicepublic class HystrixRibbonService {    private static final String SERVICE_NAME = &quot;EUREKACLIENT&quot;;    @Autowired    RestTemplate restTemplate;    @Autowired    private LoadBalancerClient loadBalancerClient;    @HystrixCommand(fallbackMethod = &quot;helloServiceFallBack&quot;)    public String helloService(String name) {        ServiceInstance serviceInstance = this.loadBalancerClient.choose(SERVICE_NAME);        System.out.println(&quot;服务主机：&quot; + serviceInstance.getHost());        System.out.println(&quot;服务端口：&quot; + serviceInstance.getPort());        //  通过服务名来访问        return restTemplate.getForObject(&quot;http://&quot; + SERVICE_NAME + &quot;/hello?name=&quot;+name,String.class);    }    @SuppressWarnings(&quot;unused&quot;)    private String helloServiceFallBack(String name) {        return &quot;这个是失败的信息！&quot;;    }}</code></pre><p>在<code>Feign</code>中同样可以使用<code>Hystix</code>，在<code>Feign</code>中指定<code>fallback</code>，示例如下：</p><pre><code class="java">@FeignClient(value=&quot;EUREKACLIENT&quot;, fallback = HystrixFeignServiceFallback.class)public interface HystrixFeignService {    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)     String sayHiUseFeign(@RequestParam(value = &quot;name&quot;) String name);}@Componentpublic class HystrixFeignServiceFallback implements HystrixFeignService{    @Override    public String sayHiUseFeign(String name) {        return &quot;feign调用错误！&quot;;    }}</code></pre><h2 id="Zuul"><a href="#Zuul" class="headerlink" title="Zuul"></a>Zuul</h2><p>在说Zuul之前，应先理解API Gateway(API网关)的概念，API网关即给用户规定一个统一的入口，接收到用户请求后，网关在内部会分发到各个对应的服务服务上。API网关的好处：</p><ul><li>简化客户端调用复杂度</li><li>数据裁剪以及聚合</li><li>多渠道支持</li><li>遗留系统的微服务化改造</li></ul><p>Spring Cloud Zuul路由是微服务架构的不可或缺的一部分，提供动态路由，监控，弹性，安全等的边缘服务。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p><p>引用依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件:</p><pre><code class="yaml">spring:    application:        name: gateway-service-zuulserver:    port: 8888#这里的配置表示，访问/goo/** 直接重定向到http://www.google.comzuul:    routes:        baidu:            path: /goo/**            url: http://www.google.com</code></pre><p>启动类：</p><pre><code class="java">@SpringBootApplication@EnableZuulProxypublic class GatewayServiceZuulApplication {    public static void main(String[] args) {        SpringApplication.run(GatewayServiceZuulApplication.class, args);    }}</code></pre><h3 id="网关服务化"><a href="#网关服务化" class="headerlink" title="网关服务化"></a>网关服务化</h3><p>添加eureka依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件：</p><pre><code class="yaml">spring:    application:        name: gateway-service-zuulserver:    port: 8888zuul:    routes:        server-a:                    path: /goo/**            serviceId: server-aeureka:    client:        serviceUrl:            defaultZone: http://localhost:8000/eureka/</code></pre><p>其中<code>server-a</code>为<code>eureka</code>中的服务。</p><h2 id="Sleuth"><a href="#Sleuth" class="headerlink" title="Sleuth"></a>Sleuth</h2><p>Sleuth是Spring Cloud的组成部分之一，为SpringCloud应用实现了一种分布式追踪解决方案，其兼容了Zipkin, HTrace和log-based追踪</p><p>几个基本术语：</p><ul><li>Span：基本工作单元，发送一个远程调度任务 就会产生一个Span，Span是一个64位ID唯一标识的，Trace是用另一个64位ID唯一标识的，Span还有其他数据信息，比如摘要、时间戳事件、Span的ID、以及进度ID。</li><li>Trace：一系列Span组成的一个树状结构。请求一个微服务系统的API接口，这个API接口，需要调用多个微服务，调用每个微服务都会产生一个新的Span，所有由这个请求产生的Span组成了这个Trace。</li><li>Annotation：用来及时记录一个事件的，一些核心注解用来定义一个请求的开始和结束 。这些注解包括以下：<ul><li>cs - Client Sent -客户端发送一个请求，这个注解描述了这个Span的开始</li><li>sr-Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络传输的时间。</li><li>ss - Server Sent （服务端发送响应）–该注解表明请求处理的完成(当请求返回客户端)，如果ss的时间戳减去sr时间戳，就可以得到服务器请求的时间。</li><li>cr - Client Received （客户端接收响应）-此时Span的结束，如果cr的时间戳减去cs时间戳便可以得到整个请求所消耗的时间。</li></ul></li></ul><h3 id="Spring-Cloud-Sleuth和Zipkin分布式链路跟踪"><a href="#Spring-Cloud-Sleuth和Zipkin分布式链路跟踪" class="headerlink" title="Spring Cloud Sleuth和Zipkin分布式链路跟踪"></a>Spring Cloud Sleuth和Zipkin分布式链路跟踪</h3><h4 id="Zipkin服务端构建"><a href="#Zipkin服务端构建" class="headerlink" title="Zipkin服务端构建"></a>Zipkin服务端构建</h4><p>Zipkin 是一个开放源代码分布式的跟踪系统，由Twitter公司开源，它致力于收集服务的定时数据，以解决微服务架构中的延迟问题，包括数据的收集、存储、查找和展现。</p><p>每个服务向zipkin报告计时数据，zipkin会根据调用关系通过Zipkin UI生成依赖关系图，显示了多少跟踪请求通过每个服务，该系统让开发者可通过一个 Web 前端轻松的收集和分析数据，例如用户每次请求服务的处理时间等，可方便的监测系统中存在的瓶颈。</p><p>Zipkin提供了可插拔数据存储方式：In-Memory、MySql、Cassandra以及Elasticsearch。接下来的测试为方便直接采用In-Memory方式进行存储，生产推荐Elasticsearch。</p><p>首先在项目中添加依赖</p><pre><code class="xml">&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;        &lt;artifactId&gt;zipkin-server&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;io.zipkin.java&lt;/groupId&gt;        &lt;artifactId&gt;zipkin-autoconfigure-ui&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>编写对应的启动类，使用了<code>@EnableZipkinServer</code>注解，启用Zipkin服务。</p><pre><code class="java">@SpringBootApplication@EnableEurekaClient@EnableZipkinServerpublic class ZipkinApplication {    public static void main(String[] args) {        SpringApplication.run(ZipkinApplication.class, args);    }}</code></pre><p>修改配置文件</p><pre><code class="yaml">eureka:  client:    serviceUrl:      defaultZone: http://127.0.0.1:8761/eureka/server:  port: 9000spring:  application:    name: zipkin-server</code></pre><p>配置完成后依次启动示例项目：<code>spring-cloud-eureka</code>、<code>zipkin-server</code>项目。刚问地址:<code>http://localhost:9000/zipkin/</code>可以看到Zipkin后台页面</p><p><img src="./tracing3.png" srcset="/img/loading.gif" alt=""></p><h3 id="客户端添加zipkin支持"><a href="#客户端添加zipkin支持" class="headerlink" title="客户端添加zipkin支持"></a>客户端添加zipkin支持</h3><p>在项目中添加如下依赖：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>配置文件中添加如下代码：</p><pre><code class="yaml">spring:  zipkin:    base-url: http://localhost:9000  sleuth:    sampler:      percentage: 1.0</code></pre><p>spring.zipkin.base-url指定了Zipkin服务器的地址，spring.sleuth.sampler.percentage将采样比例设置为1.0，也就是全部都需要。</p><p>Spring应用在监测到Java依赖包中有sleuth和zipkin后，会自动在RestTemplate的调用过程中向HTTP请求注入追踪信息，并向Zipkin Server发送这些信息。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringCloud</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nginx配置</title>
    <link href="/2018/12/22/server/nginx%E9%85%8D%E7%BD%AE/"/>
    <url>/2018/12/22/server/nginx%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><h2 id="nginx常用编译参数"><a href="#nginx常用编译参数" class="headerlink" title="nginx常用编译参数"></a>nginx常用编译参数</h2><p>对于nginx，如果使用源码安装，在进行./configure编译的时候，需要为其指定一些参数。</p><ul><li><p>–prefix=PATH ： 指定nginx的安装目录。默认 /usr/local/nginx</p></li><li><p>–conf-path=PATH ： 设置nginx.conf配置文件的路径。nginx允许使用不同的配置文件启动，通过命令行中的-c选项。默认为<em>prefix/conf/nginx.conf</em></p></li><li><p>–user=name： 设置nginx工作进程的用户。安装完成后，可以随时在nginx.conf配置文件更改user指令。默认的用户名是nobody。–group=name类似</p></li><li><p>–with-pcre ： 设置PCRE库的源码路径，如果已通过yum方式安装，使用–with-pcre自动找到库文件。使用–with-pcre=PATH时，需要从PCRE网站下载pcre库的源码（版本4.4 – 8.30）并解压，剩下的就交给Nginx的./configure和make来完成。perl正则表达式使用在location指令和 ngx_http_rewrite_module模块中。</p></li><li><p>–with-zlib=PATH ： 指定 zlib（版本1.1.3 – 1.2.5）的源码解压目录。在默认就启用的网络传输压缩模块ngx_http_gzip_module时需要使用zlib 。</p></li><li><p>–with-http_ssl_module ： 使用https协议模块。默认情况下，该模块没有被构建。前提是openssl与openssl-devel已安装</p></li><li><p>–with-http_stub_status_module ： 用来监控 Nginx 的当前状态</p></li><li><p>–with-http_realip_module ： 通过这个模块允许我们改变客户端请求头中客户端IP地址值(例如X-Real-IP 或 X-Forwarded-For)，意义在于能够使得后台服务器记录原始客户端的IP地址</p></li><li><p>–add-module=PATH ： 添加第三方外部模块，如nginx-sticky-module-ng或缓存模块。每次添加新的模块都要重新编译（Tengine可以在新加入module时无需重新编译）</p><h2 id="config基本配置概览"><a href="#config基本配置概览" class="headerlink" title="config基本配置概览"></a>config基本配置概览</h2></li></ul><p>Nginx的配置文件默认在Nginx程序安装目录的conf目录下，其中核心文件为nginx.conf，当然你也可以自己写配置文件，然后在nginx.conf中引用。</p><p>nginx.conf配置具体信息如下：</p><pre><code>#定义Nginx运行的用户和用户组user www www;#nginx进程数，建议设置为等于CPU总核心数。worker_processes 8;#全局错误日志定义类型，[ debug | info | notice | warn | error | crit ]error_log /var/log/nginx/error.log info;#进程文件pid /var/run/nginx.pid;#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀，所以建议与ulimit -n的值保持一致。worker_rlimit_nofile 65535;#工作模式与连接数上限events{    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型是Linux 2.6以上版本内核中的高性能网络I/O模型，如果跑在FreeBSD上面，就用kqueue模型。    use epoll;    #单个进程最大连接数（最大连接数=连接数*进程数）    worker_connections 65535;}#设定http服务器http{    include mime.types; #文件扩展名与文件类型映射表    default_type application/octet-stream; #默认文件类型    #charset utf-8; #默认编码    server_names_hash_bucket_size 128; #服务器名字的hash表大小    client_header_buffer_size 32k; #上传文件大小限制    large_client_header_buffers 4 64k; #设定请求缓    client_max_body_size 8m; #设定请求缓    sendfile on; #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。    autoindex on; #开启目录列表访问，合适下载服务器，默认关闭。    tcp_nopush on; #防止网络阻塞    tcp_nodelay on; #防止网络阻塞    keepalive_timeout 120; #长连接超时时间，单位是秒    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。    fastcgi_connect_timeout 300;    fastcgi_send_timeout 300;    fastcgi_read_timeout 300;    fastcgi_buffer_size 64k;    fastcgi_buffers 4 64k;    fastcgi_busy_buffers_size 128k;    fastcgi_temp_file_write_size 128k;    #gzip模块设置    gzip on; #开启gzip压缩输出    gzip_min_length 1k; #最小压缩文件大小    gzip_buffers 4 16k; #压缩缓冲区    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）    gzip_comp_level 2; #压缩等级    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含text/html，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。    gzip_vary on;    #limit_zone crawler $binary_remote_addr 10m; #开启限制IP连接数的时候需要使用    upstream blog.ha97.com {    #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。    server 192.168.80.121:80 weight=3;    server 192.168.80.122:80 weight=2;    server 192.168.80.123:80 weight=3;    }    #虚拟主机的配置    server    {        #监听端口        listen 80;        #域名可以有多个，用空格隔开        server_name www.ha97.com ha97.com;        index index.html index.htm index.php;        root /data/www/ha97;        location ~ .*.(php|php5)?$        {            fastcgi_pass 127.0.0.1:9000;            fastcgi_index index.php;            include fastcgi.conf;        }        #图片缓存时间设置        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$        {            expires 10d;        }        #JS和CSS缓存时间设置        location ~ .*.(js|css)?$        {            expires 1h;        }        #日志格式设定        log_format access &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;        &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;        &#39;&quot;$http_user_agent&quot; $http_x_forwarded_for&#39;;        #定义本虚拟主机的访问日志        access_log /var/log/nginx/ha97access.log access;        #对 &quot;/&quot; 启用反向代理        location / {            proxy_pass http://127.0.0.1:88;            proxy_redirect off;            proxy_set_header X-Real-IP $remote_addr;            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            #以下是一些反向代理的配置，可选。            proxy_set_header Host $host;            client_max_body_size 10m; #允许客户端请求的最大单文件字节数            client_body_buffer_size 128k; #缓冲区代理缓冲用户端请求的最大字节数，            proxy_connect_timeout 90; #nginx跟后端服务器连接超时时间(代理连接超时)            proxy_send_timeout 90; #后端服务器数据回传时间(代理发送超时)            proxy_read_timeout 90; #连接成功后，后端服务器响应时间(代理接收超时)            proxy_buffer_size 4k; #设置代理服务器（nginx）保存用户头信息的缓冲区大小            proxy_buffers 4 32k; #proxy_buffers缓冲区，网页平均在32k以下的设置            proxy_busy_buffers_size 64k; #高负荷下缓冲大小（proxy_buffers*2）            proxy_temp_file_write_size 64k;            #设定缓存文件夹大小，大于这个值，将从upstream服务器传        }        #设定查看Nginx状态的地址        location /NginxStatus {            stub_status on;            access_log on;            auth_basic &quot;NginxStatus&quot;;            auth_basic_user_file conf/htpasswd;            #htpasswd文件的内容可以用apache提供的htpasswd工具来产生。        }        #本地动静分离反向代理配置        #所有jsp的页面均交由tomcat或resin处理        location ~ .(jsp|jspx|do)?$ {            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            proxy_pass http://127.0.0.1:8080;        }        #所有静态文件由nginx直接读取不经过tomcat或resin        location ~ .*.    (htm|html|gif|jpg|jpeg|png|bmp|swf|ioc|rar|zip|txt|flv|mid|doc|ppt|pdf|xls|mp3|wma)$        { expires 15d; }        location ~ .*.(js|css)?$        { expires 1h; }        }}</code></pre><h2 id="nginx常用配置说明"><a href="#nginx常用配置说明" class="headerlink" title="nginx常用配置说明"></a>nginx常用配置说明</h2><h3 id="nginx日志文件配置"><a href="#nginx日志文件配置" class="headerlink" title="nginx日志文件配置"></a>nginx日志文件配置</h3><p>关于日志文件的配置主要有两个属性log_format、access_log、error_log。</p><h4 id="log-format"><a href="#log-format" class="headerlink" title="log_format"></a>log_format</h4><p>log_format为日志格式，其语法为：</p><pre><code>log_format name format {format ... }</code></pre><p>其中，name表示日志名字，format表示定义的格式样式。</p><p>log_format有一个默认的、无需配置的combined日志格式：</p><pre><code>log_format combined &#39;$remote_addr-$remote_user [$time_local]&#39;&quot;$request&quot;$status $body_bytes_sent &quot;$http_referer&quot; &quot;$http_user_agent&quot;</code></pre><p>在日志格式中的变量主要有：</p><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>$remote_addr</td><td>反向代理服务器的IP地址</td><td>127.0.0.1</td></tr><tr><td>$remote_user</td><td>远程客户端用户名称</td><td>–</td></tr><tr><td>$time_local</td><td>访问时间与时区</td><td>18/Jul/2012:17:00:01 +0800</td></tr><tr><td>$request</td><td>请求URL与HTTP协议</td><td>GET /article-10000.html HTTP/1.1</td></tr><tr><td>$status</td><td>请求状态，例如成功时状态为200，页面找不到时状态为404</td><td>200</td></tr><tr><td>$body_bytes_sent</td><td>发送客户端的文件主体内容大小</td><td>1000</td></tr><tr><td>$upstream_status</td><td>upstream状态</td><td>200</td></tr><tr><td>$http_referer</td><td>访问来源</td><td><a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></td></tr><tr><td>$http_user_agent</td><td>客户浏览器的相关信息</td><td>Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; SV1; GTB7.0; .NET4.0C;</td></tr><tr><td>$ssl_protocol</td><td>SSL协议版本</td><td>TLSv1</td></tr><tr><td>$ssl_cipher</td><td>交换数据中的算法</td><td>RC4-SHA</td></tr><tr><td>$upstream_addr</td><td>后台upstream的地址，即真正提供服务的主机地址</td><td>10.10.10.100:80</td></tr><tr><td>$request_time</td><td>整个请求的总时间</td><td>0.205</td></tr><tr><td>$upstream_response_time</td><td>请求过程中，upstream响应时间</td><td>0.002</td></tr><tr><td>$http_host</td><td>请求地址，即浏览器中你输入的地址（IP或域名）</td><td><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 192.168.1.1</td></tr></tbody></table><h4 id="access-log"><a href="#access-log" class="headerlink" title="access_log"></a>access_log</h4><p>access_log主要用于记录nginx访问日志。其语法如下：</p><pre><code>access_log path [foramt {buffer-size | off} </code></pre><p>关闭日志方法：access_log off。</p><p>使用默认combined格式记录日志：access_log path。</p><p>使用自定义格式记录日志，首先定义一个log_format，如log_format customformat ‘具体配置’。</p><p>access_log path customformat  buffer=32k。</p><p>结尾的buffer代表缓冲区大小。</p><h4 id="error-log"><a href="#error-log" class="headerlink" title="error_log"></a>error_log</h4><p>与access_log不同的是，error_log主要记录nginx运行过程中的错误日志。其语法如下</p><pre><code>error_log &lt;FILE&gt; &lt;LEVEL&gt;</code></pre><p>其中参数含义如下：</p><ul><li>FILE：代表日志文件存放目录。</li><li>LEVEL：错误日志级别。</li></ul><p>常见的错误日志级别有：debug | info | notice | warn | error | crit | alert | emerg ，级别越高记录的错误信息越少。对于我们而言，一般用到的为warn，error,crit。</p><h3 id="nginx压缩输出"><a href="#nginx压缩输出" class="headerlink" title="nginx压缩输出"></a>nginx压缩输出</h3><p>nginx压缩输出使用的技术为gzip(GNU-ZIP)压缩技术。经过gzip压缩后的页面大小可以变为原来的30%以下，压缩页面后可以降低用户在浏览页面时下载资源的时间，但gzip有个明显的去诶按，就是需要服务端与客户端同步支持gzip，即服务器压缩，浏览器解压。目前IE、Chrome等主流浏览器均具备解压gzip的功能。</p><p>nginx中的gzip指令如下：</p><p>开启或关闭gzip</p><pre><code>gzip on|off</code></pre><p>设置系统获取几个单位的缓存用于存储gzip的压缩结果数据流</p><pre><code>gzip_buffers number size</code></pre><p>设置gzip压缩比例</p><pre><code>gzip_comp_level 1..9</code></pre><p>设置允许压缩的页面最小字节数，当页面超过该数值时才进行压缩，其默认为0，即所有页面都进行压缩</p><pre><code>gzip_min_length length</code></pre><h3 id="nginx作为静态服务器"><a href="#nginx作为静态服务器" class="headerlink" title="nginx作为静态服务器"></a>nginx作为静态服务器</h3><p>nginx其根本上是一个HTTP服务器，可以将服务器撒花姑娘的静态资源文件（如HTML、JS、Image）通过HTTP协议展现给客户端。</p><pre><code>server {    listen 80; # 端口号    location / {        root /usr/share/nginx/html; # 静态文件路径    }}</code></pre><h3 id="nginx负载均衡与反向代理"><a href="#nginx负载均衡与反向代理" class="headerlink" title="nginx负载均衡与反向代理"></a>nginx负载均衡与反向代理</h3><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><blockquote><p>负载均衡就是由多台服务器以对称的方式组成一个服务器集合，每台服务器都具有等价的地位，都可以单独对外提供服务而无须其他服务器的辅助。通过某种负载分担技术，将外部送来的请求均匀分配到对称结构中的某一台服务器上，而接收到请求的服务器独立地回应客户的请求。</p></blockquote><p>常见的复杂均衡主要有：</p><ul><li>用户手动选择：通过用户手动选择线路。</li><li>DNS轮询：为域名添加多个解析记录。</li><li>四/七层负载均衡设备：硬件实现负载均衡，如F5。软件实现为LVS。</li><li>Nginx负载均衡</li></ul><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><blockquote><p>反向代理是指以代理服务器来接受Internet上的连接请求，然后将请求发给内部网路上的服务器，并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</p></blockquote><h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在nginx中，通过Upstream可以设置一组在proxy_pass和fastcgi_pass指令中使用的代理服务器，默认的负载均衡方式为轮询，Upstream模块中的Server指令用于指定后端服务器的名称和参数，服务器的名称可以是一个域名、一个IP地址、端口号或UNIX Socket。</p><p>而在server{}虚拟主机内，可以通过proxy_pass和fastcgi_pass指令设置进行反向代理的服务器集群。</p><p>proxy_set_header指令用于在向反向代理的后端Web服务器发起请求时添加指定的Header头信息。</p><p>当后端Web服务器上有多个基于域名的虚拟主机时，要通过添加Header头信息Host，用于指定请求的域名，这样后端Web服务器才能识别该方向代理访问请求由哪一个虚拟主机来处理。</p><p>在使用方向代理后，连接通过代理服务器链接到目标服务器后，如果在目标服务器中存在获取用户真实IP的代码（比如，Java、PHP等后台语言）就会失效，这时服务器获取的是代理服务器的IP。如果要获取真实IP，需要在nginx反向代理配置里添加Header头信息：X-Forwarded-For,让目标服务器能够获取用户的真实IP。</p><p>具体配置如下：</p><pre><code>upstream baidu.com {    # weight 设置权重      server 127.0.0.1:8881 weight=3;      server 127.0.0.1:8882;      server 127.0.0.1:8888;}server{     listen 80;     server_name baidu.com;     location / {         proxy_pass         http://baidu.com;         proxy_set_header   Host             $host;         #获取真实IP设置        proxy_set_header   X-Real-IP        $remote_addr;         proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;     } }</code></pre>]]></content>
    
    
    <categories>
      
      <category>服务器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网关</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot介绍</title>
    <link href="/2018/10/22/Java/spring/SpringBoot%E4%BB%8B%E7%BB%8D/"/>
    <url>/2018/10/22/Java/spring/SpringBoot%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot介绍"><a href="#SpringBoot介绍" class="headerlink" title="SpringBoot介绍"></a>SpringBoot介绍</h1><blockquote><p>Spring框架为我们提供了多种解决方案，但在使用它的时候总免不了进行导包、配置等操作。于是在2012年10月，有人提出了新需求，要求在Spring框架中支持无容器Web应用程序体系结构，即无不需要将项目打包后放置在中间件中，直接通过main方法引导的Spring容器内配置Web容器服务。 于是，2014年4月,SpringBoot正式发布。</p></blockquote><h2 id="SpringBoot四大特性"><a href="#SpringBoot四大特性" class="headerlink" title="SpringBoot四大特性"></a>SpringBoot四大特性</h2><p>在Spring官网这样说到：</p><p>SpringBoot可以轻松创建一个独立的、基于昌平级别的Spring应用程序，我们可以不依赖服务器中间件，直接运行程序。我们的目标是：</p><ul><li>为所有Spring开发提供一个从根本上更快，且随处可得的入门体验。</li><li>开箱即用，但通过不采用默认设置可以快速摆脱这种方式。</li><li>提供一系列大型项目常用的非功能性特征，比如：内嵌服务器，安全，指标，健康检测，外部化配置。</li><li>绝对没有代码生成，也不需要XML配置。</li></ul><p>在我看来SpringBoot其实并不是一个新的框架，它更像是一个总指挥，能够按照我的需求去引入框架，比如，我需要使用SpringMVC，对于SpringBoot而言，我只需要引入一个spring-boot-starter-web，它就会默认去帮我把SpringMVC，tomcat等等都引入到我的工程里。</p><p>SpringBoot主要提供了四个特性，也正是这四个特性才能改变开发Spring引用程序的方式：</p><ul><li>SpringBoot Starter：它将常用的依赖分组进行了整合，将其合并到一个依赖中，这样可以一次性添加所有的依赖到项目中，注意，这里一般指的是Maven或Gradle。</li><li>自动配置：SpringBoot的自动配置特性利用了Spring4对条件华配置的支持，合理地推测应用所需的Bean并自动化配置他们。</li><li>命令行接口（Command-line interface,即<code>CLI</code>）：SpringBoot的CLI发挥了Groovy编程语言的优势，并结合自动配置进一步简化Spring应用的开发。</li><li>Actuator：它为SprigBoot应用添加了一定的管理特性。</li></ul><h2 id="SpringBoot优缺点"><a href="#SpringBoot优缺点" class="headerlink" title="SpringBoot优缺点"></a>SpringBoot优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>SpringBoot的优点其实可以看做是基于上文四点衍生出来的。</p><ul><li>简化依赖，避免了我们手动去配置Maven/Gradle依赖，仅一个starter就能够搞定。</li><li>利用starter可以达到自动化配置的效果。</li><li>去除了大量的XML配置文件，采用全注解的方式。</li><li>舍弃外部的服务器中间件，可以利用其内嵌的tomcat/jetty直接运行。</li><li>使用CLI可以快速构建SpringBoot程序</li><li>拥有SpringCloud微服务解决方案</li></ul><p>在SpringBoot1.0正式发布之后，2014年年底，Spring团队基于SpringBoot推出SpringCloud，提供一套完整的微服务解决方案。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>升级难，不能友好的兼容老版本的SpringFramework项目。对于某些项目可能会存在升级的情况，即将老的框架升级为新框架，但如果你想升级使用SpringBoot，我想这应该是一个非常困难的过程。</li><li>配置服务器服务麻烦。</li><li>增量更新文件麻烦，因为是jar，如果遇见需要更新包类的一个js、html等文件，则需要先解压后再替换，最后再压缩。</li></ul><h2 id="SpringBoot2-0"><a href="#SpringBoot2-0" class="headerlink" title="SpringBoot2.0"></a>SpringBoot2.0</h2><p>SpringBoot2.0是2018年3月发布的版本，该版本基于Spring Framework5.0，与SpringFramework5.0对应的是，SpringBoot2.0同样支持的最低版本为Java8，同时也支持Java9。</p><p><strong>SpringBoot2.0新特性：</strong></p><ul><li>修改默认数据库连接池，从tomcat改为HikariCP。</li><li>优化NOSQL（Redis等）集成方式。</li><li>升级内嵌容器（Tomcat、Jetty）。</li><li>适配Spring5.0的WebFlux。</li><li>增加Quartz自动配置，增加Starter。</li></ul><p>当然，对于Spring2.0的新特性远不止于此。本文主要列举了几个较为明显且常见的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring核心原理</title>
    <link href="/2018/10/18/Java/spring/Srping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/"/>
    <url>/2018/10/18/Java/spring/Srping%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring核心原理"><a href="#Spring核心原理" class="headerlink" title="Spring核心原理"></a>Spring核心原理</h1><blockquote><p>在Spring中拥有许多的组件，但核心部分主要为：Beans、Core、Context、Expression，其中最为主要的为Core、与Beans，它们提供了最为核心的IOC和依赖注入功能。下文主要从这两个着手进行说明。</p></blockquote><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><p>Spring5架构图：</p><p><img src="https://img-blog.csdn.net/20181018212051213?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="Spring5架构图"></p><p>Spring框架设计理念</p><p>在Spring框架中，其最核心组件应属Beans，Spring-Beans模块是所有应用都必须使用的，它包含了访问配置文件、创建和管理Bean以及进行控制反转(<code>IOC</code>，Inversion of Control)、依赖注入(<code>DI</code>,Dependency Injection)操作相关的所有类。</p><p>在IBM developerWorks一文中(<a href="https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/index.html</a>)这样说道：Spring就是面向Bean编程（BOP,Bean Oriented Programming），Bean 在 Spring 中才是真正的主角。</p><h2 id="Bean生命周期"><a href="#Bean生命周期" class="headerlink" title="Bean生命周期"></a>Bean生命周期</h2><blockquote><p>在Spring中Bean贯穿整个Spring应用，其生命周期应是从Spring容器创建后开始，直至Spring容器主动或被动销毁Bean。</p></blockquote><p>在Spring中，Bean默认为单例模式，即singleton属性默认为false，从BeanFactory中取得的Bean实例为在其初始化就产生一个新的对象，而不是每次获取的时候都产出一个新的对象。当然我们也可以在初始化Bean的时候设置其singleton属性为true，使这个Bean变成多例模式，在getBean的时候，Spring都会产出一个新的对象，类似于Java的中的new Object操作。但设置其为多例，应避免多线程同时存取共享资源所引发的数据不同步问题。</p><p>然后在Spring中，一个Bean从创建到销毁，大致需要经历一下几个步骤（其具体的实现方式，将在下放继续阐述）：</p><ol><li>实例化Bean，根据Spring配置，执行包扫描操作，并对其进行实例化操作。</li><li>根据Spring上线文对实例化的Bean进行配置，其中包括依赖注入。</li><li>判断是否实现了BeanNameAware接口，如果有会执行setBeanName方法去设置这个Bean的id，即自己设置Bean在BeanFactory中的名字。</li><li>判断是否实现了BeanFactoryAware接口，如果有则执行setBeanFactory方法，使得Bean可以获取自己的工厂，从而可以使用工厂的getBean方法。</li><li>判断是否实现了ApplicationContextAware接口，如果有则执行setApplicationContext方法，使得在Bean中可以获取Spring上下文，从而可以获取通过上下文去getBean，该步骤与上一步作用大致相同，但通过该中方式能实现的功能却更加丰富。</li><li>判断是否实现了BeanPostProcessor接口，如果有则调用postProcessBeforeInitialization方法，这一步属于实例化Bean的前置操作，在经过该步骤后，即Bean实例化后同样也会执行一个操作，详情见第八条。</li><li>判断Bean是否配置了init-method，如果有，在Bean初始化之后会默认执行一次init-method指定的方法。</li><li>判断Bean是否实现了BeanPostProcessor接口，如果有则调用postProcessAfterInitialization方法，该方法属于Bean实例化后的操作。在经过这个步骤后，Bean的初始化操作就完成了。</li><li>当Bean实例化完成后，当Bean不再被需要的时候会执行销毁操作。一般是在ApplicationContext执行close方法时会进行销毁操作。</li><li>在销毁过程中，判断是否实现了DisposableBean接口，如果有则执行destroy方法。</li><li>判断Bean是否配置了destroy-method，如果有，在销毁过程中会默认执行一次destroy-method方法。</li></ol><h2 id="Bean初始化过程"><a href="#Bean初始化过程" class="headerlink" title="Bean初始化过程"></a>Bean初始化过程</h2><p>在上一篇关于‘Spring初始化过程’的文章最后写到Spring初始化过程中最后执行的核心方法是AbstractRefreshableApplicationContext类的refresh方法。这里再次将其源码贴出.</p><pre><code class="java">public void refresh() throws BeansException, IllegalStateException {        synchronized (this.startupShutdownMonitor) {               // 1.为应用上下文的刷新做准备--设置时间、记录刷新日志、初始化属性源中的占位符(事实上什么都没做)和验证必要的属性等            // Prepare this context for refreshing.            prepareRefresh();            // 2.让子类刷新内部的bean factory            // Tell the subclass to refresh the internal bean factory.            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();            //3.为上下文准备bean factory            // Prepare the bean factory for use in this context.            prepareBeanFactory(beanFactory);            try {                 // 4.bean factory 后置处理                // Allows post-processing of the bean factory in context subclasses.                postProcessBeanFactory(beanFactory);                // 5.调用应用上下文中作为bean注册的工厂处理器                // Invoke factory processors registered as beans in the context.                invokeBeanFactoryPostProcessors(beanFactory);                // 6.注册拦截创建bean的bean处理器                // Register bean processors that intercept bean creation.                registerBeanPostProcessors(beanFactory);                 // 7.初始化消息源                // Initialize message source for this context.                initMessageSource();                 // 8.初始化事件广播                // Initialize event multicaster for this context.                initApplicationEventMulticaster();                // 9.初始化特定上下文子类中的其它bean                // Initialize other special beans in specific context subclasses.                onRefresh();                 // 10.注册监听器bean                // Check for listener beans and register them.                registerListeners();                // 11.实例化所有的单例bean                // Instantiate all remaining (non-lazy-init) singletons.                finishBeanFactoryInitialization(beanFactory);                 // 12.发布相应的事件                // Last step: publish corresponding event.                finishRefresh();            }catch (BeansException ex) {                if (logger.isWarnEnabled()) {                    logger.warn(&quot;Exception encountered during context initialization - &quot; +                            &quot;cancelling refresh attempt: &quot; + ex);                }                 //销毁错误的资源                // Destroy already created singletons to avoid dangling resources.                destroyBeans();                //重置刷新标志                // Reset &#39;active&#39; flag.                cancelRefresh(ex);                //主动抛出异常                // Propagate exception to caller.                throw ex;            }            finally {                //重置内存缓存                // Reset common introspection caches in Spring&#39;s core, since we                // might not ever need metadata for singleton beans anymore...                resetCommonCaches();            }        }    }</code></pre><p>通过源码可以看出该方法是构建整个IOC容器的完成过程。其中每一行代码都是创建容器的一个流程。其中主要包括以下几个步骤：</p><ol><li>构建BeanFactory</li><li>添加事件处理</li><li>创建 Bean 实例对象并构建Bean关系</li><li>触发被监听的事件 </li></ol><h3 id="构建BeanFactory"><a href="#构建BeanFactory" class="headerlink" title="构建BeanFactory"></a>构建BeanFactory</h3><p>构建BeanFactory的操作主要包括步骤1、2、3。其中第一步在我看来并未做啥重要的事情，我们只需将焦点定在二三步即可。</p><p>在第二步中，obtainFreshBeanFactory方法主要调用了AbstractRefreshableApplicationContext#refreshBeanFactory方法：</p><pre><code class="java">protected final void refreshBeanFactory() throws BeansException {        if (hasBeanFactory()) {            destroyBeans();            closeBeanFactory();        }        try {            DefaultListableBeanFactory beanFactory = createBeanFactory();            beanFactory.setSerializationId(getId());            customizeBeanFactory(beanFactory);            loadBeanDefinitions(beanFactory);            synchronized (this.beanFactoryMonitor) {                this.beanFactory = beanFactory;            }        }        catch (IOException ex) {            throw new ApplicationContextException(&quot;I/O error parsing bean definition source for &quot; + getDisplayName(), ex);        }    }</code></pre><p>在上述代码中清晰可见的说明了BeanFactory的创建过程，首先判断当前容器是否存在BeanFactory，如果有则销毁后在进行创建。通过try/catch中代码可见，BeanFactory的是DefaultListableBeanFactory的实例对象。</p><p>通过Idea查看DefaultListableBeanFactory的类图如下：</p><p><img src="https://img-blog.csdn.net/20181018212106877?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>从这个图中发现除了 BeanFactory 相关的类外，还发现了与 Bean 的 register 相关。这在 refreshBeanFactory 方法中有一行 loadBeanDefinitions(beanFactory) 将找到答案，这个方法将开始加载、解析 Bean 的定义，也就是把用户定义的数据结构转化为 Ioc 容器中的特定数据结构。 </p><p>对于WEB应用而言，其调用的是XmlWebApplicationContext#loadBeanDefinitions方法。</p><p>在BeanFactory创建成功后，Spring将创建的对象交于第三步，即prepareBeanFactory方法为其添加一些 Spring 本身需要的一些工具类。</p><h3 id="添加事件处理"><a href="#添加事件处理" class="headerlink" title="添加事件处理"></a>添加事件处理</h3><p>在第4、5、6步中，这三行代码对 Spring 的功能扩展性起了至关重要的作用 。其中第4、5步的代码主要是让你可以在Bean已经被创建，但未被初始化之前对已经构建的 BeanFactory 的配置做修改；第6步代码主要是让你可以对以后再创建 Bean 的实例对象时添加一些自定义的操作 。</p><p>第4步，即postProcessBeanFactory方法。主要功能为允许上下文能对BeanFactory做一些处理。比如：AbstractRefreshableWebApplicationContext抽象类实现了该方法，并在方法中对Servlet做了一些处理。</p><p>第5步，即invokeBeanFactoryPostProcessors方法主要是获取实现 BeanFactoryPostProcessor 接口的子类。其中主要包括执行BeanDefinitionRegistryPostProcessor类型的postProcessBeanDefinitionRegistry方法，以及执行非BeanDefinitionRegistryPostProcessor类型的postProcessBeanFactory方法。当然，该方法传入的参数是ConfigurableListableBeanFactory 类型，我们仅能对BeanFactory的一些配置做修改。</p><p>第6步，即registerBeanPostProcessors 方法也是可以获取用户定义的实现了 BeanPostProcessor 接口的子类，并执行把它们注册到 BeanFactory 对象中的 beanPostProcessors 变量中。BeanPostProcessor 中声明了两个方法：postProcessBeforeInitialization、postProcessAfterInitialization 分别用于在 Bean 对象初始化时执行。可以执行用户自定义的操作。 </p><p>第7、8、9、10步的方法主要是初始化监听事件和对系统的其他监听者的注册，监听者必须是 ApplicationListener 的子类。 在容器启动时，Spring会调用ApplicationStartListener的onApplicationEvent方法。</p><h3 id="创建-Bean-实例对象并构建Bean关系"><a href="#创建-Bean-实例对象并构建Bean关系" class="headerlink" title="创建 Bean 实例对象并构建Bean关系"></a>创建 Bean 实例对象并构建Bean关系</h3><p>Bean的实例化过程是第11步开始的，即finishBeanFactoryInitialization方法，而在finishBeanFactoryInitialization方法中核心方法又为preInstantiateSingletons（DefaultListableBeanFactory类）。在该方法中，首先拿到所有beanName，然后在实例化的时候会判断bean是否为FactoryBean，顾名思义，这是一个特殊的工厂Bean，可以产生Bean的Bean。</p><p>这里的产生 Bean 是指 Bean 的实例，如果一个类继承 FactoryBean 用户只要实现他的 getObject 方法，就可以自己定义产生实例对象的方法。然而在 Spring 内部这个 Bean 的实例对象是 FactoryBean，通过调用这个对象的 getObject 方法就能获取用户自定义产生的对象，从而为 Spring 提供了很好的扩展性。Spring 获取 FactoryBean 本身的对象是在前面加上 &amp; 来完成的。 </p><p>在Bean的实例化主要分两个步骤：</p><ul><li>Bean不为抽象、单例、非懒加载。<ul><li>判断Bean是否为FactoryBean，是则执行FactoryBean相关的操作，否则直接调用getBean方法产生实例。</li></ul></li><li>在singleton的bean初始化完了之后调用SmartInitializingSingleton的afterSingletonsInstantiated方法。</li></ul><p>通过跟进Bean实例化代码可以发现getBean方法最后指向的是AbstractBeanFactory类的抽象方法createBean，其实现类为AbstractAutowireCapableBeanFactory。在该方法中有一个步骤会去查找Bean的依赖关系，并对其进行依赖注入操作。这里画一个时序图来作说明。</p><p><img src="https://img-blog.csdn.net/20181018212125722?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>需要注意的是，在resolveValueIfNecessary方法中，不仅有调用resolveReference，同样的还有resolveInnerBean，即解析内部的Bean引用。</p><h3 id="触发被监听的事件"><a href="#触发被监听的事件" class="headerlink" title="触发被监听的事件"></a>触发被监听的事件</h3><p>在经历第11步后，上下文的创建就已经基本完成了，这时Spring会执行finishRefresh方法，完成此上下文的刷新。其中包括LifecycleProcessor的onRefresh方法，并执行ContextRefreshedEvent事件。例如：执行SpringMVC的事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在Bean声明周期中曾讲到，Spring在初始化Bean的时候先后对调用BeanPostProcessor接口的postProcessBeforeInitialization、postProcessAfterInitialization方法。利用这一特性我们可以在Bean中实现BeanPostProcessor接口，然后再方法体中加入自己的逻辑。</p><p>对于Spring的IOC容器而言，除了BeanPostProcessor，还有BeanFactoryPostProcessor。顾明思议，BeanFactoryPostProcessor是在构建BeanFactory和构建Bean对象时调用。IOC容器允许BeanFactoryPostProcessor在容器初始化任何Bean之前对BeanFactory配置进行修改。</p><p>在Spring的IOC容器中还有一个特殊的Bean，即FactoryBean，FactoryBean主要用于初始化其他Bean，我们可以自己实现一个FactoryBean，然后添加自定义实例化逻辑。在Spring中，AOP、ORM、事务管理等都是依靠FactoryBean的扩展来实现的。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringApplicationContext初始化过程</title>
    <link href="/2018/10/18/Java/spring/SpringApplicationContext%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/"/>
    <url>/2018/10/18/Java/spring/SpringApplicationContext%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringApplicationContext初始化过程"><a href="#SpringApplicationContext初始化过程" class="headerlink" title="SpringApplicationContext初始化过程"></a>SpringApplicationContext初始化过程</h1><h2 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h2><p>在SpringBoot面世之前。在一般的WEB项目中，项目的启动都是从web.xml开始的，如果我们想在项目中使用Spring，只需在web.xml文件中指定以下内容即可：</p><pre><code>&lt;context-param&gt;        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;        &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt;        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;</code></pre><p>通过以上代码片段不难看出Spring正是通过ContextLoaderListener监听器来进行容器初始化的，查看<code>ContextLoaderListener</code>源码：</p><pre><code class="java">public class ContextLoaderListener extends ContextLoader implements ServletContextListener {    public ContextLoaderListener() {    }    public ContextLoaderListener(WebApplicationContext context) {        super(context);    }    @Override    public void contextInitialized(ServletContextEvent event) {        initWebApplicationContext(event.getServletContext());    }    @Override    public void contextDestroyed(ServletContextEvent event) {        closeWebApplicationContext(event.getServletContext());        ContextCleanupListener.cleanupAttributes(event.getServletContext());    }}</code></pre><p>根据该类中的注释可以看出initWebApplicationContext方法为核心的初始化方法，从initWebApplicationContext方法源代码可以看出Spring初始化容器主要分为以下几个步骤：</p><ol><li>创建容器WebApplicationContext</li><li>验证当前容器是否为可配置的，是则配置并且刷新当前容器 </li><li>将当前创建的容器设置到servlet上下文中</li></ol><h2 id="SpringBoot中的Spring"><a href="#SpringBoot中的Spring" class="headerlink" title="SpringBoot中的Spring"></a>SpringBoot中的Spring</h2><blockquote><p>上文根据一般WEB项目跟踪了Spring容器初始化过程，但是从上诉过程并不能相对明显地看出Spring容器初始化过程。</p></blockquote><p>在SpringBoot面世后，它简化了许多的配置方式，在SpringBoot中只需引入相应的start即可使用Spring，接下来就去看看SpringBoot中的Spring吧。</p><p>通过SpringBoot入口方法<code>SpringApplication.run</code>可以看到以下代码：</p><pre><code class="java">ApplicationArguments applicationArguments = new DefaultApplicationArguments(    args);ConfigurableEnvironment environment = prepareEnvironment(listeners,                                                         applicationArguments);configureIgnoreBeanInfo(environment);Banner printedBanner = printBanner(environment);//创建容器context = createApplicationContext();exceptionReporters = getSpringFactoriesInstances(    SpringBootExceptionReporter.class,    new Class[] { ConfigurableApplicationContext.class }, context);//容器准备工作prepareContext(context, environment, listeners, applicationArguments,               printedBanner);//刷新容器refreshContext(context);</code></pre><p>其中，创建容器容器的方法是createApplicationContext，createApplicationContext方法会根据当前启动类型去初始化不同的Spring容器，主要类型为以下三种：</p><ul><li>NONE：非WEB，普通应用程序</li><li>REACTIVE：反应堆栈Web容器(5.x新加)</li><li>SERVLET：Web容器</li></ul><p>ps:反应堆栈Web容器，即WebFlux框架，该框架是Spring 5.x新加的框架，详细内容请访问SpringCloud中文网：<a href="https://springcloud.cc/web-reactive.html" target="_blank" rel="noopener">https://springcloud.cc/web-reactive.html</a></p><h3 id="prepareContext"><a href="#prepareContext" class="headerlink" title="prepareContext"></a>prepareContext</h3><p>prepareContext方法是做context的准备工作，该方法主要对容器进行一些预设置，源码中，该方法中的postProcessApplicationContext方法向beanFactory中添加了一个beanNameGenerator：</p><pre><code class="java">protected void postProcessApplicationContext(ConfigurableApplicationContext context) {        if (this.beanNameGenerator != null) {            context.getBeanFactory().registerSingleton(                    AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR,                    this.beanNameGenerator);        }        if (this.resourceLoader != null) {            if (context instanceof GenericApplicationContext) {                ((GenericApplicationContext) context)                        .setResourceLoader(this.resourceLoader);            }            if (context instanceof DefaultResourceLoader) {                ((DefaultResourceLoader) context)                        .setClassLoader(this.resourceLoader.getClassLoader());            }        }    }</code></pre><p>其中，BeanNameGenerator用来生成扫描到的Bean在容器中的名字。</p><p>在prepareContext方法中，applyInitializers也是一个颇为重要的内容，通过查询资料发现该方法主要是对已创建的并且未被刷新的容器进行设置的自定义应用上下文初始化器。</p><h3 id="refreshContext"><a href="#refreshContext" class="headerlink" title="refreshContext"></a>refreshContext</h3><p>通过跟踪refreshContext方法不难发现，其最终执行的是AbstractRefreshableApplicationContext类中的refresh方法，其源码如下：</p><pre><code class="java">public void refresh() throws BeansException, IllegalStateException {        Object var1 = this.startupShutdownMonitor;        synchronized(this.startupShutdownMonitor) {         // 为应用上下文的刷新做准备--设置时间、记录刷新日志、初始化属性源中的占位符(事实上什么都没做)和验证必 要的属性等            this.prepareRefresh();            // 让子类刷新内部的bean factory            ConfigurableListableBeanFactory beanFactory = this.obtainFreshBeanFactory();            //为上下文准备bean factory            this.prepareBeanFactory(beanFactory);            try {                // bean factory 后置处理                this.postProcessBeanFactory(beanFactory);                // 调用应用上下文中作为bean注册的工厂处理器                this.invokeBeanFactoryPostProcessors(beanFactory);                // 注册拦截创建bean的bean处理器                this.registerBeanPostProcessors(beanFactory);                // 初始化消息源                this.initMessageSource();                // 初始化事件广播                this.initApplicationEventMulticaster();                // 初始化特定上下文子类中的其它bean                this.onRefresh();                // 注册监听器bean                this.registerListeners();                 // 实例化所有的单例bean                this.finishBeanFactoryInitialization(beanFactory);                 // 发布相应的事件                this.finishRefresh();            } catch (BeansException var9) {                if (this.logger.isWarnEnabled()) {                    this.logger.warn(&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot; + var9);                }             //销毁错误的资源                this.destroyBeans();                //重置刷新标志                this.cancelRefresh(var9);                throw var9;            } finally {                this.resetCommonCaches();            }        }    }</code></pre><p>从以上代码的注释，可以看出refresh方法是Spring容器初始化的过程中加载Bean至关重要的一环，其职责主要是获取Bean，并初始化Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象设计与设计原则</title>
    <link href="/2018/07/16/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%88%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2018/07/16/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%88%E8%AE%A1-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="面向对象设计与设计原则"><a href="#面向对象设计与设计原则" class="headerlink" title="面向对象设计与设计原则"></a>面向对象设计与设计原则</h1><h2 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h2><blockquote><p>面向对象程序设计(<code>Object-oriented programming</code>即<code>OOP</code>)是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。</p></blockquote><p>面向对象编程的两个重要概念是类和对象。</p><p>类：类是变量与作用这些变量的方法集合，事物都具有其自身的属性和方法，通过这些属性和方法可以将不同的物质区分开来。</p><p>对象：对象是类进行实例化后的产物，是一个实体。</p><h2 id="面向对象基本特征"><a href="#面向对象基本特征" class="headerlink" title="面向对象基本特征"></a>面向对象基本特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装是面向对象的特征之一，是对象和类概念的主要特性。</p><p>封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的类进行信息隐藏。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 </p><ul><li>通过继承创建的新类称为“子类”或“派生类”。</li><li>被继承的类称为“基类”、“父类”或“超类”。</li><li>继承的过程，就是从一般到特殊的过程。</li></ul><p>继承概念的实现方式有三类：实现继承、接口继承和可视继承。</p><ul><li>实现继承：使用基类的属性和方法而无需额外编码的能力；</li><li>接口继承：仅使用属性和方法的名称、但是子类必须提供实现的能力；</li><li>可视继承：子窗体（类）使用基窗体（类）的外观和实现代码的能力。</li></ul><p>OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><p>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p><p>实现多态，有两种方式，覆盖和重载。覆盖和重载的区别在于，覆盖在运行时决定，重载是在编译时决定。并且覆盖和重载的机制不同，例如在 Java 中，重载方法的签名(<code>方法签名：方法名+形参列表</code>)必须不同于原先方法的，但对于覆盖签名必须相同。 </p><h2 id="面向对象设计原则"><a href="#面向对象设计原则" class="headerlink" title="面向对象设计原则"></a>面向对象设计原则</h2><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><blockquote><p>开闭原则(<code>Open Close Principle</code>即<code>OCP</code>)是Java中最基础的设计原则，它可以帮助我们建立一个稳定、灵活的系统。</p></blockquote><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。</p><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>我们假设当前有一个书籍销售的功能模块，程序原本的类图如下：</p><p><img src="https://img-blog.csdn.net/20180716105056528?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="面向对象开闭原则1"></p><p>此时，因为书店打折活动，书籍价格会产生变化，我们需要修改程序的getPrice()方法，我们可以修改接口<code>IBook</code>，也可以修改其实现类<code>NovelBook</code>，但是这样的话都会在类中产生两个读取价格的方法，顾这两种方法都不是最优的解决办法。如下图所示，我们新建一个<code>OffNovelBook</code>，让其继承<code>NovelBook</code>并重写<code>getPrice</code>方法，新建高层类，通过复写来改变业务逻辑，减少底层代码的修改，减少代码风险。</p><p><img src="https://img-blog.csdn.net/20180716105120767?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="面向对象开闭原则2"></p><p>我们可以把变化归类为两种类型：</p><ul><li>逻辑变化：只变化了一个逻辑，而不涉及到其他模块的变化，可以直接修改原有类中的方法来实现，但这有一个前提条件是所有依赖或关联都按照相同的逻辑处理。</li><li>子模块变化：一个模块的变化，会对其他模块产生影响，特别是一个低层次的模块变化必然引起高层模块的变化，因此诸如此类的变化应通过扩展来完成。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>抽象约束 ：通过接口或抽象类约束扩展，对扩展进行边界限定 ；参数类型、引用对象尽量使用接口或抽象类，而不是具体的实现类 ；抽象层尽量保持稳定，一旦确定就不要修改 。</li><li>元数据（metadata）控制模块行为 ：元数据就是用来描述环境和数据的数据。尽量使用元数据来控制程序的行为，减少重复开发 。</li><li>封装变化：将相同的变化封装到一个接口或抽象类中，不同的变化应封装在不同的接口或抽象类中，否则即违背了单一职责原则。</li></ul><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><blockquote><p>单一职责原则(<code>Single Responsibility Principle</code>即<code>SRP</code>)，其核心的思想是： 一个类，最好只做一件事，只有一个引起它变化的原因。</p></blockquote><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>单一职责，强调的是职责的分离，在某种程度上对职责的理解，构成了不同类之间耦合关系的设计关键，因此单一职责原则或多或少成为设计过程中一个必须考虑的基础性原则。 </p><h4 id="实例分析-1"><a href="#实例分析-1" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="java">public void addProduct() {    if (!getCuurentUserPermission.contains(&quot;product.add&quot;)) {        //当前用户不具有add权限        return;    }     //业务逻辑}</code></pre><p>从以上代码，我们不难看出，如果该功能对应的权限规则发生了变化 ，那么我们需要对系统中所有诸如此类的类进行修改。这将大大降低程序的稳定性，同时也会大大的提高我们得工作量。</p><p>对于这种情况我们可以新建一个类(权限控制类，比如<code>shiro</code>框架)来做处理。在<code>shrio</code>框架中，可以通过注解的方式去配置权限代码来实现权限控制，同理我们也可自己写一个方法，例如：<code>PermisssionUtils.haveRight(String permissionCode)</code>，在调用<code>addProduct</code>之前去判断是否拥有权限，从而使业务逻辑与权限控制两个职责分离。</p><pre><code class="java">PermisssionUtils.haveRight(&quot;product.add&quot;);addProduct();</code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 </p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><blockquote><p>里氏替换原则(<code>Liskov Substitution Principle</code>,即<code>LSP</code>)：所有引用父类的地方必须能使用其子类的对象。</p></blockquote><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p><strong>所有引用父类的地方必须能使用其子类的对象</strong>：</p><p>在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用父类对象。 </p><h4 id="实例分析-2"><a href="#实例分析-2" class="headerlink" title="实例分析"></a>实例分析</h4><p>在下文关于<code>依赖倒置原则</code>的实例中：</p><pre><code class="java">public class Client {    public static void main(String[] args) {        People jim = new Jim();        Fruit apple = new Apple();        Fruit banana = new Banana();        jim.eat(apple);        jim.eat(banana);    }}</code></pre><p>我们将<code>Banana</code>赋值给其父类<code>Banana</code>，并且在执行<code>jim.eat(Banana)</code>方法时得到了我们期望的结果。</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>里氏替换原则是实现开闭原则的重要方式之一，由于使用父类对象的地方都可以使用子类对象，因此在程序中尽量使用父类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。通常我们会使用接口或者抽象方法定义基类，然后子类中实现父类的方法，并在运行时通过各种手段进行类型选择调用（比如反射）。 </p><p>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏替换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。 </p><p>我们在运用里氏替换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏替换原则是开闭原则的具体实现手段之一。这也就是我们应该更多的依赖抽象，尽量少的依赖实现细节， 也就是依赖倒置原则。 </p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><blockquote><p>依赖倒置原则(<code>Dependency Inversion Principle</code>即<code>DIP</code>)</p></blockquote><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><p><strong>抽象</strong>：抽象类或接口，两者是不能被实例化的</p><p><strong>细节</strong>：抽象具体的实现类，实现接口或继承抽象类所产生的类（可以被实例化的类）</p><h4 id="实例分析-3"><a href="#实例分析-3" class="headerlink" title="实例分析"></a>实例分析</h4><pre><code class="java">//具体Jim人类public class Jim {    public void eat(Apple apple){        System.out.println(&quot;Jim eat &quot; + apple.getName());    }}//具体苹果类public class Apple {    public String getName(){        return &quot;apple&quot;;    }}public class Client {    public static void main(String[] args) {        Jim jim = new Jim();        Apple apple = new Apple();        jim.eat(apple);    }}</code></pre><p>从上述代码，我们不难看出，该程序所表示的人吃苹果。此时我们如果要加一条人吃香蕉，只能先定义一个<code>Banana</code>类，然后在修改<code>Jim</code>类，在其中加一个吃香蕉的方法。加一种尚且如此，那么加n种呢？并且修改<code>Jim</code>类的操作会大大减少系统的稳健性，顾应根据依赖倒置原则对源码进行修改，修改如下：</p><pre><code class="java">//人接口public interface People {    public void eat(Fruit fruit);//人都有吃的方法，不然都饿死了}//水果接口public interface Fruit {    public String getName();//水果都是有名字的}//具体Jim人类public class Jim implements People{    public void eat(Fruit fruit){        System.out.println(&quot;Jim eat &quot; + fruit.getName());    }}//具体苹果类public class Apple implements Fruit{    public String getName(){        return &quot;apple&quot;;    }}//具体香蕉类public class Banana implements Fruit{    public String getName(){        return &quot;banana&quot;;    }}public class Client {    public static void main(String[] args) {        People jim = new Jim();        Fruit apple = new Apple();        Fruit banana = new Banana();        jim.eat(apple);        jim.eat(banana);    }}</code></pre><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>总而言之，依赖倒置原则的核心就是面向接口编程，对于一些底层类都提取抽象类和公共接口，顶层类依赖抽象类或接口而不直接依赖具体实现。</p><p>依赖倒置原则的本质是通过抽象类或接口使各个类或模块的实现彼此独立，不相互影响，实现模块之间的松耦合。</p><p>在多人协作时，我们还可以遵循依赖倒置原则去设计程序，提取抽象，使得各模块相对独立，提升并行开发效率，提高开发速度。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><blockquote><p>接口隔离原则(<code>Interface  Segregation Principle</code>, 即<code>ISP</code>)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</p></blockquote><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><ul><li><p>客户端不应该依赖它不需要的接口。</p></li><li><p>类间的依赖关系应该建立在最小的接口上。</p></li><li><p>接口隔离原则将非常庞大、臃肿的接口拆分成为更小的和更具体的接口，这样客户将会只知道他们感兴趣的方法。</p></li></ul><h4 id="实例分析-4"><a href="#实例分析-4" class="headerlink" title="实例分析"></a>实例分析</h4><p>例如：客户端的用户需要登录、登出、修改密码等操作，而后台的管理员则可以修改用户资料、删除用户等操作。</p><pre><code class="java">public interface UserService{    public void login();    public void logout();    public void changePassword();}public interface AdminUserService extends UserService {    public void updateUser(User user);    public void deleteUser(User user);}</code></pre><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><p>接口隔离原则的目的是系统解开耦合，从而容易重构、更改和重新部署。</p><p>接口隔离原则与前面的单一职责原则相辅相成。但单一职责原则并不保证客户程序只知道必要的信息，甚至在有些情况下接口隔离原则与单一职责原则会出现一定的冲突，设计时我们要根据用户界面,性能等因素决策.。</p><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><blockquote><p>迪米特法则(<code>Law of  Demeter</code>, 即<code>LOD</code>)：一个软件实体应当尽可能少地与其他实体发生相互作用。</p><p>迪米特法则又称为最少知识原则(<code>LeastKnowledge Principle</code>,即<code>LKP</code>) </p></blockquote><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p><strong>不要和“陌生人”说话、只与你的直接朋友通信</strong></p><p>在迪米特法则中，对于一个对象，其朋友包括以下几类： </p><ul><li>当前对象本身(this) </li><li>以参数形式传入到当前对象方法中的对象 </li><li>当前对象的成员对象 </li><li>如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友</li><li>当前对象所创建的对象 </li></ul><p>任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响 。</p><h4 id="实例分析-5"><a href="#实例分析-5" class="headerlink" title="实例分析"></a>实例分析</h4><p>例如：现在用户像好友发送消息，用户可以对单个好友发送消息，也可以发送群消息。</p><p><img src="https://img-blog.csdn.net/20180716105157897?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="迪米特恩法则"></p><p>从上图不难看出，我们专门引入了一个<code>MessageService</code>用与控制消息转发，同时降低<code>UserService</code>与各系统之间的耦合度。当需要新增功能时，只需修改<code>MessageSerice</code>即可。</p><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><p>迪米特法则要求我们在设计系统时，<strong>应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用</strong>。简言之，就是<strong>通过引入一个合理的第三者来降低现有对象之间的耦合度</strong>。 </p><p>在运用迪米特恩法则时应注意以下几点：</p><ul><li>在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及。</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限。</li><li>在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</li></ul><h3 id="组合-聚合复用原则"><a href="#组合-聚合复用原则" class="headerlink" title="组合/聚合复用原则"></a>组合/聚合复用原则</h3><blockquote><p>组合/聚合复用原则（<code>Composite/Aggregate Reuse Principle</code> 即<code>CARP</code>）</p></blockquote><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p>组合和聚合都是对象建模中关联（<code>Association</code>）关系的一种.聚合表示整体与部分的关系，表示“含有”，整体由部分组合而成，部分可以脱离整体作为一个独立的个体存在。组合则是一种更强的聚合，部分组成整体，而且不可分割，部分不能脱离整体而单独存在。在合成关系中，部分和整体的生命周期一样，组合的新的对象完全支配其组成部分，包括他们的创建和销毁。一个合成关系中成分对象是不能与另外一个合成关系共享。 </p><h4 id="实例分析-6"><a href="#实例分析-6" class="headerlink" title="实例分析"></a>实例分析</h4><p>组合/聚合和继承是实现复用的两个基本途径。合成复用原则是指尽量使用合成/聚合，而不是使用继承。 只有当以下的条件全部被满足时，才应当使用继承关系。</p><ul><li>继承复用破坏包装，它把父类的实现细节直接暴露给了子类，这违背了信息隐藏的原则。</li><li>如果父类发生了改变，那么子类也要发生相应的改变，这就直接导致了类与类之间的高耦合，不利于类的扩展、复用、维护等，也带来了系统僵硬和脆弱的设计。 </li><li>合成和聚合的时候新对象和已有对象的交互往往是通过接口或者抽象类进行的，就可以很好的避免上面的不足，而且这也可以让每一个新的类专注于实现自己的任务，符合单一职责原则。 </li></ul><p><strong>判断方法：</strong></p><p>1.<strong>使用“Has-A”和“Is-A”来判断：</strong></p><p>“Has-A”：代表的是 对象和它的成员的从属关系。同一种类的对象，通过它们的属性的不同值来区别。比如一个人可以是医生、警察、教师等。<strong>此时可使用继承关系</strong>。</p><p>“Is-A”：代表的是类之间的继承关系，比如一个人可以是男人、女人。<strong>此时应使用组合/聚合</strong>。</p><p>2.<strong>使用里氏替换原则来判断</strong></p><p> 里氏代换原则是继承复用的基础。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>继承的缺点：</p><ul><li>继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用。虽然简单，但不安全，不能在程序的运行过程中随便改变。</li><li>基类的实现发生了改变，派生类的实现也不得不改变。</li><li>从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</li></ul><p>组合/聚合优点：</p><ul><li>新对象存取<code>组成对象</code>的唯一方法是通过<code>组成对象</code>的<code>getter/setter</code>方法。</li><li>组合复用是黑箱复用，因为组成对象的内部细节是新对象所看不见的。</li><li>组合复用所需要的依赖较少。</li><li>每一个新的类可以将焦点集中到一个任务上。</li><li>组合复用可以在运行时间动态进行，新对象可以动态的引用与成分对象类型相同的对象。</li></ul><p>组合/聚合缺点：组合复用建造的系统会有较多的对象需要管理。</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-总览</title>
    <link href="/2018/07/14/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/"/>
    <url>/2018/07/14/Java/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式-总览"><a href="#设计模式-总览" class="headerlink" title="设计模式-总览"></a>设计模式-总览</h1><blockquote><p>设计模式（Design pattern）是一种被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。即：在某些场景下，针对某类问题的某种通用的解决办法</p></blockquote><h2 id="设计模式分类"><a href="#设计模式分类" class="headerlink" title="设计模式分类"></a>设计模式分类</h2><ul><li><p><strong>创建型模式</strong>：对象实例化的模式，创建型模式用于解耦对象的实例化过程</p></li><li><p><strong>结构型模式</strong>： 把类或对象结合在一起形成一个更大的结构</p></li><li><p><strong>行为型模式</strong> ：类和对象如何交互，及划分责任和算法</p><p><img src="https://img-blog.csdn.net/20180714204639663?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2psaDkxMjAwODU0OA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" srcset="/img/loading.gif" alt="设计模式"></p></li></ul><h3 id="创建型设计模式"><a href="#创建型设计模式" class="headerlink" title="创建型设计模式"></a>创建型设计模式</h3><blockquote><p>创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则 。</p><p>创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p></blockquote><table><thead><tr><th>名称</th><th>重要程度</th><th>说明</th><th>链接</th></tr></thead><tbody><tr><td>工厂模式(Factory)</td><td>★★★★★</td><td>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行 。</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81047337" target="_blank" rel="noopener">工厂模式</a></td></tr><tr><td>抽象工厂模式(Abstract Factory)</td><td>★★</td><td>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81047337" target="_blank" rel="noopener">工厂模式</a></td></tr><tr><td>建造者模式(Builder)</td><td>★★★</td><td>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81054668" target="_blank" rel="noopener">建造者模式</a></td></tr><tr><td>原型模式(Prototype)</td><td>★★★</td><td>用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81143167" target="_blank" rel="noopener">原型模式</a></td></tr><tr><td>单例模式(Singleton)</td><td>★★★★</td><td>在整个应用中保证只有一个类的实例存在。</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81047375" target="_blank" rel="noopener">单例模式</a></td></tr></tbody></table><h3 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h3><table><thead><tr><th>名称</th><th>重要程度</th><th>说明</th><th>链接</th></tr></thead><tbody><tr><td>适配器模式( Adapter )</td><td>★★★★</td><td>定义一个包装类，用于包装不兼容接口的对象</td><td></td></tr><tr><td>桥接模式( Bridge )</td><td>★★★</td><td>将抽象部分与它的实现部分分离，使它们都可以独立地变化</td><td></td></tr><tr><td>组合模式( Composite )</td><td>★★★★</td><td>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性</td><td></td></tr><tr><td>装饰模式( Decorator )</td><td>★★★</td><td>动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活</td><td></td></tr><tr><td>外观模式( Facade )</td><td>★★★★★</td><td>外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81054502" target="_blank" rel="noopener">外观模式</a></td></tr><tr><td>亨元模式( Flyweight )</td><td>★</td><td>运用共享技术有效地支持大量细粒度对象的复用</td><td></td></tr><tr><td>代理模式( Proxy )</td><td>★★★★</td><td>给某一个对象提供一个代 理，并由代理对象控制对原对象的引用</td><td></td></tr></tbody></table><h3 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h3><blockquote><p>行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化 。</p><p>行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。 </p><p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。 </p></blockquote><p>行为型模式主要分为以下两种：</p><ul><li>类行为型模式 ：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责</li><li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式</li></ul><table><thead><tr><th>名称</th><th>重要程度</th><th>说明</th><th>链接</th></tr></thead><tbody><tr><td>责任链模式( Chain of Responsibility )</td><td>★★★</td><td>为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦</td><td></td></tr><tr><td>命令模式( Command )</td><td>★★★★</td><td>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作</td><td></td></tr><tr><td>解释器模式( Interpreter )</td><td>★</td><td></td><td></td></tr><tr><td>迭代器模式( Iterator )</td><td>★★★★★</td><td>提供一种方法访问一个容器对象中各个元素，而又不暴露该对象的内部细节</td><td></td></tr><tr><td>中介者模式( Mediator )</td><td>★★</td><td>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互</td><td></td></tr><tr><td>备忘录模式( Memento )</td><td>★★</td><td>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态</td><td></td></tr><tr><td>观察者模式( Observer )</td><td>★★★★★</td><td>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</td><td><a href="https://blog.csdn.net/jlh912008548/article/details/81054547" target="_blank" rel="noopener">观察者模式</a></td></tr><tr><td>状态模式( State )</td><td>★★★</td><td>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</td><td></td></tr><tr><td>策略模式( Strategy )</td><td>★★★★</td><td>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换</td><td></td></tr><tr><td>模板方法模式( Template Method) )</td><td>★★★</td><td>使得子类可以在不改变算法结构的情况下，重新定义算法中的某一些步骤</td><td></td></tr><tr><td>访问者模式( Visitor )</td><td>★</td><td>提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作</td><td></td></tr></tbody></table><hr><p><strong>参考资料</strong></p><p><a href="http://design-patterns.readthedocs.io/zh_CN/latest/" target="_blank" rel="noopener">http://design-patterns.readthedocs.io/zh_CN/latest/</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
